<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Phase-aware Spectrogram Editor â€” Fixed</title>
<style>
body { background:#111; color:#eee; font-family:sans-serif; margin:0; padding:1em; }
.controls { margin-bottom:1em; }
label { margin-right:1em; display:inline-block; margin-top:0.5em; }
canvas { display:block; background:#000;}
#timeline { display:block; height:40px; }
#status { margin-top:0.5em; font-size:13px; }
</style>
</head>
<body>
<div class="controls">
  <input id="file" type="file" accept=".wav"/>
  <label>FFT exponent (2^exp):
    <input id="fftSize" type="number" value="11" step="1" min="6" max="14">
  </label>
  <label>Hop size:
    <input id="hopSize" type="number" value="512" step="1" min="1">
  </label>
  <label>Brush size:
    <input id="brushSize" type="range" min="1" max="200" value="40">
  </label>
  <label>Brush brightness:
    <input id="brushColor" type="range" min="0" max="255" value="255">
  </label>
  <label>Brush phase:
    <input id="penPhase" type="range" min="0" max="31415" value="0">
  </label>
  <label>Brightness opacity:
    <input id="brushOpacity" type="range" min="0" max="100" value="100">
  </label>
  <label>Phase opacity:
    <input id="phaseOpacity" type="range" min="0" max="100" value="0">
  </label>
  <label>Logscale:
    <input id="logscale" type="range" min="1" max="2" step="0.01" value="1.12">
    <span id="logscaleValue">1.00</span>
  </label>
  <label title="Displays the spectrogram like how it looks when it's downloaded">True scale 
    <input id="trueScale" type="checkbox">
  </label>
  <div class="controls">
    <button class="tool-btn" data-tool="brush">Brush</button>
    <button class="tool-btn" data-tool="rectangle">Rectangle</button>
    <button class="tool-btn" data-tool="line">Line</button>
    <button class="tool-btn" data-tool="blur">Blur</button>
    <button class="tool-btn" data-tool="eraser">Eraser</button>
    <button class="tool-btn" data-tool="image">Image Overlay</button>
    <input type="file" id="overlayFile" accept="image/*" style="display:none;">
  </div>

  <button id="downloadWav">Download WAV</button>
  <button id="downloadButton">Download Spectrogram</button>
  <button id="resetButton" onClick="initEmptyPCM()">Reset audio</button>

  <label>Empty audio length:
    <input id="emptyAudioLength" type="range" min="0.01" max="100" step="0.01" value="10">
    <span id="emptyAudioLengthValue">10</span>
  </label>
</div>
<div class="controls">
  <button id="playPause">Play</button>
  <button id="stop">Stop</button>
</div>

<!-- Timeline canvas -->
<canvas id="timeline" style="height:40px; background:#222;"></canvas>
<div id="canvasWrapper" style="position:relative; display:inline-block; width:100%">
  <canvas id="canvas" style="cursor:crosshair"></canvas>
  <canvas id="overlay" style="background: transparent; position:absolute; left:0; top:0; pointer-events:none; z-index:10;"></canvas>
</div>

<div id="status"></div>

<script>
let currentTool = "brush";
const toolButtons = document.querySelectorAll(".tool-btn");
toolButtons.forEach(btn => {
  if(btn.dataset.tool === currentTool) {
    btn.style.background = "#444"; 
  }
});
toolButtons.forEach(btn => {
  btn.addEventListener("click", () => {
    currentTool = btn.dataset.tool;
    toolButtons.forEach(b => b.style.background = "");
    btn.style.background = "#444"; 
    if(currentTool === "image") overlayFile.click();
  });
});

const overlayFile = document.getElementById("overlayFile");
let overlayImage = null;
overlayFile.addEventListener("change", e => {
  const f = e.target.files[0];
  if (!f) return;
  const img = new Image();
  img.onload = () => overlayImage = img;
  img.src = URL.createObjectURL(f);
});

function nextPow2(v) { return 1 << Math.ceil(Math.log2(v)); }

function fft_inplace(re, im) {
  const n = re.length;
  if (n !== im.length) throw new Error('Mismatched lengths');
  const levels = Math.floor(Math.log2(n));
  if ((1 << levels) !== n) throw new Error('Length must be power of 2');

  for (let i = 0; i < n; i++) {
    let j = 0;
    for (let k = 0; k < levels; k++) j = (j << 1) | ((i >>> k) & 1);
    if (j > i) {
      [re[i], re[j]] = [re[j], re[i]];
      [im[i], im[j]] = [im[j], im[i]];
    }
  }

  for (let size = 2; size <= n; size <<= 1) {
    const half = size >>> 1;
    const theta = -2 * Math.PI / size;
    const wpr = Math.cos(theta);
    const wpi = Math.sin(theta);
    for (let i = 0; i < n; i += size) {
      let wr = 1, wi = 0;
      for (let j = 0; j < half; j++) {
        const k = i + j;
        const l = k + half;
        const tr = wr * re[l] - wi * im[l];
        const ti = wr * im[l] + wi * re[l];
        re[l] = re[k] - tr;
        im[l] = im[k] - ti;
        re[k] += tr;
        im[k] += ti;
        const tmp = wr;
        wr = tmp * wpr - wi * wpi;
        wi = tmp * wpi + wi * wpr;
      }
    }
  }
}

function ifft_inplace(re, im) {
  for (let i = 0; i < re.length; i++) im[i] = -im[i];
  fft_inplace(re, im);
  for (let i = 0; i < re.length; i++) { re[i] /= re.length; im[i] = -im[i] / re.length; }
}

function hann(N) {
  const w = new Float32Array(N);
  for (let i = 0; i < N; i++) w[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (N - 1)));
  return w;
}

function overlapAdd(signal, N) {
  const hop = N / 2; 
  const window = hann(N);
  const out = new Float32Array(signal.length + N); 
  const re = new Float32Array(N);
  const im = new Float32Array(N);

  for (let pos = 0; pos < signal.length; pos += hop) {

    for (let i = 0; i < N; i++) {
      re[i] = (pos + i < signal.length ? signal[pos + i] : 0) * window[i];
      im[i] = 0;
    }

    fft_inplace(re, im);

    ifft_inplace(re, im);

    for (let i = 0; i < N; i++) {
      out[pos + i] += re[i] * window[i]; 
    }
  }

  return out.subarray(0, signal.length); 
}

const fileEl=document.getElementById("file");
const canvas=document.getElementById("canvas");
const ctx=canvas.getContext("2d");
const overlayCanvas = document.getElementById("overlay");
const overlayCtx = overlayCanvas.getContext("2d");
const status=document.getElementById("status");
const fftSizeEl=document.getElementById("fftSize");
const hopSizeEl=document.getElementById("hopSize");
const brushSizeEl=document.getElementById("brushSize");
const brushOpacityEl=document.getElementById("brushOpacity");
const phaseOpacityEl=document.getElementById("phaseOpacity");
const brushColorEl=document.getElementById("brushColor");
const penPhaseEl=document.getElementById("penPhase");
const logscaleEl = document.getElementById("logscale");
const logscaleValueEl = document.getElementById("logscaleValue");
const emptyAudioLengthEl = document.getElementById("emptyAudioLength");
const emptyAudioLengthValueEl = document.getElementById("emptyAudioLengthValue");
let trueScale = document.getElementById("trueScale").checked;

let pcm=null, sampleRate=44100, pos=0, fftSize=1024, hop=512, win=hann(1024);
let framesTotal=0, x=0, rendering=false;
let imageBuffer=null;
let currentCursorX = 0;
let iLow = null;
let iHigh = null;
let specCanvas = document.createElement("canvas");
let specCtx = specCanvas.getContext("2d");

let mags = null;     
let phases = null;   
let specWidth = 0;
let specHeight = 0;

let brushSize=parseInt(brushSizeEl.value);
let brushOpacity=parseInt(brushOpacityEl.value)/100;
let phaseOpacity=parseInt(phaseOpacityEl.value)/100;
let brushColor=parseInt(brushColorEl.value); 
let penPhase=parseInt(penPhaseEl.value)/10000;
brushSizeEl.addEventListener("input",()=>brushSize=parseInt(brushSizeEl.value));
brushOpacityEl.addEventListener("input",()=>brushOpacity=parseInt(brushOpacityEl.value)/100);
phaseOpacityEl.addEventListener("input",()=>phaseOpacity=parseInt(phaseOpacityEl.value)/100);
brushColorEl.addEventListener("input",()=>brushColor=parseInt(brushColorEl.value));
penPhaseEl.addEventListener("input", ()=>penPhase = parseInt(penPhaseEl.value) / 10000);

function initEmptyPCM() {
    const sampleRateLocal = 44100;
    const duration = emptyAudioLengthEl.value; 
    const length = sampleRateLocal * duration; 
    const tinyNoiseAmplitude = 0.0001; 

    const pcmArray = new Float32Array(length);
    for (let i = 0; i < length; i++) {
        pcmArray[i] = (Math.random() * 2 - 1) * tinyNoiseAmplitude; 
    }

    pcm = pcmArray;
    sampleRate = sampleRateLocal;

    restartRender();
}

logscaleValueEl.textContent = parseFloat(logscaleEl.value).toFixed(2);
logscaleEl.addEventListener("input", ()=> {
  logscaleValueEl.textContent = parseFloat(logscaleEl.value).toFixed(2);
  renderFullSpectrogramToImage();
});

emptyAudioLengthValueEl.textContent = parseFloat(emptyAudioLengthEl.value).toFixed(2);
emptyAudioLengthEl.addEventListener("input", ()=> {
  emptyAudioLengthValueEl.textContent = parseFloat(emptyAudioLengthEl.value).toFixed(2);
  renderFullSpectrogramToImage();
});

let audioCtx = null;
function ensureAudioCtx(){
  if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
}

let startTime=0; 
let audioProcessed=0; 

fileEl.addEventListener("change", async e=>{
    const f=e.target.files[0]; if(!f)return;
    const buf=await f.arrayBuffer();
    ensureAudioCtx();
    const ab = await audioCtx.decodeAudioData(buf.slice(0));
    pcm = new Float32Array(ab.getChannelData(0));
    sampleRate = ab.sampleRate || 44100;

    status.textContent=`Loaded ${f.name}, ${pcm.length} samples @ ${sampleRate} Hz`;
    restartRender();
});

fftSizeEl.addEventListener("change",restartRender);
hopSizeEl.addEventListener("change",restartRender);
document.getElementById("trueScale").addEventListener("change",restartRender);

function restartRender(){
    if(!pcm) return;
    console.log('hi')

    trueScale = document.getElementById("trueScale").checked;
    const exponent = Math.max(6, Math.min(14, parseInt(fftSizeEl.value)||10));
    fftSize = 1 << exponent;
    hop = Math.max(1, parseInt(hopSizeEl.value) || Math.floor(fftSize/2));
    win = hann(fftSize);

    framesTotal = Math.max(1, Math.floor((pcm.length - fftSize) / hop) + 1);
    if (iLow == null) {
      iLow = 0;
      iHigh = framesTotal;
    }
    console.log(iLow);

    const freqBins = Math.floor(fftSize / 2);
    canvas.width = framesTotal;
    canvas.height = freqBins;
    if (trueScale) {
      const maxHeight = 600;
      const containerWidth = canvas.parentElement.clientWidth;
      const scaleX = containerWidth / framesTotal;
      const scaleY = maxHeight / freqBins;
      const scale = Math.min(scaleX, scaleY, 1);

      canvas.style.width = (canvas.width * scale) + "px";
      canvas.style.height = (canvas.height * scale) + "px";
    } else {
      canvas.style.width = "100%";
      canvas.style.height = "500px";
    }

    overlayCanvas.style.width = canvas.style.width;
    overlayCanvas.style.height = canvas.style.height;

    specWidth = canvas.width;
    specHeight = canvas.height;

    syncOverlaySize();

    const timeline = document.getElementById('timeline');
    timeline.width = window.innerWidth*1.2;
    timeline.style.width = canvas.style.width;
    timeline.height = 40;

        // full-size image buffer and offscreen canvas (full spectrogram)
    imageBuffer = new ImageData(canvas.width, canvas.height);
    specWidth = canvas.width;
    specHeight = canvas.height;

    specCanvas.width = specWidth;
    specCanvas.height = specHeight;
    specCtx.clearRect(0, 0, specCanvas.width, specCanvas.height);
    specCtx.putImageData(imageBuffer, 0, 0);

    // keep your mags/phases in sync
    mags = new Float32Array(specWidth * specHeight);
    phases = new Float32Array(specWidth * specHeight);
    for(let i=0;i<specWidth*specHeight;i++){ mags[i]=0; phases[i]=0; }

    // start rendering at the current left view frame (iLow)
    const startFrame = Math.max(0, Math.floor(iLow || 0));
    pos = startFrame * hop;
    x = startFrame;
    rendering = true;

    ctx.fillStyle = "black";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    startTime = performance.now();
    audioProcessed = 0;

    stopSource(true);
    requestAnimationFrame(drawLoop);
}

function magPhaseToRGB(mag, phase){

    const h = (phase / (2*Math.PI) + 1) % 1; 
    const s = 1;
    const v = Math.min(mag/60,1);
    const c = v*s;
    const m = v - c;
    const hp = h*6;
    const x = c*(1-Math.abs(hp%2-1));
    let r=0,g=0,b=0;
    if(hp < 1){ r=c; g=x; b=0; }
    else if(hp < 2){ r=x; g=c; b=0; }
    else if(hp < 3){ r=0; g=c; b=x; }
    else if(hp < 4){ r=0; g=x; b=c; }
    else if(hp < 5){ r=x; g=0; b=c; }
    else { r=c; g=0; b=x; }
    return [Math.floor((r+m)*255), Math.floor((g+m)*255), Math.floor((b+m)*255)];
}

function rgbToMagPhase(r, g, b) {
    let rf=r/255,gf=g/255,bf=b/255;
    const mx=Math.max(rf,gf,bf), mn=Math.min(rf,gf,bf);
    const d=mx-mn;
    let h=0,s=0,v=mx;
    s=mx===0?0:d/mx;
    if(d!==0){
        if(mx===rf) h=((gf-bf)/d)%6;
        else if(mx===gf) h=(bf-rf)/d+2;
        else h=(rf-gf)/d+4;
        h/=6; if(h<0) h+=1;
    }
    const phase=h*2*Math.PI;
    const mag=v*60;
    return [mag, phase];
}

function getLogScaleSlider() { return Math.max(1, parseFloat(logscaleEl.value) || 1); }

function binToDisplayY(bin, h) {
    if (!h) return 0;
    const s = getLogScaleSlider();
    if (s <= 1.0000001) {
        return Math.round(h - 1 - bin); 
    } else {
        const a = s - 1;
        const denom = Math.log(1 + a * (h - 1));
        if (!isFinite(denom) || denom === 0) return Math.round(h - 1 - bin);
        const t = Math.log(1 + a * bin) / denom; 
        const y = (1 - t) * (h - 1);
        return Math.round(y);
    }
}

function displayYToBin(y, h) {
    if (!h) return 0;
    const s = getLogScaleSlider();
    if (s <= 1.0000001) {
        return Math.max(0, Math.min(h - 1, Math.round(h - 1 - y)));
    } else {
        const a = s - 1;
        const denom = Math.log(1 + a * (h - 1));
        if (!isFinite(denom) || denom === 0) return Math.max(0, Math.min(h - 1, Math.round(h - 1 - y)));
        const t = 1 - (y / (h - 1));
        const raw = (Math.exp(t * denom) - 1) / a;
        const clamped = Math.max(0, Math.min(h - 1, Math.round(raw)));
        return clamped;
    }
}

function drawLoop() {
    if (!rendering) return;

    const framesPerTick = Math.min(200, Math.max(4, Math.floor(specWidth/8)));

    const h = specHeight;
    const w = specWidth;

    for (let f = 0; f < framesPerTick; f++) {
        if (pos + fftSize > pcm.length) { rendering = false; break; }

        const re = new Float32Array(fftSize);
        const im = new Float32Array(fftSize);
        for (let i = 0; i < fftSize; i++) { re[i] = (pcm[pos + i] || 0) * win[i]; im[i] = 0; }
        fft_inplace(re, im);

        for (let bin = 0; bin < h; bin++) {
            const mag = Math.hypot(re[bin] || 0, im[bin] || 0);
            const phase = Math.atan2(im[bin] || 0, re[bin] || 0);
            const idx = x * h + bin; 
            mags[idx] = mag;
            phases[idx] = phase;
        }

        for (let yy = 0; yy < h; yy++) {
            const mappedBin = displayYToBin(yy, h);
            const idx = x * h + mappedBin;
            const mag = mags[idx] || 0;
            const phase = phases[idx] || 0;
            const [r, g, b] = magPhaseToRGB(mag, phase);
            const pix = (yy * w + x) * 4; 
            imageBuffer.data[pix]     = r;
            imageBuffer.data[pix + 1] = g;
            imageBuffer.data[pix + 2] = b;
            imageBuffer.data[pix + 3] = 255;
        }

        pos += hop; x++;
        audioProcessed += hop;
        if (x >= w) { rendering = false; 
            if (!painting) playPCM(true);
            break;
        }
    }

    specCtx.putImageData(imageBuffer, 0, 0);
    renderView();
    drawCursor();
    const elapsedMS = performance.now() - startTime;
    const elapsedSec = elapsedMS / 1000;
    const speed = audioProcessed / Math.max(1e-6, elapsedSec); 
    const audioSec = pcm.length / 44100; 
    const processedSec = audioProcessed / 44100;

    status.textContent = `Progress: ${(100*pos/pcm.length).toFixed(1)}% | ` 
        + `Elapsed: ${elapsedSec.toFixed(2)}s | `
        + `Audio processed: ${processedSec.toFixed(2)}/${audioSec.toFixed(2)}s | `
        + `Speed: ${(speed/44100).toFixed(2)}x realtime`;
    if (rendering) requestAnimationFrame(drawLoop);
}

function drawCursor(){
    
    const x = (currentCursorX-iLow) * canvas.width / (iHigh-iLow)
    overlayCtx.clearRect(0,0, canvas.width, canvas.height);
    overlayCtx.strokeStyle = "#0f0";
    overlayCtx.lineWidth = Math.max(1, Math.min(4, framesTotal/500));
    overlayCtx.beginPath();
    overlayCtx.moveTo(x + 0.5, 0);
    overlayCtx.lineTo(x + 0.5, specHeight);
    overlayCtx.stroke();
}

function updateCanvasScroll() {
    if (!imageBuffer) return;

    const viewWidth = iHigh - iLow;      // number of frames in view
    const viewHeight = specHeight;       // full frequency range

    // Keep canvas full-resolution
    canvas.width = viewWidth;
    canvas.height = viewHeight;

    // Put full spectrogram into an offscreen canvas
    const off = document.createElement("canvas");
    off.width = specWidth;
    off.height = specHeight;
    const offCtx = off.getContext("2d");
    specCtx.putImageData(imageBuffer, 0, 0);
    renderView();

    // Crop the correct slice from iLowâ†’iHigh
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(
        off,
        iLow, 0,                // source x, y
        viewWidth, viewHeight,  // source w, h
        0, 0,                   // dest x, y
        canvas.width, canvas.height // dest w, h
    );

    // Overlay must match canvas dimensions
    overlayCanvas.width = canvas.width;
    overlayCanvas.height = canvas.height;
    overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

    drawCursor();
}

function renderView() {
    if (!specCanvas || !imageBuffer) return;

    // number of frames shown
    const viewWidth = Math.max(1, Math.floor(iHigh - iLow));
    const viewHeight = specHeight;

    // set visible canvas pixel size to viewWidth x viewHeight
    canvas.width = viewWidth;
    canvas.height = viewHeight;

    // draw the slice [iLow..iHigh) from the offscreen full spec into visible canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(
        specCanvas,
        Math.max(0, Math.floor(iLow)), 0,   // src x, y (integer)
        viewWidth, viewHeight,              // src w, h
        0, 0,                                // dst x, y
        canvas.width, canvas.height         // dst w, h
    );

    // sync overlay to same pixel size
    overlayCanvas.width = canvas.width;
    overlayCanvas.height = canvas.height;
    overlayCanvas.style.width = canvas.style.width;
    overlayCanvas.style.height = canvas.style.height;
}

let painting=false;
let paintedPixels=null;

let startX = null, startY = null;

function getCanvasCoords(e){
    const rect=canvas.getBoundingClientRect();
    const scaleX=canvas.width/rect.width;
    const scaleY=canvas.height/rect.height;
    return {cx:(e.clientX-rect.left)*scaleX, cy:(e.clientY-rect.top)*scaleY, scaleX, scaleY};
}

function syncOverlaySize() {
  overlayCanvas.width = canvas.width;
  overlayCanvas.style.width = canvas.style.width;
  overlayCanvas.height = canvas.height;

  overlayCanvas.style.height = canvas.style.height;
}

let pendingPreview = false;
let lastPreviewCoords = null;

function previewShape(cx, cy) {

  lastPreviewCoords = { cx, cy };
  if (pendingPreview) return;
  pendingPreview = true;
  requestAnimationFrame(() => {
    pendingPreview = false;
    const coords = lastPreviewCoords;
    overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

    overlayCtx.strokeStyle = "#fff";
    overlayCtx.lineWidth = Math.max(1, Math.min(4, Math.floor(framesTotal / 500)));

    if (currentTool === "rectangle" && startX !== null && startY !== null) {
      overlayCtx.strokeRect(startX + 0.5, startY + 0.5, coords.cx - startX, coords.cy - startY);
    } else if (currentTool === "line" && startX !== null && startY !== null) {
      overlayCtx.beginPath();
      overlayCtx.moveTo(startX + 0.5, startY + 0.5);
      overlayCtx.lineTo(coords.cx + 0.5, coords.cy + 0.5);
      overlayCtx.stroke();
    }
  });
}

function commitShape(cx, cy) {
    // Full spec dimensions (for indexing imageBuffer/mags/phases)
    const fullW = specWidth;
    const fullH = specHeight;
    const bo = brushOpacity;
    const po = phaseOpacity;
    const brushMag = (brushColor / 255) * 128;
    const brushPhase = penPhase;

    function drawPixelIntFrame(xFrame, yDisplay, mag, phase, bo, po) {
        const xI = Math.round(xFrame);
        const yI = Math.round(yDisplay);
        if (xI < 0 || xI >= fullW || yI < 0 || yI >= fullH) return;
        const bin = displayYToBin(yI, fullH);
        const idx = xI * fullH + bin;
        if (idx < 0 || idx >= mags.length) return;
        const oldMag = mags[idx] || 0;
        const oldPhase = phases[idx] || 0;
        const newMag = oldMag * (1 - bo) + mag * bo;
        const newPhase = oldPhase + po * (phase - oldPhase);
        mags[idx] = newMag;
        phases[idx] = newPhase;
        const displayY = binToDisplayY(bin, fullH);
        const pix = (displayY * fullW + xI) * 4;
        const [r, g, b] = magPhaseToRGB(newMag, newPhase);
        imageBuffer.data[pix]     = r;
        imageBuffer.data[pix + 1] = g;
        imageBuffer.data[pix + 2] = b;
        imageBuffer.data[pix + 3] = 255;
    }

    // visible X coordinates (canvas-space) for start and end
    const visStartX = startX == null ? cx : startX;
    const visEndX = cx;
    // visible Y coordinates
    const visStartY = startY == null ? cy : startY;
    const visEndY = cy;

    // Convert visible X -> global frame indices by adding iLow (left offset)
    // Keep the (x,y) pairing intact when possibly swapping endpoints.
    let x0Frame, y0Vis, x1Frame, y1Vis;
    const leftFrame = Math.round(visStartX + (iLow || 0));
    const rightFrame = Math.round(visEndX + (iLow || 0));

    if (leftFrame <= rightFrame) {
        x0Frame = leftFrame;  y0Vis = visStartX <= visEndX ? visStartY : visEndY;
        x1Frame = rightFrame; y1Vis = visStartX <= visEndX ? visEndY   : visStartY;
    } else {
        // when the "start" was to the right visually, maintain correct pairing
        x0Frame = rightFrame; y0Vis = visStartX <= visEndX ? visEndY   : visStartY;
        x1Frame = leftFrame;  y1Vis = visStartX <= visEndX ? visStartY : visEndY;
    }

    // clamp
    x0Frame = Math.max(0, Math.min(fullW - 1, x0Frame));
    x1Frame = Math.max(0, Math.min(fullW - 1, x1Frame));
    y0Vis = Math.max(0, Math.min(fullH - 1, Math.round(y0Vis)));
    y1Vis = Math.max(0, Math.min(fullH - 1, Math.round(y1Vis)));

    if (currentTool === "rectangle") {
        const minX = Math.min(x0Frame, x1Frame);
        const maxX = Math.max(x0Frame, x1Frame);
        const minY = Math.min(y0Vis, y1Vis);
        const maxY = Math.max(y0Vis, y1Vis);
        for (let yy = minY; yy <= maxY; yy++) {
            for (let xx = minX; xx <= maxX; xx++) {
                drawPixelIntFrame(xx, yy, brushMag, brushPhase, bo, po);
            }
        }
    } else if (currentTool === "line") {
        // convert visible startX/startY â†’ globals (frame indices for X, display Y unchanged)
        let visStartX = (startX == null ? cx : startX);
        let visStartY = (startY == null ? cy : startY);
        
        // x in global frame coordinates (so indexing into mags/phases/imageBuffer works)
        let x0 = Math.round(visStartX + (iLow || 0));
        let y0 = Math.round(visStartY);
        const x1 = Math.round(cx + (iLow || 0));
        const y1 = Math.round(cy);
        
        const dx = Math.abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
        const dy = Math.abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
        let err = (dx > dy ? dx : -dy) / 2;
        
        while (true) {
            // drawPixelInt must accept X as a global frame index (0..specWidth-1)
            drawPixelIntFrame(x0, y0, brushMag, brushPhase, bo, po);
            if (x0 === x1 && y0 === y1) break;
            const e2 = err;
            if (e2 > -dx) { err -= dy; x0 += sx; }
            if (e2 < dy)  { err += dx; y0 += sy; }
        }
    }

    specCtx.putImageData(imageBuffer, 0, 0);
    renderView();
}


// Replace existing paint(...) with this:
function paint(cx, cy, scaleX, scaleY, startX_vis, startY_vis) {
    if (!mags || !phases) return;

    // IMPORTANT: cx is expected to be a global frame index (i.e. caller must pass cx + iLow).
    // In your mouse handlers you already do that, except for commitShape which we fixed above.
    const fullW = specWidth;
    const fullH = specHeight;
    const po = currentTool === "eraser" ? 1 : phaseOpacity;
    const bo = currentTool === "eraser" ? 1 : brushOpacity;

    function drawPixelFrame(xFrame, yDisplay, mag, phase, bo, po) {
        const xI = Math.round(xFrame);
        const yI = Math.round(yDisplay);
        if (xI < 0 || xI >= fullW || yI < 0 || yI >= fullH) return;
        const bin = displayYToBin(yI, fullH);
        const idx = xI * fullH + bin;
        if (idx < 0 || idx >= mags.length) return;
        const oldMag = mags[idx] || 0;
        const oldPhase = phases[idx] || 0;
        const newMag = oldMag * (1 - bo) + mag * bo;
        const newPhase = oldPhase + po * (phase - oldPhase);
        mags[idx] = newMag;
        phases[idx] = newPhase;
        const displayY = binToDisplayY(bin, fullH);
        const pix = (displayY * fullW + xI) * 4;
        const [r, g, b] = magPhaseToRGB(newMag, newPhase);
        imageBuffer.data[pix] = r;
        imageBuffer.data[pix + 1] = g;
        imageBuffer.data[pix + 2] = b;
        imageBuffer.data[pix + 3] = 255;
    }

    if (currentTool === "brush" || currentTool === "eraser") {
        // cx is global frame index; cy is display Y (0..canvas.height-1)
        // Turn brush radii into frame/display coordinates:
        // radiusY is in display pixels, radiusX should be in frames. We approximate by scaling using scale values.
        // scaleX = canvas.width / rect.width ; scaleY = canvas.height / rect.height
        const radiusY = brushSize;
        // radius in frames: brushSize in display px -> convert using scaleX (frames per display pixel)
        // compute framesPerDisplayPixel = (specWidth / canvas.getBoundingClientRect().width)
        // but we don't want to access DOM heavily here; use scaleX to approximate:
        // scaleX provided was canvas.width/rect.width; when canvas.width==viewWidth, frames per display pixel =
        // (specWidth / viewWidth). So:
        const rect = canvas.getBoundingClientRect();
        const viewWidth = canvas.width; // visible frames
        const framesPerDisplayPixel = (fullW / Math.max(1, viewWidth));
        const radiusXFrames = Math.max(1, Math.round((brushSize) * framesPerDisplayPixel));

        const minXFrame = Math.max(0, Math.floor(cx - radiusXFrames));
        const maxXFrame = Math.min(fullW - 1, Math.ceil(cx + radiusXFrames));
        const minY = Math.max(0, Math.floor(cy - radiusY));
        const maxY = Math.min(fullH - 1, Math.ceil(cy + radiusY));

        const brushMag = currentTool === "eraser" ? 0 : (brushColor / 255) * 128;
        const brushPhase = currentTool === "eraser" ? 0 : penPhase;

        for (let yy = minY; yy <= maxY; yy++) {
            for (let xx = minXFrame; xx <= maxXFrame; xx++) {
                const dx = xx - cx;
                const dy = yy - cy;
                // elliptical mask (approx)
                if ((dx * dx) / (radiusXFrames * radiusXFrames) + (dy * dy) / (radiusY * radiusY) > 1) continue;
                drawPixelFrame(xx, yy, brushMag, brushPhase, bo, po);
            }
        }
    } else if (currentTool === "blur") {
        const radius = brushSize;
        // blur operates in display coords; but we map neighbors into frames/bin correctly
        const minXFrame = Math.max(0, Math.floor(cx - radius));
        const maxXFrame = Math.min(fullW - 1, Math.ceil(cx + radius));
        const minY = Math.max(0, Math.floor(cy - radius));
        const maxY = Math.min(fullH - 1, Math.ceil(cy + radius));

        for (let yy = minY; yy <= maxY; yy++) {
            for (let xx = minXFrame; xx <= maxXFrame; xx++) {
                let sumMag = 0, sumPhase = 0, count = 0;
                for (let oy = -1; oy <= 1; oy++) {
                    for (let ox = -1; ox <= 1; ox++) {
                        const nx = xx + ox, ny = yy + oy;
                        if (nx < 0 || ny < 0 || nx >= fullW || ny >= fullH) continue;
                        const nidx = nx * fullH + displayYToBin(ny, fullH);
                        sumMag += mags[nidx] || 0;
                        sumPhase += phases[nidx] || 0;
                        count++;
                    }
                }
                if (count > 0) drawPixelFrame(xx, yy, sumMag / count, sumPhase / count, bo, po);
            }
        }
    } else if (currentTool === "image" && overlayImage) {
        // draw overlay image into full-frame coords: cx is center frame index, cy is display Y
        const scale = brushSize / Math.max(overlayImage.width, overlayImage.height) * fftSize / 400;
        const overlayW = Math.max(1, Math.round(overlayImage.width * scale));
        const overlayH = Math.max(1, Math.round(overlayImage.height * scale));
        const ox = Math.floor(cx - overlayW / 2);
        const oy = Math.floor(cy - overlayH / 2);

        const tempCanvas = document.createElement("canvas");
        tempCanvas.width = overlayW;
        tempCanvas.height = overlayH;
        const tctx = tempCanvas.getContext("2d");
        tctx.drawImage(overlayImage, 0, 0, overlayW, overlayH);
        const imgData = tctx.getImageData(0, 0, overlayW, overlayH);

        for (let yy = 0; yy < overlayH; yy++) {
            for (let xx = 0; xx < overlayW; xx++) {
                const pix = (yy * overlayW + xx) * 4;
                const r = imgData.data[pix];
                const g = imgData.data[pix + 1];
                const b = imgData.data[pix + 2];
                const [mag, phase] = rgbToMagPhase(r, g, b);
                const cxPix = ox + xx;
                const cyPix = oy + yy;
                if (cxPix >= 0 && cyPix >= 0 && cxPix < fullW && cyPix < fullH) {
                    drawPixelFrame(cxPix, cyPix, mag, phase, brushOpacity, phaseOpacity);
                }
            }
        }
    }

    specCtx.putImageData(imageBuffer, 0, 0);
    renderView();
}


let sineOsc = null;
let sineGain = null;
function setSineFreq(cy) {
    const h = specHeight;
    const s = parseFloat(logscaleEl.value); 

    let bin;
    if (s <= 1.0000001) {

        bin = h - 1 - cy;
    } else {

        const a = s - 1;
        const denom = Math.log(1 + a * (h - 1));
        const t = 1 - cy / (h - 1);
        bin = (Math.exp(t * denom) - 1) / a;
    }

    bin = Math.max(0, Math.min(h - 1, bin));

    const freq = bin * sampleRate / fftSize;

    sineOsc.frequency.setTargetAtTime(freq, audioCtx.currentTime, 0.01);
}

canvas.addEventListener("mousedown", e=>{
    if (!mags || !phases) return;
    painting = true;
    stopSource();
    paintedPixels = new Set();
    const {cx,cy,scaleX,scaleY} = getCanvasCoords(e);
    startX = cx; startY = cy;
    overlayCtx.clearRect(0,0,overlayCanvas.width, overlayCanvas.height);

    if (!(currentTool === "rectangle" || currentTool === "line")) {
        paint(cx+iLow,cy,scaleX,scaleY,startX,startY);
    }

    ensureAudioCtx();
    mouseDown = true;
    currentFrame = Math.floor(cx);
    playFrame(currentFrame);

    if (!sineOsc) {
        sineOsc = audioCtx.createOscillator();
        sineOsc.type = "sine";
        sineGain = audioCtx.createGain();
        sineGain.gain.value = 0.2;
        sineOsc.connect(sineGain).connect(audioCtx.destination);
        setSineFreq(cy);
        sineOsc.start();
    }
});

canvas.addEventListener("mousemove", e=>{
    if(!painting) return;
    const {cx,cy,scaleX,scaleY} = getCanvasCoords(e);

    if (currentTool === "rectangle" || currentTool === "line") {
      previewShape(cx, cy);
    } else {
      overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
      paint(cx+iLow,cy,scaleX,scaleY,startX,startY);
    }

    currentFrame = Math.floor(cx);
    if (mouseDown) {
        playFrame(currentFrame);

        if (sineOsc) setSineFreq(cy);
    }

    currentCursorX = currentFrame;
    drawCursor();
});

document.addEventListener("mouseup", e => {
    if (!mags || !phases || !painting) return;

    painting = false;
    paintedPixels = null;
    mouseDown = false;
    stopSource();
    if (sineOsc) {
        sineOsc.stop();
        sineOsc.disconnect();
        sineOsc = null;
        sineGain = null;
    }
    if (!pcm) { 
        playPCM(); 
        return; 
    }
    const { cx, cy } = getCanvasCoords(e);
    if (currentTool === "rectangle" || currentTool === "line") {
        commitShape(cx, cy); 
        overlayCtx.clearRect(0,0,overlayCanvas.width,overlayCanvas.height);
    }

    startX=startY=null;

    const newPCM = new Float32Array(pcm.length);
    const overlapCount = new Float32Array(pcm.length);
    const window = new Float32Array(fftSize);
    for (let i = 0; i < fftSize; i++) window[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (fftSize - 1)));

    const h = specHeight;
    const w = specWidth;

    for (let xCol = 0; xCol < w; xCol++) {
        const re = new Float32Array(fftSize);
        const im = new Float32Array(fftSize);

        for (let bin = 0; bin < h; bin++) {
            const idx = xCol * h + bin;
            let mag = mags[idx] || 0;
            const phase = phases[idx] || 0;

            re[bin] = mag * Math.cos(phase);
            im[bin] = mag * Math.sin(phase);

            if (bin > 0 && bin < fftSize / 2) {
                const sym = fftSize - bin;
                re[sym] = re[bin];
                im[sym] = -im[bin];
            }
        }

        ifft_inplace(re, im);

        for (let i = 0; i < fftSize; i++) {
            const posPCM = xCol * hop + i;
            if (posPCM >= pcm.length) break;

            newPCM[posPCM] += re[i] * window[i];
            overlapCount[posPCM] += window[i] * window[i];
        }
    }

    for (let i = 0; i < pcm.length; i++) {
        if (overlapCount[i] > 0) newPCM[i] /= overlapCount[i];
    }

    pcm.set(newPCM);
    // start rendering at the current left view frame (iLow)
const startFrame = Math.max(0, Math.floor(iLow || 0));
pos = startFrame * hop;
x = startFrame;
rendering = true;
    requestAnimationFrame(drawLoop);

    startTime = performance.now();
    audioProcessed = 0;

    playPCM();
    console.log("PCM updated from phase-aware spectrogram!");
});

let sourceNode = null;
let playing = false;
let mouseDown = false;
let currentFrame = 0; 
let pausedAtSample = null; 
let sourceStartTime = 0; 
let wasPlayingDuringDrag = false;

initEmptyPCM();

function updateCursorLoop() {
    if (playing && !painting && pcm && sourceNode) {
        const elapsed = audioCtx.currentTime - sourceStartTime; 
        let samplePos = elapsed * sampleRate;

        if (sourceNode.loop) {
            samplePos = samplePos % pcm.length; 
        }

        const frame = Math.floor(samplePos / hop);
        currentCursorX = Math.min(frame, specWidth - 1);

        specCtx.putImageData(imageBuffer, 0, 0);
        renderView();
        drawCursor();
    }
    requestAnimationFrame(updateCursorLoop);
}
updateCursorLoop();

function stopSource(preservePaused=false){
    if(sourceNode){
        try { sourceNode.stop(); } catch(e) {  }
        try { sourceNode.disconnect(); } catch(e) {  }
        sourceNode = null;
    }

    if (!preservePaused) pausedAtSample = null;
    playing = false;
}

function playPCM(loop = true, startFrame = null) {
    if (!pcm) return;
    ensureAudioCtx();
    stopSource(true);

    let startSample = 0;
    if (startFrame !== null && !isNaN(startFrame)) {
        startSample = Math.max(0, Math.min(pcm.length - 1, startFrame * hop));
    } else if (pausedAtSample !== null) {
        startSample = Math.max(0, Math.min(pcm.length - 1, pausedAtSample));
    } else {
        startSample = 0;
    }

    sourceNode = audioCtx.createBufferSource();
    const buffer = audioCtx.createBuffer(1, pcm.length, sampleRate);
    buffer.copyToChannel(pcm, 0);
    sourceNode.buffer = buffer;
    sourceNode.loop = !!loop;
    sourceNode.connect(audioCtx.destination);

    const offsetSec = startSample / sampleRate;
    sourceStartTime = audioCtx.currentTime - offsetSec;
    try {
        sourceNode.start(0, offsetSec);
    } catch (e) {

        const remaining = pcm.length - startSample;
        const shortBuf = audioCtx.createBuffer(1, Math.max(1, remaining), sampleRate);
        shortBuf.copyToChannel(pcm.subarray(startSample, startSample + remaining), 0);
        sourceNode.stop();
        sourceNode.disconnect();
        sourceNode = audioCtx.createBufferSource();
        sourceNode.buffer = shortBuf;
        sourceNode.loop = !!loop;
        sourceNode.connect(audioCtx.destination);
        sourceStartTime = audioCtx.currentTime;
        sourceNode.start();
    }

    playing = true;
    pausedAtSample = null; 
}

function playFrame(frameX) {
    currentCursorX = frameX;
    if (!pcm) return;
    ensureAudioCtx();
    stopSource(true);
    const start = frameX * hop;
    const end = Math.min(start + fftSize, pcm.length);
    if (end <= start) return;
    const frameLen = end - start;

    const buffer = audioCtx.createBuffer(1, frameLen, sampleRate);
    buffer.copyToChannel(pcm.subarray(start, end), 0);

    sourceNode = audioCtx.createBufferSource();
    sourceNode.buffer = buffer;
    sourceNode.loop = true; 
    sourceNode.connect(audioCtx.destination);
    sourceStartTime = audioCtx.currentTime - (start / sampleRate);
    sourceNode.start();
    playing = true;
    pausedAtSample = null;
}

function renderFullSpectrogramToImage() {
    if (!imageBuffer || !mags || !phases) return;
    const w = specWidth, h = specHeight;
    for(let xx=0; xx<w; xx++){

        for(let yy=0; yy<h; yy++){

            const bin = displayYToBin(yy, h);
            const idx = xx * h + bin;
            const mag = mags[idx] || 0;
            const phase = phases[idx] || 0;
            const [r,g,b] = magPhaseToRGB(mag, phase);
            const pix = (yy * w + xx) * 4;
            imageBuffer.data[pix] = r;
            imageBuffer.data[pix+1] = g;
            imageBuffer.data[pix+2] = b;
            imageBuffer.data[pix+3] = 255;
        }
    }
    specCtx.putImageData(imageBuffer, 0, 0);
    renderView();
}

function floatTo16BitPCM(float32Array) {
    const buffer = new ArrayBuffer(float32Array.length * 2);
    const view = new DataView(buffer);
    for (let i = 0; i < float32Array.length; i++) {
        let s = Math.max(-1, Math.min(1, float32Array[i]));
        view.setInt16(i * 2, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
    }
    return view;
}

function writeWavHeader(view, sampleRate, numSamples) {
    const blockAlign = 2; 
    const byteRate = sampleRate * blockAlign;

    function writeString(view, offset, str) {
        for (let i = 0; i < str.length; i++) view.setUint8(offset + i, str.charCodeAt(i));
    }

    writeString(view, 0, 'RIFF');
    view.setUint32(4, 36 + numSamples * 2, true);
    writeString(view, 8, 'WAVE');
    writeString(view, 12, 'fmt ');
    view.setUint32(16, 16, true);       
    view.setUint16(20, 1, true);        
    view.setUint16(22, 1, true);        
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, byteRate, true);
    view.setUint16(32, blockAlign, true);
    view.setUint16(34, 16, true);       
    writeString(view, 36, 'data');
    view.setUint32(40, numSamples * 2, true);
}

document.getElementById('downloadWav').addEventListener('click', () => {
    if (!pcm) return alert('No PCM loaded!');
    const numSamples = pcm.length;
    const buffer = new ArrayBuffer(44 + numSamples * 2);
    const view = new DataView(buffer);

    writeWavHeader(view, sampleRate, numSamples);

    const pcm16 = floatTo16BitPCM(pcm);
    for (let i = 0; i < pcm16.byteLength; i++) {
        view.setUint8(44 + i, pcm16.getUint8(i));
    }

    const blob = new Blob([view], { type: 'audio/wav' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'output.wav';
    a.click();
    URL.revokeObjectURL(url);
});
document.getElementById('downloadButton').addEventListener('click', function() {

            let canvasUrl = canvas.toDataURL('image/png');

            const downloadLink = document.createElement('a');

            downloadLink.href = canvasUrl;
            downloadLink.download = 'my-drawing.png';

            downloadLink.click();

            downloadLink.remove();
        });

const timeline = document.getElementById('timeline');
const tctx = timeline.getContext('2d');

let timelineWidth = timeline.width; 
let timelineHeight = 20;
let timelineCursorX = 0;
let draggingTimeline = false;
let draggingBounds = false;
let tDmode = -1;
let oldX = null;
let iWidth = iHigh - iLow;

function drawTimeline() {
    tctx.clearRect(0, 0, timeline.width, timeline.height);

    tctx.fillStyle = "#333";
    tctx.fillRect(0, 0, timeline.width, timeline.height);

    const ts = 20; 
    const tx = (timelineCursorX-iLow) * timeline.width / (iHigh-iLow);
    const tx2 = timelineCursorX * timeline.width / framesTotal;

    tctx.fillStyle = "#0f0";
    tctx.beginPath();
    tctx.moveTo(tx, ts+10);
    tctx.lineTo(tx - ts, 10);
    tctx.lineTo(tx + ts, 10);
    tctx.closePath();
    tctx.fill();

    if (!pcm) return;
    iWidth = iHigh - iLow;
    const totalSeconds = iWidth*hopSizeEl.value / sampleRate;

    let interval = 0.01; 
    if (totalSeconds > 0.3) interval = 0.1;
    if (totalSeconds > 1) interval = 0.3;
    if (totalSeconds > 3) interval = 1;
    if (totalSeconds > 10) interval = 3;
    if (totalSeconds > 30) interval = 10;
    if (totalSeconds > 100) interval = 30;

    tctx.fillStyle = "#eee";
    tctx.font = "15px sans-serif";
    tctx.textAlign = "center";
    tctx.textBaseline = "top";
    const factor = timeline.width / framesTotal;
    const visibleFrames = iHigh - iLow;
    const secondsPerFrame = hopSizeEl.value / sampleRate;
    
    // visible time range
    const sLow = iLow * secondsPerFrame;
    const sHigh = iHigh * secondsPerFrame;
    
    // round up start to nearest interval
    let tStart = Math.ceil(sLow / interval) * interval;
    
    for (let t = tStart; t <= sHigh; t += interval) {
        const frame = t / secondsPerFrame; // convert seconds â†’ frame index
        const markerX = (frame - iLow) / visibleFrames * timeline.width;
    
        tctx.fillText(
            t.toFixed(interval < 1 ? 2 : interval < 10 ? 1 : 0),
            markerX,
            25
        );
    }
    
    tctx.fillStyle = "#222";
    tctx.fillRect(0, 0, timeline.width, 20);
    tctx.fillStyle = "#555";
    tctx.fillRect(iLow*factor, 0, (iHigh-iLow)*factor, 20);
    tctx.strokeStyle = "#777";
    tctx.strokeRect(iLow*factor, 0, (iHigh-iLow)*factor, 20);
    tctx.fillStyle = "#af0";
    tctx.fillRect(tx2-1,0,2,20);
}

function timelineXToFrame(clientXLeft) {
    return iLow + clientXLeft/timeline.getBoundingClientRect().width*iWidth;
}

timeline.addEventListener("mousedown", e => {
    const rect = timeline.getBoundingClientRect();
    if (e.clientY- rect.top>20) {
      draggingTimeline = true;
      wasPlayingDuringDrag = playing;
  
      stopSource(true);
      timelineCursorX = timelineXToFrame(e.clientX - rect.left);
  
      currentCursorX = timelineCursorX;
      drawTimeline();
      drawCursor();
    } else {
      draggingBounds = true;
      oldX = e.clientX- rect.left;
      iWidth = iHigh-iLow;
    }
});
window.addEventListener("mousemove", e => {
    const rect = timeline.getBoundingClientRect();
    const mouseY = e.clientY- rect.top;
    const mouseX = e.clientX- rect.left;
    if (mouseY > 20 && tDmode == -1) {
      timeline.style.cursor = "pointer";
      if (!draggingTimeline) return;
      timelineCursorX = timelineXToFrame(mouseX);
      currentCursorX = timelineCursorX;
      drawTimeline();
      drawCursor();
    } else {
      const sLow = iLow * rect.width/framesTotal;
      const sHigh = iHigh * rect.width/framesTotal;
      iWidth = iHigh-iLow;
      if ((Math.abs(mouseX - sLow)<15 && tDmode == -1) || tDmode == 0) {
        timeline.style.cursor = "e-resize";
        if (!draggingBounds) return;
        updateCanvasScroll();
        tDmode = 0;
        iLow = mouseX/rect.width*framesTotal;
        if (iLow < 0) {
          iLow = 0;
        }
        if (iLow > iHigh) iLow = iHigh - 1;
      } else if ((Math.abs(mouseX - sHigh)<15 && tDmode == -1) || tDmode == 1) {
        timeline.style.cursor = "w-resize";
        if (!draggingBounds) return;
        updateCanvasScroll();
        tDmode = 1;
        iHigh = mouseX/rect.width*framesTotal;
        if (iHigh > framesTotal) {
          iHigh = framesTotal;
        }
        if (iHigh < iLow) iHigh = iLow + 1;
      } else {
        timeline.style.cursor = "move";
        if (!draggingBounds) return;
        updateCanvasScroll();
        tDmode = 2;
        const inc = (mouseX-oldX)/rect.width*framesTotal
        iLow += inc;
        if (iLow < 0) {
          iLow = 0;
        }
        if (iHigh > framesTotal) {
          iLow = framesTotal - iWidth;
        }
        iHigh = iLow + iWidth;
        oldX = mouseX;
      }
    }
});
window.addEventListener("mouseup", e => {
    tDmode = -1;
    draggingBounds = false;
    clickX = null;
    if (!draggingTimeline) return;
    draggingTimeline = false;
    const frame = timelineCursorX;

    pausedAtSample = frame * hop;

    if (wasPlayingDuringDrag) {
        playPCM(true, frame);
        document.getElementById("playPause").textContent = "Pause";
    } else {

        specCtx.putImageData(imageBuffer, 0, 0);
        renderView();
        drawCursor();
    }
    drawTimeline();
});

const playPauseBtn = document.getElementById("playPause");
const stopBtn = document.getElementById("stop");

playPauseBtn.addEventListener("click", () => {
    ensureAudioCtx();
    if (playing) {

        const elapsed = audioCtx.currentTime - sourceStartTime;
        let samplePos = Math.floor(elapsed * sampleRate);
        if (sourceNode && sourceNode.loop) {
            samplePos = samplePos % pcm.length;
        }
        pausedAtSample = Math.max(0, Math.min(pcm.length - 1, samplePos));
        stopSource(true);
        playPauseBtn.textContent = "Play";
    } else {

        const startFrame = (pausedAtSample !== null) ? Math.floor(pausedAtSample / hop) : 0;
        playPCM(true, startFrame);
        playPauseBtn.textContent = "Pause";
    }
});

stopBtn.addEventListener("click", () => {
    stopSource(false); 
    timelineCursorX = 0;
    currentCursorX = 0;
    drawTimeline();
    specCtx.putImageData(imageBuffer, 0, 0);
    renderView();
    drawCursor();
    playPauseBtn.textContent = "Play";
});

function updateTimelineCursor() {
    if (playing && !draggingTimeline && pcm && sourceNode) {
        const elapsed = audioCtx.currentTime - sourceStartTime;
        let samplePos = elapsed * sampleRate;

        if (sourceNode.loop) {
            samplePos = samplePos % pcm.length;
        }

        const frame = Math.floor(samplePos / hop);
        timelineCursorX = Math.min(frame, specWidth-1);
        currentCursorX = timelineCursorX;
        drawTimeline();
        drawCursor();
    }
    requestAnimationFrame(updateTimelineCursor);
}
updateTimelineCursor();

drawTimeline();
renderFullSpectrogramToImage();
</script>
</body>
</html>