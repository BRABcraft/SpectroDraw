<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Phase-aware Spectrogram Editor â€” Fixed</title>
<style>
/* ---------- improved vertical slider styles (replace previous block) ---------- */
:root{
  --slider-length: 60px;    /* vertical length in screen px */
  --slider-thickness: 12px;  /* visual thickness (smaller = less wide) */
  --track-color: #444;
  --thumb-color: #fff;
  --thumb-size: 12px;
}

/* ensure controls sit above the canvas and won't be hidden */
.controls {
  position: relative;
  z-index: 5000;
  display:flex;
  flex-wrap:wrap;
  gap:8px;
  align-items:flex-start;
}

/* each control label gets reserved horizontal space so the rotated input won't overlap siblings */
.controls label {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap:6px;
  font-size: 0.9em;
  min-width: 15px;    /* reserve space horizontally for the rotated element */
  padding: 2px 2px;
  box-sizing: border-box;
}

/* put the rotated input inside a small container so the rotated bounding-box is constrained */
label .vertical-wrap {
  width: var(--slider-thickness);
  height: var(--slider-length);
  display:flex;
  align-items:center;
  justify-content:center;
  overflow: visible; /* allow thumb to render outside if needed */
  pointer-events: auto;
}

/* the actual rotated range */
.controls input[type="range"].vertical {
  -webkit-appearance: none;
  appearance: none;

  /* keep the logical element small (thickness x length), then rotate so it looks vertical */
  width: var(--slider-length);
  height: var(--slider-thickness);

  transform: rotate(-90deg);        /* visually vertical */
  transform-origin: 50% 50%;
  display: block;
  margin: 0;
  padding: 0;
  background: transparent;
  cursor: pointer;
}

/* track & thumb: WebKit */
.controls input[type="range"].vertical::-webkit-slider-runnable-track {
  height: 4px;                        /* thin track */
  background: var(--track-color);
  border-radius: 999px;
}

.controls input[type="range"].vertical::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: var(--thumb-size);
  height: var(--thumb-size);
  border-radius: 50%;
  background: var(--thumb-color);
  margin-top: -(var(--thumb-size) / 2); /* try to center thumb */
  box-shadow: 0 1px 3px rgba(0,0,0,0.6);
  margin-top: -4px;
}

/* Firefox */
.controls input[type="range"].vertical::-moz-range-track {
  height: 4px;
  background: var(--track-color);
  border-radius: 999px;
}
.controls input[type="range"].vertical::-moz-range-thumb {
  width: var(--thumb-size);
  height: var(--thumb-size);
  border-radius:50%;
  background: var(--thumb-color);
  border: none;
  box-shadow: 0 1px 3px rgba(0,0,0,0.6);
  margin-top: -4px;
}

/* small tweaks so the label text doesn't shift when slider rotates */
.controls label > input[type="range"],
.controls label > .vertical-wrap {
  margin-top: 6px;
  margin-bottom: 6px;
}

/* ensure canvases sit below controls and buttons remain visible */
#canvasWrapper { z-index: 1; position: absolute; }
canvas#overlay { z-index: 10; pointer-events: none; }
.tool-btn, #downloadWav, #downloadButton, #resetButton, #playPause, #stop, #trueScale,#fileB {
  position: relative;
  z-index: 6000;           /* keep UI buttons above rotated inputs and canvas */
}

body { background:#111; color:#eee; font-family:sans-serif; margin:0px;}
.controls { margin-bottom:1em; }
label { margin-right:1em; display:inline-block; margin-top:0.2em; }
canvas { display:block; background:#000;}
.tool-btn, #downloadWav, #downloadButton, #resetButton, #playPause, #stop, #trueScale, #fileB {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 36px;
  height: 36px;
  padding: 6px;
  border: none;
  background: #f3f3f3;
  border-radius: 6px;
  cursor: pointer;
}

.tool-btn svg {
  width: 20px;
  height: 20px;
  display: block;
  preserveAspectRatio: 'xMidYMid meet';
  transform: translateX(-0.5px); 
}
#timeline { display:block; height:40px; }
#status { margin-top:0.5em; font-size:13px; }
.controls {
  display: flex;
  flex-wrap: wrap; 
  gap: 5px;       
  align-items: flex-start; 
}

.controls label {
  display: flex;
  flex-direction: column; 
  font-size: 0.9em;
}

.controls input[type="range"],
.controls input[type="number"] {
  margin-top: 2px; 
}
/* make all number inputs compact */
.controls input[type="number"] {
  width: 5ch;            /* try 4ch..8ch to taste */
  min-width: 10ch;
  max-width: 10ch;
  box-sizing: border-box;
  padding: 0.15rem 0.35rem;
  font-size: 0.95rem;
  background-color: #333;
  border-radius: 10px;
  border-color: #aaa;
  color: #fff;
}
</style>
</head>
<body>
<div class="controls">
  <label title="An exponent of 2, height of spectrogram in pixels.">Pitch resolution:
    <input id="fftSize" type="number" value="11" step="1" min="6" max="14">
  </label>
  <label title="Number of audio samples given to each frame (x pixel).">Time resolution:
    <input id="hopSize" type="number" value="512" step="1" min="1">
  </label>
  
  <label id="es">
    <span class="label-line">
      <span class="label-text">Empty audio seconds:</span>
      <span class="label-value" id="ev">10</span>
    </span>
    <input id="emptyAudioLength" type="range" min="0.01" max="100" step="0.01" value="10">
  </label>
  <label style="position: absolute; right: 160px">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20" stroke="currentColor" fill="none" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
      <!-- axes -->
      <line x1="5" y1="19" x2="19" y2="19" />   <!-- X axis -->
      <line x1="5" y1="19" x2="5"  y2="5"  />   <!-- Y axis -->
    
      <!-- little filled origin box at bottom-left (origin) -->
      <rect x="4.5" y="12.5" width="6" height="6" fill="currentColor" stroke="none" rx="0.5" ry="0.5" />
    
      <!-- small axis arrows -->
      <path d="M19 19 L17.5 17.5" />
      <path d="M5 5 L3.5 6.5" />
    </svg>


    <div class="vertical-wrap">
      <input id="brushSize" class="vertical" type="range" min="1" max="200" value="40">
    </div>
  </label>
  <label style="position: absolute; right: 125px">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 -2 24 24" width="20" height="20">
      <defs>
        <linearGradient id="brightnessGrad" x1="0" x2="1" y1="0" y2="0">
          <stop offset="0%" stop-color="black"/>
          <stop offset="100%" stop-color="white"/>
        </linearGradient>
      </defs>
      <rect x="0" y="0" width="20" height="20" fill="url(#brightnessGrad)" stroke="currentColor"/>
    </svg>

    <div class="vertical-wrap">
      <input id="brushColor" class="vertical" type="range" min="0" max="255" value="255">
    </div>
  </label>
  <label style="position: absolute; right: 90px">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20">
      <defs>
        <linearGradient id="rainbow" x1="1" y1="0" x2="0" y2="1">
          <stop offset="0%" stop-color="red"/>
          <stop offset="17%" stop-color="orange"/>
          <stop offset="33%" stop-color="yellow"/>
          <stop offset="50%" stop-color="green"/>
          <stop offset="67%" stop-color="blue"/>
          <stop offset="83%" stop-color="indigo"/>
          <stop offset="100%" stop-color="violet"/>
        </linearGradient>
      </defs>
      <circle cx="12" cy="12" r="10" fill="url(#rainbow)" stroke="currentColor"/>
    </svg>

    <div class="vertical-wrap">
      <input id="penPhase" class="vertical" type="range" min="0" max="31415" value="0">
    </div>
  </label>
  <label style="position: absolute; right: 55px">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20">
      <defs>
        <pattern id="checker" width="4" height="4" patternUnits="userSpaceOnUse">
          <rect width="4" height="4" fill="white"/>
          <rect width="2" height="2" fill="#ccc"/>
          <rect x="2" y="2" width="2" height="2" fill="#ccc"/>
        </pattern>
        <linearGradient id="fade" x1="0" y1="0" x2="1" y2="0">
          <stop offset="0%" stop-color="white" stop-opacity="1"/>
          <stop offset="100%" stop-color="white" stop-opacity="0"/>
        </linearGradient>
      </defs>
      <rect x="4" y="4" width="20" height="20" fill="url(#checker)"/>
      <rect x="4" y="4" width="20" height="20" fill="url(#fade)"/>
      <rect x="4" y="4" width="20" height="20" stroke="currentColor" fill="none"/>
    </svg>

    <div class="vertical-wrap">
      <input id="brushOpacity" class="vertical" type="range" min="0" max="100" value="100">
    </div>
  </label>
  <label style="position: absolute; right: 20px">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20">
      <defs>
        <linearGradient id="saturation" x1="1" y1="0" x2="0" y2="1">
          <stop offset="0%" stop-color="red"/>
          <stop offset="50%" stop-color="gray"/>
          <stop offset="100%" stop-color="gray"/>
        </linearGradient>
      </defs>
      <circle cx="12" cy="12" r="10" fill="url(#saturation)" stroke="currentColor"/>
    </svg>

    <div class="vertical-wrap">
      <input id="phaseOpacity" class="vertical" type="range" min="0" max="100" value="0">
    </div>
  </label>
  <div class="controls" style="position:absolute; top:60px">
    <button id="fileB" title="Upload Audio" style="margin-left: 10px">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#333" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="18" cy="6" r="3" fill="#333" stroke="none"/>
        <polygon points="1,20 8,10 15,20" fill="#333"/>
        <polygon points="8,20 15,12 23,20" fill="#333"/>
      </svg>
    </button>
    <input id="file" type="file" accept=".wav" style="display:none;"/>
    <button id="playPause" title="play" style="margin-left: 20px">
      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 20 20"><rect x="2" y="0" width="5" height="18" rx="2" ry="2"/><rect x="12" y="0" width="5" height="18" rx="2" ry="2"/></svg>
    </button>
    <button id="stop" title="pause">
      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 20 20">
        <rect x="0" y="0" width="18" height="18" rx="2" ry="2"/>
      </svg>
    </button>
    <button class="tool-btn" data-tool="brush" style="margin-left: 20px" title="Brush">
      <svg xmlns="http://www.w3.org/2000/svg" 
           width="20" height="20" 
           viewBox="5 4 18 18" 
           fill="currentColor">
        <path d="M20.71 4.63a2 2 0 0 0-2.83 0l-9.9 9.9a3 3 0 0 0-.78 1.37l-.69 2.76a1 1 0 0 0 1.21 1.21l2.76-.69a3 3 0 0 0 1.37-.78l9.9-9.9a2 2 0 0 0 0-2.83zm-11.24 11.3l-.88.22.22-.88 9.19-9.19.66.66z"/>
      </svg>
    </button>
    <button class="tool-btn" data-tool="rectangle" title="Rectangle">
      <svg xmlns="http://www.w3.org/2000/svg" 
           width="20" height="20" viewBox="0 0 20 20" 
           fill="none"
           stroke = "black" stroke-width = "5">
        <path d="M0 0 H 20 V 20 H 0 V -20"/>
      </svg>
    </button>
    <button class="tool-btn" data-tool="line" title="Line">
      <svg xmlns="http://www.w3.org/2000/svg" 
           width="20" height="20" viewBox="0 0 20 20" 
           fill="none"
           stroke = "black" stroke-width = "3">
        <path d="M20 0 L 0 20"/>
      </svg>
    </button>
    <button class="tool-btn" data-tool="blur" title="Blur">
      <svg xmlns="http://www.w3.org/2000/svg" 
           width="24" height="24" 
           viewBox="0 0 24 24" 
           fill="currentColor">
        <path d="M12 2C12 2 7 10 7 14a5 5 0 0 0 10 0c0-4-5-12-5-12z"/>
      </svg>
    </button>
    <button class="tool-btn" data-tool="eraser" title="Eraser">
      <svg width="20" height="20" viewBox="-1 -1 16 16">
        <path d="M5,0 L0,5 L5,10 L10,5 Z " fill="#333" stroke="#333" stroke-width="1"/>
        <path d="M5,10 L10,5 L15,10 L12,13 L8,13 Z" fill="white" stroke="#333" stroke-width="1"/>
      </svg>
    </button>
    <button class="tool-btn" data-tool="image" title="Image Overlay">
      <svg width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="#333" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="18" cy="6" r="3" fill="#333" stroke="none"/>
        <polygon points="1,20 8,10 15,20" fill="#333"/>
        <polygon points="8,20 15,12 23,20" fill="#333"/>
      </svg>
    </button>
    <input type="file" id="overlayFile" accept="image/*" style="display:none;">
    <button id="trueScale" title="Use true aspect ratio" style="margin-left: 20px">
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" aria-hidden="true" role="img">
        <title>Enter fullscreen</title>
        <g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M3 9V3h6" />
          <path d="M15 3h6v6" />
          <path d="M3 15v6h6" />
          <path d="M21 15v6h-6" />
        </g>
      </svg>

    </button>
     <button id="downloadWav" style="margin-left:20px" title="Download audio">
      <svg width="20" height="20" viewBox="2 2 20 21" fill="none" stroke="#333" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M4 14v-2a8 8 0 0 1 16 0v2" />
        <path d="M5 14v4h2v-4H6z" />
        <path d="M17 14v4h2v-4h-2z" />
        <path d="M12 12v10" />
        <path d="M9 19l3 3 3 -3" />
      </svg>
    </button>
    <button id="downloadButton" title="Download spectrogram">
      <svg width="20" height="20" viewBox="2 2 20 21" fill="none" stroke="#333" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <rect x="3" y="3" width="18" height="14" rx="2" ry="2" />
        <circle cx="17" cy="7" r="2" />
        <polyline points="3 17 10 10 14 14 21 7" />
        <path d="M12 12v10" />
        <path d="M9 19l3 3 3 -3" />
      </svg>
    </button>
    <button id="resetButton" onClick="initEmptyPCM()" title="Reset audio">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#333" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <rect x="5" y="7" width="14" height="14" rx="2" ry="2" />
        <line x1="8" x2="8" y1="11" y2 = "17" stroke-width="1"/>
        <line x1="12" x2="12" y1="11" y2 = "17" stroke-width="1"/>
        <line x1="16" x2="16" y1="11" y2 = "17" stroke-width="1"/>
        <rect x="3" y="4" width="18" height="3" rx="2" ry="2" />
        <rect x="8" y="1" width="8" height="2" rx="2" ry="2" stroke-width="1"/>
      </svg>
    </button>
  </div>
</div>

<!-- Timeline canvas -->
<div id="canvasWrapper" style="position:absolute; display:inline-block; width:100%; top:100px;">
  <canvas id="timeline" style="height:40px; background:#222; position: absolute;align:left;left:40px;z-index: 9998; top:0px"></canvas>
  <canvas id="canvas" style="cursor:crosshair; position: absolute; left: 40px; top:40px"></canvas>
  <canvas id="overlay" style="background: transparent; position:absolute; left:40px; pointer-events:none; z-index:10;; top:40px"></canvas>
  <canvas id="freq" style="width:40px; background:#222; position:absolute; left:0; ; top:40px"></canvas>
  <canvas id="logscale" width=40 height = 40 style="position:absolute; top:0px; background: #111;z-index: 99999; top:0px"></canvas>

</div>
<div id="status" style="position:absolute;bottom:0px;"></div>

<script>
let currentTool = "brush";
const toolButtons = document.querySelectorAll(".tool-btn");
toolButtons.forEach(btn => {
  if(btn.dataset.tool === currentTool) {
    btn.style.background = "#4af"; 
  }
});
toolButtons.forEach(btn => {
  btn.addEventListener("click", () => {
    currentTool = btn.dataset.tool;
    toolButtons.forEach(b => b.style.background = "");
    btn.style.background = "#4af"; 
    if(currentTool === "image") overlayFile.click();
  });
});
const trueScale = document.getElementById("trueScale");
let trueScaleVal=false;
trueScale.addEventListener("click", () => {
    trueScaleVal = !trueScaleVal;
    trueScale.style.background = trueScaleVal?"#4af":"#f3f3f3";
    restartRender();
  });

const overlayFile = document.getElementById("overlayFile");
let overlayImage = null;
overlayFile.addEventListener("change", e => {
  const f = e.target.files[0];
  if (!f) return;
  const img = new Image();
  img.onload = () => overlayImage = img;
  img.src = URL.createObjectURL(f);
});

</script>
<script src="fft.js"></script>
<script>

const fileEl=document.getElementById("file");
const canvas=document.getElementById("canvas");
const ctx=canvas.getContext("2d");
const overlayCanvas = document.getElementById("overlay");
const overlayCtx = overlayCanvas.getContext("2d");
const status=document.getElementById("status");
const fftSizeEl=document.getElementById("fftSize");
const hopSizeEl=document.getElementById("hopSize");
const brushSizeEl=document.getElementById("brushSize");
const brushOpacityEl=document.getElementById("brushOpacity");
const phaseOpacityEl=document.getElementById("phaseOpacity");
const brushColorEl=document.getElementById("brushColor");
const penPhaseEl=document.getElementById("penPhase");
const logscaleEl = document.getElementById("logscale");
const emptyAudioLengthEl = document.getElementById("emptyAudioLength");
const ev = document.getElementById("ev");
const yAxis=document.getElementById("freq");
const yctx=yAxis.getContext("2d");

let pcm=null, sampleRate=44100, pos=0, fftSize=1024, hop=512, win=hann(1024);
let framesTotal=0, x=0, rendering=false;
let imageBuffer=null;
let currentCursorX = 0;
let iLow = null;
let iHigh = null;
let fLow = null;
let fHigh = null;
let specCanvas = document.createElement("canvas");
let specCtx = specCanvas.getContext("2d");
let logScaleVal = 1.12;

let mags = null;     
let phases = null;   
let specWidth = 0;
let specHeight = 0;

let startX = null, startY = null;

let brushSize=parseInt(brushSizeEl.value);
let brushOpacity=parseInt(brushOpacityEl.value)/100;
let phaseOpacity=parseInt(phaseOpacityEl.value)/100;
let brushColor=parseInt(brushColorEl.value); 
let penPhase=parseInt(penPhaseEl.value)/10000;
brushSizeEl.addEventListener("input",()=>brushSize=parseInt(brushSizeEl.value));
brushOpacityEl.addEventListener("input",()=>brushOpacity=parseInt(brushOpacityEl.value)/100);
phaseOpacityEl.addEventListener("input",()=>phaseOpacity=parseInt(phaseOpacityEl.value)/100);
brushColorEl.addEventListener("input",()=>brushColor=parseInt(brushColorEl.value));
penPhaseEl.addEventListener("input", ()=>penPhase = parseInt(penPhaseEl.value) / 10000);

function initEmptyPCM() {
    const sampleRateLocal = 44100;
    const duration = emptyAudioLengthEl.value; 
    const length = sampleRateLocal * duration; 
    const tinyNoiseAmplitude = 0.0001; 

    const pcmArray = new Float32Array(length);
    for (let i = 0; i < length; i++) {
        pcmArray[i] = (Math.random() * 2 - 1) * tinyNoiseAmplitude; 
    }

    pcm = pcmArray;
    sampleRate = sampleRateLocal;

    es.style.display = "";
    restartRender();
}
let changingLogScale = false;
logscaleEl.addEventListener("mousedown", e=> {
  const rect= logscaleEl.getBoundingClientRect();
  changingLogScale = true;
  startY = e.clientY;
  startX = e.clientX;
  renderFullSpectrogramToImage();
  drawLogScale();
});

function drawLogScale() {
  const lctx = logscaleEl.getContext("2d");

  const w = 40, h = 40;
  lctx.clearRect(0, 0, w, h);

  lctx.beginPath();
  const steps = 40;
  for (let i = 0; i <= steps; i++) {
    const x = i / steps;              
    const y = 1-Math.pow(0-(x-1), Math.pow(logScaleVal,2)); 
    const px = x * w;                 
    const py = h - y * h;             
    if (i === 0) lctx.moveTo(px, py);
    else lctx.lineTo(px, py);
  }
  lctx.strokeStyle = "white";
  lctx.lineWidth = 3;
  lctx.stroke();
}

document.addEventListener("mousemove", e=> {
  logscaleEl.style.cursor = "n-resize";
  if (!changingLogScale) return;
  const rect= logscaleEl.getBoundingClientRect();
  logScaleVal -= (e.clientY - startY - (e.clientX - startX))/400;
  if (logScaleVal < 1) logScaleVal = 1;
  if (logScaleVal > 2) logScaleVal = 2;
  startY = e.clientY;
  startX = e.clientX;
  renderFullSpectrogramToImage();
  drawLogScale();
});

document.addEventListener("mouseup", e=>{changingLogScale=false;})

emptyAudioLengthEl.addEventListener("input", ()=> {
  ev.textContent = parseFloat(emptyAudioLengthEl.value).toFixed(2);
  initEmptyPCM();
  drawTimeline();
  drawLogScale();
  drawYAxis();
  iLow = 0;
  iHigh = framesTotal;

});

let audioCtx = null;
function ensureAudioCtx(){
  if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
}

let startTime=0; 
let audioProcessed=0; 

fileEl.addEventListener("change", async e=>{
    const f=e.target.files[0]; if(!f)return;
    const buf=await f.arrayBuffer();
    ensureAudioCtx();
    const ab = await audioCtx.decodeAudioData(buf.slice(0));
    pcm = new Float32Array(ab.getChannelData(0));
    sampleRate = ab.sampleRate || 44100;

    status.textContent=`Loaded ${f.name}, ${pcm.length} samples @ ${sampleRate} Hz`;
    status.style.display = "block";
    restartRender();
    iLow = 0;
    iHigh = framesTotal;

    es.style.display = "none";
});

fftSizeEl.addEventListener("change",restartRender);
hopSizeEl.addEventListener("change",restartRender);

function restartRender(){
    if(!pcm) return;
    const exponent = Math.max(6, Math.min(14, parseInt(fftSizeEl.value)||10));
    fftSize = 1 << exponent;
    hop = Math.max(1, parseInt(hopSizeEl.value) || Math.floor(fftSize/2));
    win = hann(fftSize);

    framesTotal = Math.max(1, Math.floor((pcm.length - fftSize) / hop) + 1);
    if (iLow == null) {
      iLow = 0;
      iHigh = framesTotal;
    }

    const freqBins = Math.floor(fftSize / 2);
    canvas.width = framesTotal;
    canvas.height = freqBins;
    if (trueScaleVal) {
      const maxHeight = 600;
      const containerWidth = canvas.parentElement.clientWidth;
      const scaleX = containerWidth / framesTotal;
      const scaleY = maxHeight / freqBins;
      const scale = Math.min(scaleX, scaleY, 1);

      canvas.style.width = (canvas.width * scale) + "px";
      canvas.style.height = (canvas.height * scale) + "px";
    } else {
      canvas.style.width = "calc(100% - 40px)";
      canvas.style.height = "500px";
    }

    overlayCanvas.style.width = canvas.style.width;
    overlayCanvas.style.height = canvas.style.height;
    yAxis.height = parseInt(canvas.style.height);
    yAxis.width = 40;
    yAxis.style.height = canvas.style.height;

    specWidth = canvas.width;
    specHeight = canvas.height;

    syncOverlaySize();

    const timeline = document.getElementById('timeline');
    timeline.width = window.innerWidth*1.2;
    timeline.style.width = canvas.style.width;
    timeline.height = 40;

    imageBuffer = new ImageData(canvas.width, canvas.height);
    specWidth = canvas.width;
    specHeight = canvas.height;

    specCanvas.width = specWidth;
    specCanvas.height = specHeight;
    specCtx.clearRect(0, 0, specCanvas.width, specCanvas.height);
    specCtx.putImageData(imageBuffer, 0, 0);

    mags = new Float32Array(specWidth * specHeight);
    phases = new Float32Array(specWidth * specHeight);
    for(let i=0;i<specWidth*specHeight;i++){ mags[i]=0; phases[i]=0; }

    const startFrame = Math.max(0, Math.floor(iLow || 0));
    pos = startFrame * hop;
    x = startFrame;
    rendering = true;

    ctx.fillStyle = "black";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    startTime = performance.now();
    audioProcessed = 0;

    stopSource(true);
    requestAnimationFrame(drawLoop);
}

function magPhaseToRGB(mag, phase){

    const h = (phase / (2*Math.PI) + 1) % 1; 
    const s = 1;
    const v = Math.min(mag/60,1);
    const c = v*s;
    const m = v - c;
    const hp = h*6;
    const x = c*(1-Math.abs(hp%2-1));
    let r=0,g=0,b=0;
    if(hp < 1){ r=c; g=x; b=0; }
    else if(hp < 2){ r=x; g=c; b=0; }
    else if(hp < 3){ r=0; g=c; b=x; }
    else if(hp < 4){ r=0; g=x; b=c; }
    else if(hp < 5){ r=x; g=0; b=c; }
    else { r=c; g=0; b=x; }
    return [Math.floor((r+m)*255), Math.floor((g+m)*255), Math.floor((b+m)*255)];
}

function rgbToMagPhase(r, g, b) {
    let rf=r/255,gf=g/255,bf=b/255;
    const mx=Math.max(rf,gf,bf), mn=Math.min(rf,gf,bf);
    const d=mx-mn;
    let h=0,s=0,v=mx;
    s=mx===0?0:d/mx;
    if(d!==0){
        if(mx===rf) h=((gf-bf)/d)%6;
        else if(mx===gf) h=(bf-rf)/d+2;
        else h=(rf-gf)/d+4;
        h/=6; if(h<0) h+=1;
    }
    const phase=h*2*Math.PI;
    const mag=v*60;
    return [mag, phase];
}

function getLogScaleSlider() { return Math.max(1, parseFloat(logScaleVal) || 1); }

function binToDisplayY(bin, h) {
    if (!h) return 0;
    const s = getLogScaleSlider();
    if (s <= 1.0000001) {
        return Math.round(h - 1 - bin); 
    } else {
        const a = s - 1;
        const denom = Math.log(1 + a * (h - 1));
        if (!isFinite(denom) || denom === 0) return Math.round(h - 1 - bin);
        const t = Math.log(1 + a * bin) / denom; 
        const y = (1 - t) * (h - 1);
        return Math.round(y);
    }
}

function displayYToBin(y, h) {
    if (!h) return 0;
    const s = getLogScaleSlider();
    if (s <= 1.0000001) {
        return Math.max(0, Math.min(h - 1, Math.round(h - 1 - y)));
    } else {
        const a = s - 1;
        const denom = Math.log(1 + a * (h - 1));
        if (!isFinite(denom) || denom === 0) return Math.max(0, Math.min(h - 1, Math.round(h - 1 - y)));
        const t = 1 - (y / (h - 1));
        const raw = (Math.exp(t * denom) - 1) / a;
        const clamped = Math.max(0, Math.min(h - 1, Math.round(raw)));
        return clamped;
    }
}

function drawLoop() {
    if (!rendering) return;

    const framesPerTick = Math.min(200, Math.max(4, Math.floor(specWidth/8)));

    const h = specHeight;
    const w = specWidth;

    for (let f = 0; f < framesPerTick; f++) {
        if (pos + fftSize > pcm.length) { rendering = false; status.style.display = "none"; break; }

        const re = new Float32Array(fftSize);
        const im = new Float32Array(fftSize);
        for (let i = 0; i < fftSize; i++) { re[i] = (pcm[pos + i] || 0) * win[i]; im[i] = 0; }
        fft_inplace(re, im);

        for (let bin = 0; bin < h; bin++) {
            const mag = Math.hypot(re[bin] || 0, im[bin] || 0);
            const phase = Math.atan2(im[bin] || 0, re[bin] || 0);
            const idx = x * h + bin; 
            mags[idx] = mag;
            phases[idx] = phase;
        }

        for (let yy = 0; yy < h; yy++) {
            const mappedBin = displayYToBin(yy, h);
            const idx = x * h + mappedBin;
            const mag = mags[idx] || 0;
            const phase = phases[idx] || 0;
            const [r, g, b] = magPhaseToRGB(mag, phase);
            const pix = (yy * w + x) * 4; 
            imageBuffer.data[pix]     = r;
            imageBuffer.data[pix + 1] = g;
            imageBuffer.data[pix + 2] = b;
            imageBuffer.data[pix + 3] = 255;
        }

        pos += hop; x++;
        audioProcessed += hop;
        if (x >= w) { rendering = false; 
            if (!painting) playPCM(true);
            status.style.display = "none";
            break;
        }
    }

    specCtx.putImageData(imageBuffer, 0, 0);
    renderView();
    drawCursor();
    const elapsedMS = performance.now() - startTime;
    const elapsedSec = elapsedMS / 1000;
    const speed = audioProcessed / Math.max(1e-6, elapsedSec); 
    const audioSec = pcm.length / 44100; 
    const processedSec = audioProcessed / 44100;
    status.textContent = `Progress: ${(100*pos/pcm.length).toFixed(1)}% | ` 
        + `Elapsed: ${elapsedSec.toFixed(2)}s | `
        + `Audio processed: ${processedSec.toFixed(2)}/${audioSec.toFixed(2)}s | `
        + `Speed: ${(speed/44100).toFixed(2)}x realtime`;
    if (rendering) {
      status.style.display = "block";
      requestAnimationFrame(drawLoop);
    }
}

function drawCursor(){

    const x = (currentCursorX-iLow) * canvas.width / (iHigh-iLow)
    overlayCtx.clearRect(0,0, canvas.width, canvas.height);
    overlayCtx.strokeStyle = "#0f0";
    overlayCtx.lineWidth = framesTotal/500;
    overlayCtx.beginPath();
    overlayCtx.moveTo(x + 0.5, 0);
    overlayCtx.lineTo(x + 0.5, specHeight);
    overlayCtx.stroke();
}

function updateCanvasScroll() {
    if (!imageBuffer || !specCanvas) return;

    const viewWidth = Math.max(1, Math.floor(iHigh - iLow));
    const fStart = Math.max(0, Math.floor(specHeight * (1 - fHigh / (sampleRate/2))));
    const fEnd = Math.min(specHeight, Math.floor(specHeight * (1 - fLow / (sampleRate/2))));
    const viewHeight = Math.max(1, fEnd - fStart);

    canvas.width = viewWidth;
    canvas.height = viewHeight;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(
        specCanvas,
        Math.max(0, Math.floor(iLow)), fStart, 
        viewWidth, viewHeight,                 
        0, 0,                                  
        canvas.width, canvas.height            
    );

    overlayCanvas.width = canvas.width;
    overlayCanvas.height = canvas.height;
    overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

    drawCursor();
}

function renderView() {
    if (!specCanvas || !imageBuffer) return;

    const viewWidth = Math.max(1, Math.floor(iHigh - iLow));
    const fStart = Math.max(0, Math.floor(specHeight * (1 - fHigh / (sampleRate/2))));
    const fEnd = Math.min(specHeight, Math.floor(specHeight * (1 - fLow / (sampleRate/2))));
    const viewHeight = Math.max(1, fEnd - fStart);

    canvas.width = viewWidth;
    canvas.height = viewHeight;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(
        specCanvas,
        Math.max(0, Math.floor(iLow)), fStart, 
        viewWidth, viewHeight,                 
        0, 0,                                  
        canvas.width, canvas.height            
    );

    overlayCanvas.width = canvas.width;
    overlayCanvas.height = canvas.height;
    overlayCanvas.style.width = canvas.style.width;
    overlayCanvas.style.height = canvas.style.height;
}

let painting=false;
let paintedPixels=null;

function getCanvasCoords(e){
    const rect=canvas.getBoundingClientRect();
    const scaleX=canvas.width/rect.width;
    const scaleY=canvas.height/rect.height;
    return {cx:(e.clientX-rect.left)*scaleX, cy:(e.clientY-rect.top)*scaleY, scaleX, scaleY};
}

function syncOverlaySize() {
  overlayCanvas.width = canvas.width;
  overlayCanvas.style.width = canvas.style.width;
  overlayCanvas.height = canvas.height;

  overlayCanvas.style.height = canvas.style.height;
}

let pendingPreview = false;
let lastPreviewCoords = null;

function previewShape(cx, cy) {

  lastPreviewCoords = { cx, cy };
  if (pendingPreview) return;
  pendingPreview = true;
  requestAnimationFrame(() => {
    pendingPreview = false;
    const coords = lastPreviewCoords;
    overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
    overlayCtx.strokeStyle = "#fff";
    overlayCtx.lineWidth = Math.max(1, Math.min(4, Math.floor(framesTotal / 500)));
    if (currentTool === "rectangle" && startX !== null && startY !== null) {
      overlayCtx.strokeRect(startX + 0.5, startY + 0.5, coords.cx - startX, coords.cy - startY);
    } else if (currentTool === "line" && startX !== null && startY !== null) {
      overlayCtx.beginPath();
      overlayCtx.moveTo(startX + 0.5, startY + 0.5);
      overlayCtx.lineTo(coords.cx + 0.5, coords.cy + 0.5);
      overlayCtx.stroke();
    } else if (currentTool === "image"  && overlayImage) {

      const screenSpace = true; 

      const rect = canvas.getBoundingClientRect();
      const pixelsPerFrame = rect.width  / Math.max(1, canvas.width);
      const pixelsPerBin   = rect.height / Math.max(1, canvas.height);

      const desiredScreenMax = brushSize*4;

      const imgW = overlayImage.width;
      const imgH = overlayImage.height;
      const imgAspect = imgW / imgH;

      let screenW, screenH;
      if (imgW >= imgH) {
        screenW = desiredScreenMax;
        screenH = Math.max(1, Math.round(desiredScreenMax / imgAspect));
      } else {
        screenH = desiredScreenMax;
        screenW = Math.max(1, Math.round(desiredScreenMax * imgAspect));
      }

      let overlayW, overlayH;
      if (screenSpace) {
        overlayW = Math.max(1, Math.round(screenW / pixelsPerFrame));
        overlayH = Math.max(1, Math.round(screenH / pixelsPerBin));
      } else {
        overlayH = Math.max(1, Math.round(brushSize));
        overlayW = Math.max(1, Math.round(overlayH * imgAspect));
      }

      overlayCtx.strokeRect(
        coords.cx - overlayW / 2,
        coords.cy - overlayH / 2,
        overlayW,
        overlayH
      );
    }
  });
}

function commitShape(cx, cy) {
    if (!mags || !phases) return;

    const fullW = specWidth;
    const fullH = specHeight;
    const bo = brushOpacity;
    const po = phaseOpacity;
    const brushMag = (brushColor / 255) * 128;
    const brushPhase = penPhase;

    function drawPixelIntFrame(xFrame, yDisplay, mag, phase, bo, po) {
        const xI = Math.round(xFrame);
        const yI = Math.round(yDisplay);
        if (xI < 0 || xI >= fullW || yI < 0 || yI >= fullH) return;
        const bin = displayYToBin(yI, fullH);
        const idx = xI * fullH + bin;
        if (idx < 0 || idx >= mags.length) return;
        const oldMag = mags[idx] || 0;
        const oldPhase = phases[idx] || 0;
        const newMag = oldMag * (1 - bo) + mag * bo;
        const newPhase = oldPhase + po * (phase - oldPhase);
        mags[idx] = newMag;
        phases[idx] = newPhase;
        const displayY = binToDisplayY(bin, fullH);
        const pix = (displayY * fullW + xI) * 4;
        const [r, g, b] = magPhaseToRGB(newMag, newPhase);
        imageBuffer.data[pix]     = r;
        imageBuffer.data[pix + 1] = g;
        imageBuffer.data[pix + 2] = b;
        imageBuffer.data[pix + 3] = 255;
    }

    const startVisX = (startX == null ? cx : startX);
    const startVisY = (startY == null ? cy : startY);

    const startFrame = Math.round(startVisX + (iLow || 0));
    const endFrame   = Math.round(cx + (iLow || 0));
    let x0Frame = Math.max(0, Math.min(fullW - 1, Math.min(startFrame, endFrame)));
    let x1Frame = Math.max(0, Math.min(fullW - 1, Math.max(startFrame, endFrame)));

    const startSpecY = visibleToSpecY(startVisY);
    const endSpecY   = visibleToSpecY(cy);
    let y0Spec = Math.max(0, Math.min(fullH - 1, Math.min(startSpecY, endSpecY)));
    let y1Spec = Math.max(0, Math.min(fullH - 1, Math.max(startSpecY, endSpecY)));

    if (currentTool === "rectangle") {
        const minX = x0Frame;
        const maxX = x1Frame;
        const minY = y0Spec;
        const maxY = y1Spec;
        for (let yy = minY; yy <= maxY; yy++) {
            for (let xx = minX; xx <= maxX; xx++) {
                drawPixelIntFrame(xx, yy, brushMag, brushPhase, bo, po);
            }
        }
    } else if (currentTool === "line") {
        let x0 = (startFrame <= endFrame) ? startFrame : endFrame;
        let x1 = (startFrame <= endFrame) ? endFrame : startFrame;
        const startWasLeft = (startFrame <= endFrame);
        let yStartSpec = startWasLeft ? startSpecY : endSpecY;
        let yEndSpec   = startWasLeft ? endSpecY   : startSpecY;

        x0 = Math.max(0, Math.min(fullW - 1, Math.round(x0)));
        x1 = Math.max(0, Math.min(fullW - 1, Math.round(x1)));
        let y0 = Math.max(0, Math.min(fullH - 1, Math.round(yStartSpec)));
        let y1 = Math.max(0, Math.min(fullH - 1, Math.round(yEndSpec)));

        const dx = Math.abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
        const dy = Math.abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
        let err = (dx > dy ? dx : -dy) / 2;

        while (true) {
            drawPixelIntFrame(x0, y0, brushMag, brushPhase, bo, po);
            if (x0 === x1 && y0 === y1) break;
            const e2 = err;
            if (e2 > -dx) { err -= dy; x0 += sx; }
            if (e2 < dy)  { err += dx; y0 += sy; }
        }
    }

    specCtx.putImageData(imageBuffer, 0, 0);
    renderView();
}

function paint(cx, cy, scaleX, scaleY, startX_vis, startY_vis) {
    if (!mags || !phases) return;

    const fullW = specWidth;
    const fullH = specHeight;
    const po = currentTool === "eraser" ? 1 : phaseOpacity;
    const bo = currentTool === "eraser" ? 1 : brushOpacity;

    function drawPixelFrame(xFrame, yDisplay, mag, phase, bo, po) {
        const xI = Math.round(xFrame);
        const yI = Math.round(yDisplay);
        if (xI < 0 || xI >= fullW || yI < 0 || yI >= fullH) return;
        const bin = displayYToBin(yI, fullH);
        const idx = xI * fullH + bin;
        if (idx < 0 || idx >= mags.length) return;
        const oldMag = mags[idx] || 0;
        const oldPhase = phases[idx] || 0;
        const newMag = oldMag * (1 - bo) + mag * bo;
        const newPhase = oldPhase + po * (phase - oldPhase);
        mags[idx] = newMag;
        phases[idx] = newPhase;
        const displayY = binToDisplayY(bin, fullH);
        const pix = (displayY * fullW + xI) * 4;
        const [r, g, b] = magPhaseToRGB(newMag, newPhase);
        imageBuffer.data[pix] = r;
        imageBuffer.data[pix + 1] = g;
        imageBuffer.data[pix + 2] = b;
        imageBuffer.data[pix + 3] = 255;
    }

    if (currentTool === "brush" || currentTool === "eraser") {
        const radiusY = brushSize;
        const rect = canvas.getBoundingClientRect();
        const radiusXFrames = Math.floor(radiusY * iWidth / hopSizeEl.value/2/(rect.width/rect.height));

        const minXFrame = Math.max(0, Math.floor(cx - radiusXFrames));
        const maxXFrame = Math.min(fullW - 1, Math.ceil(cx + radiusXFrames));
        const minY = Math.max(0, Math.floor(cy - radiusY*(fWidth/(sampleRate/2))));
        const maxY = Math.min(fullH - 1, Math.ceil(cy + radiusY*(fWidth/(sampleRate/2))));

        const brushMag = currentTool === "eraser" ? 0 : (brushColor / 255) * 128;
        const brushPhase = currentTool === "eraser" ? 0 : penPhase;

        for (let yy = minY; yy <= maxY; yy++) {
            for (let xx = minXFrame; xx <= maxXFrame; xx++) {
                const dx = xx - cx;
                const dy = yy - cy;

                if ((dx * dx) / (radiusXFrames * radiusXFrames) + (dy * dy) / (radiusY * radiusY) > 1) continue;
                drawPixelFrame(xx, yy, brushMag, brushPhase, bo, po);
            }
        }
    } else if (currentTool === "blur") {
        const radius = brushSize;

        const minXFrame = Math.max(0, Math.floor(cx - radius));
        const maxXFrame = Math.min(fullW - 1, Math.ceil(cx + radius));
        const minY = Math.max(0, Math.floor(cy - radius));
        const maxY = Math.min(fullH - 1, Math.ceil(cy + radius));

        for (let yy = minY; yy <= maxY; yy++) {
            for (let xx = minXFrame; xx <= maxXFrame; xx++) {
                let sumMag = 0, sumPhase = 0, count = 0;
                for (let oy = -1; oy <= 1; oy++) {
                    for (let ox = -1; ox <= 1; ox++) {
                        const nx = xx + ox, ny = yy + oy;
                        if (nx < 0 || ny < 0 || nx >= fullW || ny >= fullH) continue;
                        const nidx = nx * fullH + displayYToBin(ny, fullH);
                        sumMag += mags[nidx] || 0;
                        sumPhase += phases[nidx] || 0;
                        count++;
                    }
                }
                if (count > 0) drawPixelFrame(xx, yy, sumMag / count, sumPhase / count, bo, po);
            }
        }
    } else if (currentTool === "image" && overlayImage) {

      const screenSpace = true;

      const rect = canvas.getBoundingClientRect();

      const pixelsPerFrame = rect.width  / Math.max(1, canvas.width);
      const pixelsPerBin   = rect.height / Math.max(1, canvas.height);

      const desiredScreenMax = brushSize * 4;

      const imgW = overlayImage.width;
      const imgH = overlayImage.height;
      const imgAspect = imgW / imgH;

      let screenW, screenH;
      if (imgW >= imgH) {
        screenW = desiredScreenMax;
        screenH = Math.max(1, Math.round(desiredScreenMax / imgAspect));
      } else {
        screenH = desiredScreenMax;
        screenW = Math.max(1, Math.round(desiredScreenMax * imgAspect));
      }

      let overlayW, overlayH;
      if (screenSpace) {

        overlayW = Math.max(1, Math.round(screenW / pixelsPerFrame));
        overlayH = Math.max(1, Math.round(screenH / pixelsPerBin));
      } else {

        overlayH = Math.max(1, Math.round(brushSize));
        overlayW = Math.max(1, Math.round(overlayH * imgAspect));
      }

      const ox = Math.floor(cx - overlayW / 2);
      const oy = Math.floor(cy - overlayH / 2);

      const tempCanvas = document.createElement("canvas");
      tempCanvas.width = overlayW;
      tempCanvas.height = overlayH;
      const tctx = tempCanvas.getContext("2d");

      tctx.imageSmoothingEnabled = false;
      tctx.drawImage(overlayImage, 0, 0, overlayW, overlayH);

      const imgData = tctx.getImageData(0, 0, overlayW, overlayH);

      for (let yy = 0; yy < overlayH; yy++) {
        for (let xx = 0; xx < overlayW; xx++) {
          const pix = (yy * overlayW + xx) * 4;
          const r = imgData.data[pix];
          const g = imgData.data[pix + 1];
          const b = imgData.data[pix + 2];
          const a = imgData.data[pix + 3] / 255;
          if (a <= 0) continue; 
          const [mag, phase] = rgbToMagPhase(r, g, b);
          const cxPix = ox + xx;
          const cyPix = oy + yy;
          if (cxPix >= 0 && cyPix >= 0 && cxPix < fullW && cyPix < fullH) {

            drawPixelFrame(cxPix, cyPix, mag, phase, brushOpacity * a, phaseOpacity * a);
          }
        }
      }

    }

    specCtx.putImageData(imageBuffer, 0, 0);
    renderView();
}

let sineOsc = null;
let sineGain = null;
function setSineFreq(cy) {
    const h = specHeight;
    const s = parseFloat(logScaleVal); 

    let bin;
    if (s <= 1.0000001) {

        bin = h - 1 - cy;
    } else {

        const a = s - 1;
        const denom = Math.log(1 + a * (h - 1));
        const t = 1 - cy / (h - 1);
        bin = (Math.exp(t * denom) - 1) / a;
    }

    bin = Math.max(0, Math.min(h - 1, bin));

    const freq = bin * sampleRate / fftSize;

    sineOsc.frequency.setTargetAtTime(freq, audioCtx.currentTime, 0.01);
}
function visibleToSpecY(visY) {
    const fStart = Math.max(0, Math.floor(specHeight * (1 - fHigh / (sampleRate/2))));
    const fullY = Math.round(visY + fStart);
    return Math.max(0, Math.min(specHeight - 1, fullY));
}
canvas.addEventListener("mousedown", e=>{
    if (!mags || !phases) return;
    painting = true;
    stopSource();
    paintedPixels = new Set();
    const {cx,cy,scaleX,scaleY} = getCanvasCoords(e);
    startX = cx; startY = cy;
    overlayCtx.clearRect(0,0,overlayCanvas.width, overlayCanvas.height);

    const realY = visibleToSpecY(cy);

    if (!(currentTool === "rectangle" || currentTool === "line")) {

        paint(cx + iLow, realY, scaleX, scaleY, startX, startY);
    }

    ensureAudioCtx();
    mouseDown = true;
    currentFrame = Math.floor(cx);
    playFrame(currentFrame);

    if (!sineOsc) {
        sineOsc = audioCtx.createOscillator();
        sineOsc.type = "sine";
        sineGain = audioCtx.createGain();
        sineGain.gain.value = 0.2;
        sineOsc.connect(sineGain).connect(audioCtx.destination);
        setSineFreq(realY); 
        sineOsc.start();
    }
});

canvas.addEventListener("mousemove", e=>{
    if(!painting && currentTool != "image") return;
    const {cx,cy,scaleX,scaleY} = getCanvasCoords(e);

    if (currentTool === "rectangle" || currentTool === "line" || currentTool === "image") {
      previewShape(cx, cy);
    } else {
      overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
      const realY = visibleToSpecY(cy);
      paint(cx + iLow, realY, scaleX, scaleY, startX, startY);
    }

    currentFrame = Math.floor(cx);
    if (mouseDown) {
        playFrame(currentFrame);

        if (sineOsc) setSineFreq( visibleToSpecY(cy) ); 
    }

    currentCursorX = currentFrame;
    drawCursor();
});

document.addEventListener("mouseup", e => {
    if (!mags || !phases || !painting) return;

    es.style.display = "none";
    painting = false;
    paintedPixels = null;
    mouseDown = false;
    stopSource();
    if (sineOsc) {
        sineOsc.stop();
        sineOsc.disconnect();
        sineOsc = null;
        sineGain = null;
    }
    if (!pcm) { 
        playPCM(); 
        return; 
    }
    const { cx, cy } = getCanvasCoords(e);
    if (currentTool === "rectangle" || currentTool === "line") {
        commitShape(cx, cy); 
        overlayCtx.clearRect(0,0,overlayCanvas.width,overlayCanvas.height);
    }

    startX=startY=null;

    const newPCM = new Float32Array(pcm.length);
    const overlapCount = new Float32Array(pcm.length);
    const window = new Float32Array(fftSize);
    for (let i = 0; i < fftSize; i++) window[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (fftSize - 1)));

    const h = specHeight;
    const w = specWidth;

    for (let xCol = 0; xCol < w; xCol++) {
        const re = new Float32Array(fftSize);
        const im = new Float32Array(fftSize);

        for (let bin = 0; bin < h; bin++) {
            const idx = xCol * h + bin;
            let mag = mags[idx] || 0;
            const phase = phases[idx] || 0;

            re[bin] = mag * Math.cos(phase);
            im[bin] = mag * Math.sin(phase);

            if (bin > 0 && bin < fftSize / 2) {
                const sym = fftSize - bin;
                re[sym] = re[bin];
                im[sym] = -im[bin];
            }
        }

        ifft_inplace(re, im);

        for (let i = 0; i < fftSize; i++) {
            const posPCM = xCol * hop + i;
            if (posPCM >= pcm.length) break;

            newPCM[posPCM] += re[i] * window[i];
            overlapCount[posPCM] += window[i] * window[i];
        }
    }

    for (let i = 0; i < pcm.length; i++) {
        if (overlapCount[i] > 0) newPCM[i] /= overlapCount[i];
    }

    pcm.set(newPCM);

const startFrame = Math.max(0, Math.floor(iLow || 0));
pos = startFrame * hop;
x = startFrame;
rendering = true;
    requestAnimationFrame(drawLoop);

    startTime = performance.now();
    audioProcessed = 0;

    playPCM();
    console.log("PCM updated from phase-aware spectrogram!");
});

let sourceNode = null;
let playing = false;
let mouseDown = false;
let currentFrame = 0; 
let pausedAtSample = null; 
let sourceStartTime = 0; 
let wasPlayingDuringDrag = false;

initEmptyPCM();

function updateCursorLoop() {
    if (playing && !painting && pcm && sourceNode) {
        const elapsed = audioCtx.currentTime - sourceStartTime; 
        let samplePos = elapsed * sampleRate;

        if (sourceNode.loop) {
            samplePos = samplePos % pcm.length; 
        }

        const frame = Math.floor(samplePos / hop);
        currentCursorX = Math.min(frame, specWidth - 1);

        specCtx.putImageData(imageBuffer, 0, 0);
        renderView();
        drawCursor();
    }
    requestAnimationFrame(updateCursorLoop);
}
updateCursorLoop();

function stopSource(preservePaused=false){
    if(sourceNode){
        try { sourceNode.stop(); } catch(e) {  }
        try { sourceNode.disconnect(); } catch(e) {  }
        sourceNode = null;
    }

    if (!preservePaused) pausedAtSample = null;
    playing = false;
}

function playPCM(loop = true, startFrame = null) {
    if (!pcm) return;
    ensureAudioCtx();
    stopSource(true);

    let startSample = 0;
    if (startFrame !== null && !isNaN(startFrame)) {
        startSample = Math.max(0, Math.min(pcm.length - 1, startFrame * hop));
    } else if (pausedAtSample !== null) {
        startSample = Math.max(0, Math.min(pcm.length - 1, pausedAtSample));
    } else {
        startSample = 0;
    }

    sourceNode = audioCtx.createBufferSource();
    const buffer = audioCtx.createBuffer(1, pcm.length, sampleRate);
    buffer.copyToChannel(pcm, 0);
    sourceNode.buffer = buffer;
    sourceNode.loop = !!loop;
    sourceNode.connect(audioCtx.destination);

    const offsetSec = startSample / sampleRate;
    sourceStartTime = audioCtx.currentTime - offsetSec;
    try {
        sourceNode.start(0, offsetSec);
    } catch (e) {

        const remaining = pcm.length - startSample;
        const shortBuf = audioCtx.createBuffer(1, Math.max(1, remaining), sampleRate);
        shortBuf.copyToChannel(pcm.subarray(startSample, startSample + remaining), 0);
        sourceNode.stop();
        sourceNode.disconnect();
        sourceNode = audioCtx.createBufferSource();
        sourceNode.buffer = shortBuf;
        sourceNode.loop = !!loop;
        sourceNode.connect(audioCtx.destination);
        sourceStartTime = audioCtx.currentTime;
        sourceNode.start();
    }

    playing = true;
    pausedAtSample = null; 
}

function playFrame(frameX) {
    currentCursorX = frameX;
    if (!pcm) return;
    ensureAudioCtx();
    stopSource(true);
    const start = frameX * hop;
    const end = Math.min(start + fftSize, pcm.length);
    if (end <= start) return;
    const frameLen = end - start;

    const buffer = audioCtx.createBuffer(1, frameLen, sampleRate);
    buffer.copyToChannel(pcm.subarray(start, end), 0);

    sourceNode = audioCtx.createBufferSource();
    sourceNode.buffer = buffer;
    sourceNode.loop = true; 
    sourceNode.connect(audioCtx.destination);
    sourceStartTime = audioCtx.currentTime - (start / sampleRate);
    sourceNode.start();
    playing = true;
    pausedAtSample = null;
}

function renderFullSpectrogramToImage() {
    if (!imageBuffer || !mags || !phases) return;
    const w = specWidth, h = specHeight;
    for(let xx=0; xx<w; xx++){

        for(let yy=0; yy<h; yy++){

            const bin = displayYToBin(yy, h);
            const idx = xx * h + bin;
            const mag = mags[idx] || 0;
            const phase = phases[idx] || 0;
            const [r,g,b] = magPhaseToRGB(mag, phase);
            const pix = (yy * w + xx) * 4;
            imageBuffer.data[pix] = r;
            imageBuffer.data[pix+1] = g;
            imageBuffer.data[pix+2] = b;
            imageBuffer.data[pix+3] = 255;
        }
    }
    specCtx.putImageData(imageBuffer, 0, 0);
    renderView();
}

</script>
<script src="downloads.js"></script>
<script>

const timeline = document.getElementById('timeline');
const tctx = timeline.getContext('2d');

let timelineWidth = timeline.width; 
let timelineHeight = 20;
let timelineCursorX = 0;
let draggingTimeline = false;
let draggingBounds = false;
let tDmode = -1;
let oldX = null;
let iWidth = iHigh - iLow;

function drawTimeline() {
    tctx.clearRect(0, 0, timeline.width, timeline.height);

    tctx.fillStyle = "#333";
    tctx.fillRect(0, 0, timeline.width, timeline.height);

    const ts = 20; 
    const tx = (timelineCursorX-iLow) * timeline.width / (iHigh-iLow);
    const tx2 = timelineCursorX * timeline.width / framesTotal;

    tctx.fillStyle = "#0f0";
    tctx.beginPath();
    tctx.moveTo(tx, ts+10);
    tctx.lineTo(tx - ts, 10);
    tctx.lineTo(tx + ts, 10);
    tctx.closePath();
    tctx.fill();

    if (!pcm) return;
    iWidth = iHigh - iLow;
    const totalSeconds = iWidth*hopSizeEl.value / sampleRate;

    let interval = 0.01; 
    if (totalSeconds > 0.3) interval = 0.1;
    if (totalSeconds > 1) interval = 0.3;
    if (totalSeconds > 3) interval = 1;
    if (totalSeconds > 10) interval = 3;
    if (totalSeconds > 30) interval = 10;
    if (totalSeconds > 100) interval = 30;

    tctx.fillStyle = "#eee";
    tctx.font = "15px sans-serif";
    tctx.textAlign = "center";
    tctx.textBaseline = "top";
    const factor = timeline.width / framesTotal;
    const visibleFrames = iHigh - iLow;
    const secondsPerFrame = hopSizeEl.value / sampleRate;

    const sLow = iLow * secondsPerFrame;
    const sHigh = iHigh * secondsPerFrame;

    let tStart = Math.ceil(sLow / interval) * interval;

    for (let t = tStart; t <= sHigh; t += interval) {
        const frame = t / secondsPerFrame; 
        const markerX = (frame - iLow) / visibleFrames * timeline.width;

        tctx.fillText(
            t.toFixed(interval < 1 ? 2 : interval < 10 ? 1 : 0),
            markerX,
            25
        );
    }

    tctx.fillStyle = "#222";
    tctx.fillRect(0, 0, timeline.width, 20);
    tctx.fillStyle = "#555";
    tctx.fillRect(iLow*factor, 0, (iHigh-iLow)*factor, 20);
    tctx.strokeStyle = "#777";
    tctx.strokeRect(iLow*factor, 0, (iHigh-iLow)*factor, 20);
    tctx.fillStyle = "#af0";
    tctx.fillRect(tx2-1,0,2,20);
}

function timelineXToFrame(clientXLeft) {
    return iLow + clientXLeft/timeline.getBoundingClientRect().width*iWidth;
}

timeline.addEventListener("mousedown", e => {
    const rect = timeline.getBoundingClientRect();
    if (e.clientY- rect.top>20) {
      draggingTimeline = true;
      wasPlayingDuringDrag = playing;

      stopSource(true);
      timelineCursorX = timelineXToFrame(e.clientX - rect.left);

      currentCursorX = timelineCursorX;
      drawTimeline();
      drawYAxis();
      drawLogScale();
      drawCursor();
    } else {
      draggingBounds = true;
      oldX = e.clientX- rect.left;
      iWidth = iHigh-iLow;
    }
});
window.addEventListener("mousemove", e => {
    const rect = timeline.getBoundingClientRect();
    const mouseY = e.clientY- rect.top;
    const mouseX = e.clientX- rect.left;
    if (mouseY > 20 && tDmode == -1) {
      timeline.style.cursor = "pointer";
      if (!draggingTimeline) return;
      timelineCursorX = timelineXToFrame(mouseX);
      currentCursorX = timelineCursorX;
      drawTimeline();
      drawYAxis();
      drawLogScale();
      drawCursor();
    } else {
      const sLow = iLow * rect.width/framesTotal;
      const sHigh = iHigh * rect.width/framesTotal;
      iWidth = iHigh-iLow;
      if ((Math.abs(mouseX - sLow)<15 && tDmode == -1) || tDmode == 0) {
        timeline.style.cursor = "e-resize";
        if (!draggingBounds) return;
        updateCanvasScroll();
        tDmode = 0;
        iLow = mouseX/rect.width*framesTotal;
        if (iLow < 0) {
          iLow = 0;
        }
        if (iLow > iHigh) iLow = iHigh - 1;
      } else if ((Math.abs(mouseX - sHigh)<15 && tDmode == -1) || tDmode == 1) {
        timeline.style.cursor = "w-resize";
        if (!draggingBounds) return;
        updateCanvasScroll();
        tDmode = 1;
        iHigh = mouseX/rect.width*framesTotal;
        if (iHigh > framesTotal) {
          iHigh = framesTotal;
        }
        if (iHigh < iLow) iHigh = iLow + 1;
      } else {
        timeline.style.cursor = "move";
        if (!draggingBounds) return;
        updateCanvasScroll();
        tDmode = 2;
        const inc = (mouseX-oldX)/rect.width*framesTotal
        iLow += inc;
        if (iLow < 0) {
          iLow = 0;
        }
        if (iHigh > framesTotal) {
          iLow = framesTotal - iWidth;
        }
        iHigh = iLow + iWidth;
        oldX = mouseX;
      }
    }
});
window.addEventListener("mouseup", e => {
    tDmode = -1;
    draggingBounds = false;
    if (!draggingTimeline) return;
    draggingTimeline = false;
    const frame = timelineCursorX;

    pausedAtSample = frame * hop;

    if (wasPlayingDuringDrag) {
        playPCM(true, frame);
        document.getElementById("playPause").innerHtml = `
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 20 20">
        <rect x="2" y="0" width="5" height="18" rx="2" ry="2"/>
        <rect x="12" y="0" width="5" height="18" rx="2" ry="2"/>
      </svg>
        `;
    } else {
        specCtx.putImageData(imageBuffer, 0, 0);
        renderView();
        drawCursor();
    }
    drawTimeline();
    drawLogScale();
    drawYAxis();
});

fLow = 0;
fHigh = sampleRate/2;
let fWidth = fHigh-fLow;
let draggingFreq = false;
let fDmode = -1;
let oldY = null;

function freqToDisplayY(bin, h) {
    if (!h) return 0;
    const s = getLogScaleSlider();
    if (s <= 1.0000001) {
        return Math.round(h - 1 - bin); 
    } else {
        const a = s - 1;
        const denom = Math.log(1 + a * (h - 1));
        if (!isFinite(denom) || denom === 0) return Math.round(h - 1 - bin);
        const t = Math.log(1 + a * bin) / denom; 
        const y = (1 - t) * (h - 1);
        return Math.round(y);
    }
}

function drawYAxis() {
    if (yAxis.height <= 0 || yAxis.width <= 0) return;

    const temp = document.createElement("canvas");
    let resolution = (sampleRate/2)/fWidth;
    if (resolution > 15) resolution = 15;
    temp.width = yAxis.width;   
    temp.height = 2048*resolution;   
    const tctx = temp.getContext("2d");

    tctx.clearRect(0, 0, temp.width, temp.height);
    tctx.fillStyle = "#333";
    tctx.fillRect(0, 0, temp.width, temp.height);

    let interval = 1000;
    if (fWidth <= 500) interval = 100;
    else if (fWidth <= 2000) interval = 250;
    else if (fWidth <= 5000) interval = 500;

    const scaleToTemp = specHeight*resolution / yAxis.height;
    tctx.fillStyle = "#eee";
    tctx.font = "10px sans-serif";
    tctx.textAlign = "right";
    tctx.textBaseline = "middle";
    const labelX = Math.max(40, temp.width - 4);

    for (let f = 0; f <= sampleRate / 2; f += interval) {

        const posY_visible = freqToDisplayY((f) / (sampleRate * 2) * 2048, yAxis.height);

        const posY_temp = Math.round(posY_visible * scaleToTemp);
        const label = (f / 1000).toFixed(1) + "k";
        tctx.save();
        const yFactor = fWidth/(sampleRate/4/resolution)*(fftSize/2048);
        tctx.scale(1.0, yFactor);
        tctx.fillText(label, labelX, posY_temp/yFactor);
        tctx.restore();
    }

    tctx.fillStyle = "#222";
    tctx.fillRect(0, 0, 15, temp.height);

    const fStart = Math.max(0, Math.floor(specHeight * (1 - fHigh / (sampleRate / 2))));
    const fEnd = Math.min(specHeight, Math.floor(specHeight * (1 - fLow / (sampleRate / 2))));
    const viewHeightSpec = Math.max(1, fEnd - fStart);

    yctx.clearRect(0, 0, yAxis.width, yAxis.height);
    yctx.drawImage(
        temp,
        0, fStart*resolution,                  
        temp.width, viewHeightSpec*resolution, 
        0, 0,                       
        yAxis.width, yAxis.height   
    );

    const factorVisible = yAxis.height / (sampleRate / 2);
    yctx.fillStyle = "#222";
    yctx.fillRect(0, 0, 15, yAxis.height);
    const fhVisible = (fHigh - fLow) * factorVisible;
    const topVisible = Math.max(0, Math.min(yAxis.height, yAxis.height - fhVisible - fLow * factorVisible));
    yctx.fillStyle = "#555";
    yctx.fillRect(0, topVisible, 15, Math.max(1, fhVisible));
    yctx.strokeStyle = "#777";
    yctx.strokeRect(0, topVisible, 15, Math.max(1, fhVisible));
}

yAxis.addEventListener("mousedown", e => {
    const rect = yAxis.getBoundingClientRect();
    if (e.clientX - rect.left < 15) {
        draggingFreq = true;
        oldY = e.clientY - rect.top;
        fWidth = fHigh - fLow;
    }
});

window.addEventListener("mousemove", e => {
    const rect = yAxis.getBoundingClientRect();
    const mouseY = e.clientY - rect.top;
    const mouseX = e.clientX - rect.left;

    if (mouseX < 15) {
        const sLow = (fLow / (sampleRate/2)) * rect.height;
        const sHigh = (fHigh / (sampleRate/2)) * rect.height;
        fWidth = fHigh - fLow;

        if ((Math.abs(mouseY - (rect.height - sLow)) < 15 && fDmode == -1) || fDmode == 0) {
            yAxis.style.cursor = "s-resize";
            if (!draggingFreq) return;
            updateCanvasScroll();
            fDmode = 0;
            fLow = (1 - mouseY / rect.height) * (sampleRate/2);
            if (fLow < 0) fLow = 0;
            if (fLow > fHigh) fLow = fHigh - 1;
        } else if ((Math.abs(mouseY - (rect.height - sHigh)) < 15 && fDmode == -1) || fDmode == 1) {
            yAxis.style.cursor = "n-resize";
            if (!draggingFreq) return;
            updateCanvasScroll();
            fDmode = 1;
            fHigh = (1 - mouseY / rect.height) * (sampleRate/2);
            if (fHigh > sampleRate/2) fHigh = sampleRate/2;
            if (fHigh < fLow) fHigh = fLow + 1;
        } else {
            yAxis.style.cursor = "move";
            if (!draggingFreq) return;
            updateCanvasScroll();
            fDmode = 2;
            const inc = (oldY - mouseY) / rect.height * (sampleRate/2);
            fLow += inc;
            if (fLow < 0) fLow = 0;
            if (fHigh > sampleRate/2) fLow = sampleRate/2 - fWidth;
            fHigh = fLow + fWidth;
            oldY = mouseY;
        }
    }
});

window.addEventListener("mouseup", e => {
    fDmode = -1;
    draggingFreq = false;
});

const playPauseBtn = document.getElementById("playPause");
const stopBtn = document.getElementById("stop");
const playHtml = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="9 8 16 16"><path d="M16 0 M14 22V10l8 6z"/></svg>`;
const pauseHtml = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 20 20"><rect x="2" y="0" width="5" height="18" rx="2" ry="2"/><rect x="12" y="0" width="5" height="18" rx="2" ry="2"/></svg>`;

function playPause() {
  ensureAudioCtx();
    if (playing) {
        const elapsed = audioCtx.currentTime - sourceStartTime;
        let samplePos = Math.floor(elapsed * sampleRate);
        if (sourceNode && sourceNode.loop) {
            samplePos = samplePos % pcm.length;
        }
        pausedAtSample = Math.max(0, Math.min(pcm.length - 1, samplePos));
        stopSource(true);
        playPauseBtn.innerHTML = playHtml;
    } else {
        const startFrame = (pausedAtSample !== null) ? Math.floor(pausedAtSample / hop) : 0;
        playPCM(true, startFrame);
        playPauseBtn.innerHTML = pauseHtml;
    }
}

playPauseBtn.addEventListener("click", () => {
    playPause();
});

document.addEventListener('keydown', function(event) {
  if (event.key === ' ') {
    playPause();
    event.preventDefault();
  }
});

stopBtn.addEventListener("click", () => {
    stopSource(false); 
    timelineCursorX = 0;
    currentCursorX = 0;
    drawTimeline();
    drawYAxis();
    drawLogScale();
    specCtx.putImageData(imageBuffer, 0, 0);
    renderView();
    drawCursor();
    playPauseBtn.innerHTML = playHtml;
});

function updateTimelineCursor() {
    if (playing && !draggingTimeline && pcm && sourceNode) {
        const elapsed = audioCtx.currentTime - sourceStartTime;
        let samplePos = elapsed * sampleRate;

        if (sourceNode.loop) {
            samplePos = samplePos % pcm.length;
        }

        const frame = Math.floor(samplePos / hop);
        timelineCursorX = Math.min(frame, specWidth-1);
        currentCursorX = timelineCursorX;
        drawTimeline();
        drawYAxis();
        drawCursor();
    }
    requestAnimationFrame(updateTimelineCursor);
}
updateTimelineCursor();

drawTimeline();
drawYAxis();
drawLogScale();
renderFullSpectrogramToImage();
</script>
</body>
</html>