<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>SpectroDraw - Interactive spectrogram editor</title>
  <link rel="stylesheet" type="text/css" href="style.css">
  <link rel="icon" href="/favicon32x32.ico"/>
</head>
<body>
  <!-- New page layout -->
<div class="app">
  <header class="top-bar">
    <a href="/" id="home" title="Home" style="margin-left:10px;"><img src="/BannerLogo.jpg" style="background:transparent; height: 32px;"></a>
    <button id="fileB" title="Upload Audio" style="margin-left: 10px">
      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20" fill="none" stroke="#333" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
        <line x1="10" y1="16" x2="10" y2="6" />
        <polyline points="6 10 10 6 14 10" />
        <line x1="4" y1="16" x2="16" y2="16" />
      </svg>
    </button>
    <button id="rec" title="Record (Ctrl + space)"></button>
    <input id="file" title="Import audio (Ctrl + O)" type="file" accept="audio/*,video/*" style="display:none;"/>
    <button id="playPause" title="Play (space)" style="margin-left: 20px">
      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="#333" viewBox="9 8 16 16"><path d="M16 0 M14 22V10l8 6z"/></svg>
    </button>
    <button id="stop" title="Stop">
      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="#333" viewBox="0 0 20 20">
        <rect x="0" y="0" width="18" height="18" rx="2" ry="2"/>
      </svg>
    </button>
    <button class="tool-btn" data-tool="brush" id="brushBtn" style="margin-left: 20px" title="Brush (b)">
      <svg xmlns="http://www.w3.org/2000/svg" 
           width="20" height="20" 
           viewBox="5 4 18 18" 
           fill="black">
        <path d="M20.71 4.63a2 2 0 0 0-2.83 0l-9.9 9.9a3 3 0 0 0-.78 1.37l-.69 2.76a1 1 0 0 0 1.21 1.21l2.76-.69a3 3 0 0 0 1.37-.78l9.9-9.9a2 2 0 0 0 0-2.83zm-11.24 11.3l-.88.22.22-.88 9.19-9.19.66.66z"/>
      </svg>
    </button>
    <button class="tool-btn" data-tool="rectangle" id="rectBtn" title="Rectangle (r)">
      <svg xmlns="http://www.w3.org/2000/svg" 
           width="20" height="20" viewBox="0 0 20 20" 
           fill="none"
           stroke = "black" stroke-width = "5">
        <path d="M0 0 H 20 V 20 H 0 V -20"/>
      </svg>
    </button>
    <button class="tool-btn" data-tool="line" id="lineBtn" title="Line (l)">
      <svg xmlns="http://www.w3.org/2000/svg" 
           width="20" height="20" viewBox="0 0 20 20" 
           fill="none"
           stroke = "black" stroke-width = "3">
        <path d="M20 0 L 0 20"/>
      </svg>
    </button>
    <button class="tool-btn" data-tool="blur" id="blurBtn" title="Blur (u)">
      <svg xmlns="http://www.w3.org/2000/svg" 
           width="24" height="24" 
           viewBox="0 0 24 24" 
           fill="black">
        <path d="M12 2C12 2 7 10 7 14a5 5 0 0 0 10 0c0-4-5-12-5-12z"/>
      </svg>
    </button>
    <button class="tool-btn" data-tool="eraser" id="eraserBtn" title="Eraser (e)">
      <svg width="20" height="20" viewBox="-1 -1 16 16">
        <path d="M5,0 L0,5 L5,10 L10,5 Z " fill="#333" stroke="#333" stroke-width="1"/>
        <path d="M5,10 L10,5 L15,10 L12,13 L8,13 Z" fill="white" stroke="#333" stroke-width="1"/>
      </svg>
    </button>
    <button class="tool-btn" data-tool="amplifier" id="amplifierBtn" title="Amplifier / Reducer (a)">
      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20" fill="none">
        <path d="M2 8V12C2 12.55 2.45 13 3 13H5L7 17C7.18 17.36 7.56 17.59 7.95 17.59C8.63 17.59 9.08 16.86 8.79 16.25L7.2 13H9L16 17V3L9 7H5V7H3C2.45 7 2 7.45 2 8Z" fill="#333"/>
        <path d="M18 7C18.55 7 19 7.45 19 8V12C19 12.55 18.55 13 18 13" stroke="#333" stroke-width="1.2" stroke-linecap="round"/>
    </svg>
    </button>
    <button class="tool-btn" data-tool="image" id="imageBtn" title="Image Overlay (i)">
      <svg width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="#333" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="18" cy="6" r="3" fill="#333" stroke="none"/>
        <polygon points="1,20 8,10 15,20" fill="#333"/>
        <polygon points="8,20 15,12 23,20" fill="#333"/>
      </svg>
    </button>
    <input type="file" id="overlayFile" accept="image/*" style="display:none;">
    <button id="trueScale" title="Use true aspect ratio" style="margin-left: 20px">
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" aria-hidden="true" role="img">
        <title>Enter fullscreen</title>
        <g fill="none" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M3 9V3h6" />
          <path d="M15 3h6v6" />
          <path d="M3 15v6h6" />
          <path d="M21 15v6h-6" />
        </g>
      </svg>
    </button>
    <button id="yAxisMode" title="Toggle Y axis label mode (y)">
      <svg xmlns="http://www.w3.org/2000/svg" 
         width="28" height="28" viewBox="0 0 20 20" 
         fill="none" stroke="black" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
        <text x="0" y="18" font-size="8" fill="black" stroke-width="0.5">1.0k</text>
        <text x="10" y="6" font-size="8" fill="black" stroke-width="0.5">a5</text>
        <line x1="4" y1="4" x2="18" y2="14" />
      </svg>
    </button>
     <button id="downloadWav" style="margin-left:20px" title="Download audio (ctrl + s)">
      <svg width="20" height="20" viewBox="2 2 20 21" fill="none" stroke="#333" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M4 14v-2a8 8 0 0 1 16 0v2" />
        <path d="M5 14v4h2v-4H6z" />
        <path d="M17 14v4h2v-4h-2z" />
        <path d="M12 12v10" />
        <path d="M9 19l3 3 3 -3" />
      </svg>
    </button>
    <button id="downloadButton" title="Download spectrogram (ctrl + shift + s)">
      <svg width="20" height="20" viewBox="2 2 20 21" fill="none" stroke="#333" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <rect x="3" y="3" width="18" height="14" rx="2" ry="2" />
        <circle cx="17" cy="7" r="2" />
        <polyline points="3 17 10 10 14 14 21 7" />
        <path d="M12 12v10" />
        <path d="M9 19l3 3 3 -3" />
      </svg>
    </button>
    <button id="resetButton" onClick="initEmptyPCM()" title="Reset audio">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#333" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <rect x="5" y="7" width="14" height="14" rx="2" ry="2" />
        <line x1="8" x2="8" y1="11" y2 = "17" stroke-width="1"/>
        <line x1="12" x2="12" y1="11" y2 = "17" stroke-width="1"/>
        <line x1="16" x2="16" y1="11" y2 = "17" stroke-width="1"/>
        <rect x="3" y="4" width="18" height="3" rx="2" ry="2" />
        <rect x="8" y="1" width="8" height="2" rx="2" ry="2" stroke-width="1"/>
      </svg>
    </button>
    <button id="undoBtn" title="Undo (Ctrl+Z)">
      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M9 14H5V10"/>
        <path d="M20 20a9 9 0 0 0-15-6.7L5 10"/>
      </svg>
    </button>
    <button id="redoBtn" title="Redo (Ctrl+Y)">
      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M15 14h4v-4"/>
        <path d="M4 20a9 9 0 0 1 15-6.7L19 10"/>
      </svg>
    </button>
  </header>
  <aside class="left-bar">
  <!-- Settings cogwheel -->
  <button class="panel-btn" id="settingsBtn" title="General (g)" data-tool="0">
    <svg xmlns="http://www.w3.org/2000/svg" 
         width="20" height="20" viewBox="0 0 24 24" 
         fill="none" stroke="white" stroke-width="2" 
         stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="3"/>
      <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 1 1-2.83 2.83l-.06-.06a1.65 
               1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 
               1 1-4 0v-.09a1.65 1.65 0 0 0-1-1.51 
               1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 
               1 1-2.83-2.83l.06-.06a1.65 
               1.65 0 0 0 .33-1.82 1.65 
               1.65 0 0 0-1.51-1H3a2 2 0 
               1 1 0-4h.09a1.65 1.65 0 
               0 0 1.51-1 1.65 1.65 0 
               0 0-.33-1.82l-.06-.06a2 
               2 0 1 1 2.83-2.83l.06.06a1.65 
               1.65 0 0 0 1.82.33H9a1.65 
               1.65 0 0 0 1-1.51V3a2 2 
               0 1 1 4 0v.09a1.65 1.65 0 
               0 0 1 1.51 1.65 1.65 0 
               0 0 1.82-.33l.06-.06a2 
               2 0 1 1 2.83 2.83l-.06.06a1.65 
               1.65 0 0 0-.33 1.82V9c0 
               .69.28 1.35.77 1.82.49.47 
               1.15.77 1.82.77h.09a2 2 
               0 1 1 0 4h-.09c-.69 0-1.35.28-1.82.77z"/>
    </svg>
  </button>

  <!-- Piano keys -->
  <button class="panel-btn" id="pianoBtn" title="Piano (p)" data-tool="1">
    <svg xmlns="http://www.w3.org/2000/svg" 
         width="24" height="24" viewBox="0 0 24 22" 
         fill="none" stroke="white" stroke-width="2" 
         stroke-linecap="round" stroke-linejoin="round">
      <rect x="2" y="2" width="20" height="20" rx="2" ry="2"/>
      <line x1="7" y1="4" x2="7" y2="15" stroke-width="3"/>
      <line x1="17" y1="4" x2="17" y2="15" stroke-width="3"/>
      <line x1="12" y1="4" x2="12" y2="15" stroke-width="3"/>
    </svg>
  </button>

  <!-- EQ curve -->
  <button class="panel-btn" id="eqBtn" title="Equalizer (q)" data-tool="2">
    <svg xmlns="http://www.w3.org/2000/svg" 
         width="24" height="24" viewBox="0 0 24 24" 
         fill="none" stroke="white" stroke-width="2" 
         stroke-linecap="round" stroke-linejoin="round">
      <path d="M3 17c2-4 4-6 8-6s6 4 10 4"/>
      <circle cx="3" cy="17" r="1.5" fill="white"/>
      <circle cx="11" cy="11" r="1.5" fill="white"/>
      <circle cx="21" cy="15" r="1.5" fill="white"/>
    </svg>
  </button>
</aside>

  <aside class="left-panel">
    <div style="border:1px solid #888; padding: 4px; margin-top:-11px" id="midiv"><label id="mouseInfo">Pitch: 0hz<br>Time: 0.0<br>Loudness: -inf dB</label><br></div>
    <div id="d1">
      <h2 style="margin-bottom:10px;margin-top:10px;">General</h2>
      <label class="h1">FFT Parameters</label>
      <div class= "slider-row">
        <label class="h2" title="An exponent of 2, height of spectrogram in pixels.">Pitch resolution:</label>
        <input id="fftSize" type="number" value="12" step="1" min="6" max="14" style="margin-left: 102px;">
      </div>
      <div class= "slider-row">
        <label class="h2" title="Number of audio samples given to each frame (x pixel).">Time resolution:</label>
        <input id="hopSize" type="number" value="1024" step="1" min="1" style="margin-left: 102px;">
      </div>
      <label class="h1">Preset audio (Reset audio to apply)<br>
      </label>
      <label class="h2" for="presets">Use presets</label>
      <select id="presets">
        <option value="silence">Silence</option>
        <option value="male">Male sing</option>
        <option value="female">Female sing</option>
        <option value="dog">Dog</option>
        <option value="birdChirp">Bird chirp</option>
        <option value="lionRoar">Lion roar</option>
        <option value="seaLion">Sea lion</option>
        <option value="violin">Violin</option>
        <option value="trumpet">Trumpet</option>
        <option value="timpani">Timpani</option>
        <option value="piano">Piano</option>
        <option value="flute">Flute</option>
        <option value="cymbal">Cymbal</option>
        <option value="computerBeeps">Computer beeps</option>
        <option value="scream">Scream</option>
        <option value="bomb">Bomb</option>
        <option value="engine">Engine</option>
        <option value="fullSpectra">Loud noise</option>
        <option value="bass808">808 bass</option>
        <option value="cave14">Cave14.ogg</option>
        <option value="sine">Sine wave</option>
        <option value="triangle">Triangle wave</option>
        <option value="square">Square wave</option>
        <option value="saw">Saw wave</option>
      </select>
      <div id ="es" class="slider-row" title="Empty audio seconds">
        <label class="h2">Empty audio seconds</label>
        <input id="emptyAudioLength" type="range" min="0.01" max="100" step="0.01" value="10">
        <input id="emptyAudioLengthInput" type="number" value="10" min="0.01" max="100">
      </div>
      <div id="ev" class="slider-row" title="Background phase">
        <label class="h2" for="phaseType">Background phase</label>
        <select id="phaseType">
          <option value="Static">Static</option>
          <option value="Harmonics">Harmonics</option>
          <option value="Fast sine">Fast sine</option>
          <option value="Empty">Empty</option>
        </select>
      </div>
      <div id="brushSettings">
        <label class="h1">Brush settings</label>
        <canvas id="strokePreview" width="300" height="100" style="border:1px solid #ccc; display:block; margin-top:10px;"></canvas>
        <div class="slider-row" title="Brush size/image size" id="sliderStart">
          <label class="h2">Brush Size</label>
          <input id="brushSize" type="range" min="1" max="200" value="10">
          <input id="brushSizeInput" type="number" value="10" min="1" max="200">
        </div>
        <div class="slider-row" title="Brightness">
            <label class="h2">Brush Brightness</label>
            <input id="brushColor"  type="range" min="0" max="255" value="255">
            <input id="brushColorInput" type="number" value="255" min="0" max="255">
        </div>
        <div class="slider-row" title="Phase">
            <label class="h2">Brush Phase</label>
            <input id="penPhase"  type="range" min="0" max="3.1415" value="0" step="0.0001">
            <input id="penPhaseInput" type="number" value="0" min="0" max="3.1415">
        </div>
        <div class="slider-row" title="Brightness strength">
            <label class="h2">Brush Opacity</label>
            <input id="brushOpacity"  type="range" min="0" max="100" value="100">
            <input id="brushOpacityInput" type="number" value="100" min="0" max="100">
        </div>
        <div class="slider-row" title="Phase strength">
            <label class="h2">Phase Opacity</label>
            <input id="phaseOpacity"  type="range" min="0" max="100" value="0">
            <input id="phaseOpacityInput" type="number" value="0" min="0" max="100">
        </div>
      </div> 
      <div class="slider-row" title="Preview sound while drawing">
          <label class="h2">Sound while drawing</label>
          <input id="previewWhileDrawing" type="checkbox" checked>
      </div>
    </div>
    <div id="d2" style="display:none;">
      <h2 style="margin-bottom:10px;margin-top:10px;">Piano</h2>
      <label class="h1">Brush Alignment</label>
      <!--Auto align pitch-->
      <button class="leftBtn" id="alignPitch" title="Auto align pitch (j)">Auto Align Pitch</button>
      <div id ="a4PitchDiv" class="slider-row" title="A4 pitch" style="display:none;">
        <label class="h2">A4 Pitch</label>
        <input id="a4Pitch" type="range" min="415.304" max="466.163" step="0.01" value="440">
        <input id="a4PitchInput" type="number" value="440">
      </div>
      <!--Auto align time-->
      <button class="leftBtn" id="alignTime" title="Auto align time (k)">Auto Align Time</button>
      <div id ="bpmDiv" class="slider-row" title="BPM" style="display:none;">
        <label class="h2">BPM</label>
        <input id="bpm" type="range" min="0.001" max="500" step="0.01" value="120">
        <input id="bpmInput" type="number" value="120" min="0.001" max="5000">
      </div>
      <label class="h1">MIDI Export</label>
      <!--Remove harmonics button-->
      <button class="leftBtn" id="removeHarmonicsBtn" title="Auto Remove Harmonics" onClick="removeHarmonics()">Remove Harmonics</button>
      <!--Notes per octave (achieve with pitch bends)-->
      <div class="slider-row" title="Notes Per Octave">
        <label class="h2">Notes per octave</label>
        <input id="npo" type="range" min="1" max="48" step="1" value="12">
        <input id="npoInput" type="number" value="12" min="1" max="384">
      </div>
      <!--Noise floor cutoff-->
      <div class="slider-row" title="Noise floor cutoff">
        <label class="h2">Noise floor (dB)</label>
        <input id="noiseFloorCutoff" type="range" min="-50" max="0" step="0.1" value="-30">
        <input id="noiseFloorCutoffInput" type="number" value="-30" min="-50" max="0">
      </div>
      <div class="slider-row" title="Duration cutoff">
        <label class="h2">Duration cutoff (secs)</label>
        <input id="durationCutoff" type="range" min="0" max="1" step="0.001" value="0.05">
        <input id="durationCutoffInput" type="number" value="0.05" min="0" max="1">
      </div>
      <button class="leftBtn" title="Use volume controllers (Not recommended)" id="useVolumeControllers">Use Volume Controllers</button>
      <!--Export button-->
      <button class="leftBtn" id="exportMIDI" title="Export Midi (ctrl + m)" onclick="exportMidi()">Export MIDI</button>
    </div>
    <div id="d3" style="display:none; height: 80%">
      <h2 style="margin-bottom:10px;margin-top:10px;">Equalizer</h2>
      <h5 style="margin-top:0px; margin-bottom:10px;">Note: Does not update on the spectrogram to save lag</h5>
      <div class="slider-row" title="Global gain">
        <label class="h2">Global gain</label>
        <input id="globalGain" type="range" min="-30" max="30" step="0.1" value="0">
        <input id="globalGainInput" type="number" value="0" min="-30" max="30">
      </div>
      <div class="slider-row" title="EQ Presets">
        <label class="h2" for="eqPresets">Presets</label>
        <select id="eqPresets">
          <option value="Flat">Flat</option>
          <option value="Bass boost">Bass boost</option>
          <option value="Lowpass">Lowpass</option>
          <option value="Mid boost">Mid boost</option>
          <option value="Midpass">Midpass</option>
          <option value="High boost">High boost</option>
          <option value="Highpass">Highpass</option>
          <option value="Custom">Custom</option>
        </select>
      </div>
      <canvas id="eqCanvas" width="300" height="440" style="border:1px solid #ccc; display:block; margin-top:10px;"></canvas>
    </div>
  </aside>

  <main class="main-area">
    <!-- paste your canvas wrapper here -->
    <div id="canvasWrapper" style="position:absolute; width:100%;">
      <canvas id="timeline" style="height:40px; background:#222; position: absolute;left:40px;z-index: 9998; top:0px"></canvas>
      <canvas id="canvas" style="cursor:crosshair; position: absolute; left: 40px; top:40px"></canvas>
      <canvas id="overlay" style="background: transparent; position:absolute; left:40px; pointer-events:none; z-index:10;; top:40px"></canvas>
      <canvas id="freq" style="width:40px; background:#222; position:absolute; left:0; ; top:40px"></canvas>
      <canvas id="logscale" width=40 height = 40 style="position:absolute; top:0px; background: #111;z-index: 999; top:0px"></canvas>
    </div>
  </main>
</div>

<div id="status" style="position:absolute;bottom:0px;"></div>
<script>
  function syncNumberAndRange(numberInput, rangeInput) {

    numberInput.addEventListener('input', () => {
      let val = parseInt(numberInput.value);
      if (val < rangeInput.min) val = rangeInput.min;
      if (val > rangeInput.max) val = rangeInput.max;
      rangeInput.value = val;
      numberInput.value = val; 
    });

    rangeInput.addEventListener('input', () => {
      numberInput.value = rangeInput.value;
    });
  }

  const sliders = [[document.getElementById('emptyAudioLength'), document.getElementById('emptyAudioLengthInput')],
                   [document.getElementById('brushSize'), document.getElementById('brushSizeInput')],
                   [document.getElementById('brushColor'), document.getElementById('brushColorInput')],
                   [document.getElementById('penPhase'), document.getElementById('penPhaseInput')],
                   [document.getElementById('brushOpacity'), document.getElementById('brushOpacityInput')],
                   [document.getElementById('phaseOpacity'), document.getElementById('phaseOpacityInput')],
                   [document.getElementById('npo'), document.getElementById('npoInput')],
                   [document.getElementById('noiseFloorCutoff'), document.getElementById('noiseFloorCutoffInput'), true],
                   [document.getElementById('bpm'), document.getElementById('bpmInput')],
                   [document.getElementById('a4Pitch'), document.getElementById('a4PitchInput'), true],
                   [document.getElementById('durationCutoff'), document.getElementById('durationCutoffInput'), true],
                   [document.getElementById('globalGain'), document.getElementById('globalGainInput'), true]];
  sliders.forEach(pair => {if (!pair[2]) syncNumberAndRange(pair[1], pair[0])});
</script>
<script src="fft.js"></script>
<script>

const fileEl=document.getElementById("file");
const canvas=document.getElementById("canvas");
const ctx=canvas.getContext("2d");
const overlayCanvas = document.getElementById("overlay");
const overlayCtx = overlayCanvas.getContext("2d");
const status=document.getElementById("status");
const fftSizeEl=document.getElementById("fftSize");
const hopSizeEl=document.getElementById("hopSize");
const brushSizeEl=document.getElementById("brushSize");
const brushOpacityEl=document.getElementById("brushOpacity");
const phaseOpacityEl=document.getElementById("phaseOpacity");
const brushColorEl=document.getElementById("brushColor");
const penPhaseEl=document.getElementById("penPhase");
const logscaleEl = document.getElementById("logscale");
const emptyAudioLengthEl = document.getElementById("emptyAudioLength");
const phaseTypeEl = document.getElementById("phaseType");
const recordBtn = document.getElementById("rec");
const preset = document.getElementById("presets");
const es = document.getElementById("es");
const ev = document.getElementById("ev");
const yAxis=document.getElementById("freq");
const yctx=yAxis.getContext("2d");
const yAxisMode=document.getElementById("yAxisMode");
const info = document.getElementById("mouseInfo");
const alignPitchBtn = document.getElementById("alignPitch");
const a4PitchDiv = document.getElementById("a4PitchDiv");
const alignTimeBtn = document.getElementById("alignTime");
const bpmDiv = document.getElementById("bpmDiv");
const WORKLET_CODE = `
class RecorderProcessor extends AudioWorkletProcessor {
  process(inputs) {
    const input = inputs[0];
    if (input && input[0] && input[0].length > 0) {
      const chunk = new Float32Array(input[0].length);
      chunk.set(input[0]);

      this.port.postMessage(chunk, [chunk.buffer]);
    }
    return true;
  }
}
registerProcessor('recorder-processor', RecorderProcessor);
`;
const micHTML = `
<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="2 5 19 19" fill="none" stroke="#333" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
  <path d="M8 15a4 4 0 0 0 8 0" />
  <rect x="10" y="7" width="4" height="8" rx="2" ry="2" fill="black"/>
  <line x1="12" y1="18" x2="12" y2="17"/>
  <line x1="9" y1="21" x2="15" y2="21"/>
</svg>`;
const recHTML = `
<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="red">
  <circle cx="12" cy="12" r="8" />
</svg>`;
const toolButtons = document.querySelectorAll(".tool-btn");
const panelButtons = document.querySelectorAll(".panel-btn");
const trueScale = document.getElementById("trueScale");
const overlayFile = document.getElementById("overlayFile");
const uvcb = document.getElementById("useVolumeControllers");
const d1 = document.getElementById("d1");
const d2 = document.getElementById("d2");
const d3 = document.getElementById("d3");
const EQcanvas = document.getElementById("eqCanvas");
const eCtx = EQcanvas.getContext("2d"); 
const eqPresets = document.getElementById("eqPresets");

const historyStack = []; const redoStack = [];
const MAX_HISTORY_ENTRIES = 80;

let pcm=null, sampleRate=48000, pos=0, fftSize=1024, hop=512, win=hann(1024);
let framesTotal=0, x=0, rendering=false;
let imageBuffer=null;
let visited = null;
let currentCursorX = 0;
let iLow = null;
let iHigh = null;
let fLow = null;
let fHigh = null;
let specCanvas = document.createElement("canvas");
let specCtx = specCanvas.getContext("2d");
let logScaleVal = 1.12;

let mags = null;     
let phases = null;   
let specWidth = 0;
let specHeight = 0;
let pcmChunks = null;
let trueScaleVal=false;
let overlayImage = null;
let useHz = false;
let autoPlayOnFinish = true;
let alignPitch=false;let alignTime=false;
let subBeat = 1;
let useVolumeControllers = false;

let startX = null, startY = null;
let cx_ = null, cy_ = null;

let brushSize=parseInt(brushSizeEl.value);
let brushOpacity=parseInt(brushOpacityEl.value)/100;
let phaseOpacity=parseInt(phaseOpacityEl.value)/100;
let brushColor=parseInt(brushColorEl.value); 
let penPhase=parseInt(penPhaseEl.value)/10000;
let currentTool = "brush";
let currentPanel = "0";
let bpm = 120; let npo = 12;
let noiseFloor = document.getElementById("noiseFloorCutoff").value; let a4p = 440;
let dCutoff = document.getElementById("durationCutoff").value;
let globalGain = 0;
let playingTutorial = false;
let currentFrame = 0;
sliders[1][0].addEventListener("input", ()=>{brushSize   =parseInt  (sliders[1][0].value); updateBrushPreview();});
sliders[1][1].addEventListener("input", ()=>{brushSize   =parseInt  (sliders[1][1].value); updateBrushPreview();});
sliders[2][0].addEventListener("input", ()=>{brushColor  =parseInt  (sliders[2][0].value); updateBrushPreview();});
sliders[2][1].addEventListener("input", ()=>{brushColor  =parseInt  (sliders[2][1].value); updateBrushPreview();});
sliders[3][0].addEventListener("input", ()=>{penPhase    =parseFloat(sliders[3][0].value); updateBrushPreview();});
sliders[3][1].addEventListener("input", ()=>{penPhase    =parseFloat(sliders[3][1].value); updateBrushPreview();});
sliders[4][0].addEventListener("input", ()=>{brushOpacity=parseInt  (sliders[4][0].value)/100; updateBrushPreview();});
sliders[4][1].addEventListener("input", ()=>{brushOpacity=parseInt  (sliders[4][1].value)/100; updateBrushPreview();});
sliders[5][0].addEventListener("input", ()=>{phaseOpacity=parseInt  (sliders[5][0].value)/100; updateBrushPreview();});
sliders[5][1].addEventListener("input", ()=>{phaseOpacity=parseInt  (sliders[5][1].value)/100; updateBrushPreview();});
sliders[6][0].addEventListener("input", ()=>{npo         =parseInt  (sliders[6][0].value);});
sliders[6][1].addEventListener("input", ()=>{if (!isNaN(sliders[6][1].value)) npo=parseInt  (sliders[6][1].value);});
sliders[7][0].addEventListener('input', () =>{noiseFloor=parseFloat(sliders[7][0].value); sliders[7][1].value = noiseFloor;});
sliders[7][1].addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    let val = parseFloat(sliders[7][1].value);
    const min = parseFloat(sliders[7][0].min);
    const max = parseFloat(sliders[7][0].max);
    if (isNaN(val)) val = noiseFloor;      
    if (val < min) val = min;
    if (val > max) val = max;
    sliders[7][1].value = val;      
    sliders[7][0].value = val;      
    noiseFloor = val;
  }
});
sliders[8][0].addEventListener("input", ()=>{bpm         =parseFloat(sliders[8][0].value);drawCursor(true);});
sliders[8][1].addEventListener("input", ()=>{bpm         =parseFloat(sliders[8][1].value);drawCursor(true);});
sliders[9][0].addEventListener('input', () => {a4p = parseFloat(sliders[9][0].value); sliders[9][1].value = a4p;});
sliders[9][1].addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    let val = parseFloat(sliders[9][1].value);
    const min = parseFloat(sliders[9][0].min);
    const max = parseFloat(sliders[9][0].max);
    if (isNaN(val)) val = a4p;      
    if (val < min) val = min;
    if (val > max) val = max;
    sliders[9][1].value = val;      
    sliders[9][0].value = val;      
    a4p = val;
  }
});
sliders[10][0].addEventListener('input', () => {dCutoff = parseFloat(sliders[10][0].value); sliders[10][1].value = dCutoff;});
sliders[10][1].addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    let val = parseFloat(sliders[10][1].value);
    const min = parseFloat(sliders[10][0].min);
    const max = parseFloat(sliders[10][0].max);
    if (isNaN(val)) val = dCutoff;      
    if (val < min) val = min;
    if (val > max) val = max;
    sliders[10][1].value = val;      
    sliders[10][0].value = val;      
    dCutoff = val;
  }
});
sliders[11][0].addEventListener('input', () => {globalGain = parseFloat(sliders[11][0].value); sliders[11][1].value = globalGain; updateEQ();});
sliders[11][1].addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    let val = parseFloat(sliders[11][1].value);
    const min = parseFloat(sliders[11][0].min);
    const max = parseFloat(sliders[11][0].max);
    if (isNaN(val)) val = globalGain;      
    if (val < min) val = min;
    if (val > max) val = max;
    sliders[11][1].value = val;      
    sliders[11][0].value = val;      
    globalGain = val;
    updateEQ();
  }
});
recordBtn.innerHTML = micHTML;

function angleDiff(a, b) {
  const d = a - b;
  return Math.atan2(Math.sin(d), Math.cos(d));
}
function pushHistory(entry, clearRedo = true) {
  while (historyStack.length >= MAX_HISTORY_ENTRIES) historyStack.shift();
  historyStack.push(entry);
  if (clearRedo) redoStack.length = 0;
}

panelButtons.forEach(btn => {
  if(btn.dataset.tool === currentPanel) {
    btn.style.background = "#4af"; 
  }
});
panelButtons.forEach(btn => {
  btn.addEventListener("click", () => {
    currentPanel = btn.dataset.tool;
    panelButtons.forEach(b => b.style.background = "");
    btn.style.background = "#4af";
    if (currentPanel === "0") {
      d1.style.display = "block";
      d2.style.display = "none";
      d3.style.display = "none";
    } else if (currentPanel === "1") {
      d1.style.display = "none";
      d2.style.display = "block";
      d3.style.display = "none";
    } else {
      d1.style.display = "none";
      d2.style.display = "none";
      d3.style.display = "block";
      drawEQ();
    }
  });
});
toolButtons.forEach(btn => {
  if(btn.dataset.tool === currentTool) {
    btn.style.background = "#4af"; 
  }
});
toolButtons.forEach(btn => {
  btn.addEventListener("click", () => {
    currentTool = btn.dataset.tool;
    toolButtons.forEach(b => b.style.background = "");
    btn.style.background = "#4af"; 
    if(currentTool === "image") overlayFile.click();
    updateBrushPreview();
  });
});
fileB.addEventListener("click", () => {
  file.click();
});
trueScale.addEventListener("click", () =>  {trueScaleVal = !trueScaleVal; trueScale.style.background = trueScaleVal?"#4af":"var(--accent-gradient)"; restartRender(false);});
yAxisMode.addEventListener("click", () =>  {useHz        = !useHz;        yAxisMode.style.background = useHz       ?"#4af":"var(--accent-gradient)"; drawYAxis();});
uvcb.addEventListener("click",()=>{useVolumeControllers=!useVolumeControllers;uvcb.style.background = useVolumeControllers?"#4af":"var(--accent-gradient)";});
alignPitchBtn.addEventListener("click",()=>{alignPitch=!alignPitch;alignPitchBtn.style.background = alignPitch?"#4af":"var(--accent-gradient)"; a4PitchDiv.style.display=alignPitch?"block":"none";});
alignTimeBtn.addEventListener("click",()=>{alignTime=!alignTime;alignTimeBtn.style.background = alignTime?"#4af":"var(--accent-gradient)"; bpmDiv.style.display=alignTime?"block":"none";drawCursor(true);});
overlayFile.addEventListener("change", e => {
  const f = e.target.files[0];
  if (!f) return;
  const img = new Image();
  img.onload = () => {overlayImage = img; updateBrushPreview();}
  img.src = URL.createObjectURL(f);
});

function keyBind(event) {
  if (event.target.tagName === 'INPUT' || event.target.tagName === 'SELECT' || event.target.tagName === 'TEXTAREA') {
    return; 
  }
  const key = event.key.toLowerCase();
  if (key === 'b') {
    document.getElementById("brushBtn").click();
  } else if (key === 'e') {
    document.getElementById("eraserBtn").click();
  } else if (key === 'p') {
    document.getElementById("pianoBtn").click();
  } else if (key === 'g') {
    document.getElementById("settingsBtn").click();
  } else if (key === 'q') {
    document.getElementById("eqBtn").click();
  } else if (key === 'r') {
    document.getElementById("rectBtn").click();
  } else if (key === 'a') {
    document.getElementById("amplifierBtn").click();
  } else if (key === 'u') {
    document.getElementById("blurBtn").click();
  } else if (key === 'i' && !event.shiftKey && !event.ctrlKey && !event.metaKey) {
    document.getElementById("imageBtn").click();
  } else if (key === 'l') {
    document.getElementById("lineBtn").click();
  } else if ((event.ctrlKey || event.metaKey) && key === 'o') {
    event.preventDefault();
    fileEl.click();
  } else if ((event.ctrlKey || event.metaKey) && event.shiftKey && key === 's') {
    event.preventDefault();
    document.getElementById('downloadButton').click();
  } else if ((event.ctrlKey || event.metaKey) && key === 's') {
    event.preventDefault();
    document.getElementById('downloadWav').click();
  } else if ((event.ctrlKey || event.metaKey) && key === 'm') {
    exportMidi();
  } else if ((event.ctrlKey || event.metaKey) && key === ' ') {
    recordBtn.click();
  } else if (key === 'y' && !event.shiftKey && !event.ctrlKey && !event.metaKey) {
    yAxisMode.click();
  } else if (key === 'j') {
    alignPitchBtn.click();
  } else if (key === 'k') {
    alignTimeBtn.click();
  }
}
document.addEventListener("keydown", (e) => {
  const active = document.activeElement;
  if (active && active.matches("input[type=range], button")) {

    if (["ArrowLeft","ArrowRight","ArrowUp","ArrowDown","Tab"].includes(e.key)) {
      return; 
    }

    active.blur();
    setTimeout(() => {
      const evt = new KeyboardEvent('keydown', {
        key: e.key,
        code: e.code,
        keyCode: e.keyCode,
        bubbles: true,
        cancelable: true,
        ctrlKey: e.ctrlKey,
        shiftKey: e.shiftKey,
        altKey: e.altKey,
        metaKey: e.metaKey
      });
      document.dispatchEvent(evt);
    }, 0);

    e.preventDefault();
    e.stopPropagation();
  }
});
document.addEventListener('keydown', (event) => {
  keyBind(event);
});

</script>
<script src="axes.js"></script>
<script src="midi.js"></script>
<script>

function initEmptyPCM() {
    const sampleRateLocal = 48000;
    const duration = emptyAudioLengthEl.value; 
    const type = phaseTypeEl.value;
    const length = sampleRateLocal * duration; 
    const tinyNoiseAmplitude = 0.0001; 

    const pcmArray = new Float32Array(length);
    for (let i = 0; i < length; i++) {
      if (type === "Harmonics") {
        let sum = 0;
        const interval = 128;
        for (let j = 1; j <= interval; j++) {
          sum+=Math.sin(i*((Math.PI*j*(1024/interval))/1024))/interval;
        }
        // console.log(sum);
        pcmArray[i] = sum * tinyNoiseAmplitude;
      }
      else if (type === "Fast sine") pcmArray[i] = Math.sin(i / 1000) * tinyNoiseAmplitude;
      else if (type === "Static") pcmArray[i] = (Math.random() * 2 - 1) * tinyNoiseAmplitude;
      else if (type === "Empty")  pcmArray[i] = 0;
    }

    pcm = pcmArray;
    sampleRate = sampleRateLocal;

    iLow = null;
    restartRender(false);
}
function drawLogScale() {
  const lctx = logscaleEl.getContext("2d");

  const w = 40, h = 40;
  lctx.clearRect(0, 0, w, h);

  lctx.beginPath();
  const steps = 40;
  for (let i = 0; i <= steps; i++) {
    const x = i / steps;              
    const y = 1-Math.pow(0-(x-1), Math.pow(logScaleVal,2)); 
    const px = x * w;                 
    const py = h - y * h;             
    if (i === 0) lctx.moveTo(px, py);
    else lctx.lineTo(px, py);
  }
  lctx.strokeStyle = "white";
  lctx.lineWidth = 3;
  lctx.stroke();
}
let changingLogScale = false;
function getMouseXY(e,touch) {
  if (touch) {
    return [e.touches[0].clientX, e.touches[0].clientY];
  } else {
    return [e.clientX, e.clientY];
  }
}
logscaleEl.addEventListener("mousedown", e=> {
  logScaleMouseDown(e,false);
});
logscaleEl.addEventListener("touchstart", e=> {
  logScaleMouseDown(e.true);
});
function logScaleMouseDown(e,touch) {
  if (e.button !== 0) return;
  const rect= logscaleEl.getBoundingClientRect();
  changingLogScale = true;
  [startX, startY] = getMouseXY(e,touch);
  renderFullSpectrogramToImage();
  drawLogScale();
}
logscaleEl.addEventListener("mousedown", e=> {
  logScaleMouseDown(e,false);
});
logscaleEl.addEventListener("touchstart", e=> {
  logScaleMouseDown(e,true);
});

function logScaleMouseMove(e,touch) {
  logscaleEl.style.cursor = "n-resize";
  if (!changingLogScale) return;
  const rect= logscaleEl.getBoundingClientRect();
  logScaleVal -= (getMouseXY(e,touch)[1] - startY - (getMouseXY(e,touch)[0] - startX))/400;
  if (logScaleVal < 1) logScaleVal = 1;
  if (logScaleVal > 2) logScaleVal = 2;
  [startX, startY] = getMouseXY(e,touch);
  renderFullSpectrogramToImage();
  drawLogScale();
  drawYAxis();
}

document.addEventListener("mousemove", e=> {
  logScaleMouseMove(e,false);
});
document.addEventListener("touchmove", e=> {
  logScaleMouseMove(e,true);
});

logscaleEl.addEventListener("mousemove", e=> {
  logscaleEl.title = "Log scale: " + logScaleVal;
});

document.addEventListener("mouseup", e=>{changingLogScale=false;})
document.addEventListener("touchend", e=>{changingLogScale=false;})

emptyAudioLengthEl.addEventListener("input", ()=> {
  initEmptyPCM();

  if (typeof drawTimeline === 'function') drawTimeline();
  else console.warn("drawTimeline not available yet");

  if (typeof drawLogScale === 'function') drawLogScale();
  else console.warn("drawLogScale not available yet");

  if (typeof drawYAxis === 'function') drawYAxis();
  else console.warn("drawYAxis not available yet");

  iLow = 0;
  iHigh = framesTotal;
});
phaseTypeEl.addEventListener("input", ()=> {
  initEmptyPCM();
});

</script>
<script src="recordingAndPresets.js"></script>
<script>
fftSizeEl.addEventListener("change",restartRender);
hopSizeEl.addEventListener("change",restartRender);

function restartRender(autoPlay){
    if(!pcm) return;
    autoPlayOnFinish = !!playing || !!autoPlay;
    const exponent = Math.max(6, Math.min(14, parseInt(fftSizeEl.value)||10));
    fftSize = 1 << exponent;
    hop = Math.max(1, parseInt(hopSizeEl.value) || Math.floor(fftSize/2));
    win = hann(fftSize);

    framesTotal = Math.max(1, Math.floor((pcm.length - fftSize) / hop) + 1);
    if (iLow == null || iHigh > framesTotal) {
      iLow = 0;
      iHigh = framesTotal;
    }

    const freqBins = Math.floor(fftSize / 2);
    canvas.width = framesTotal;
    canvas.height = freqBins;
    if (trueScaleVal) {
      const maxHeight = 600;
      const containerWidth = canvas.parentElement.clientWidth;
      const scaleX = containerWidth / framesTotal;
      const scaleY = maxHeight / freqBins;
      const scale = Math.min(scaleX, scaleY, 1);

      canvas.style.width = (canvas.width * scale) + "px";
      canvas.style.height = (canvas.height * scale) + "px";
    } else {
      canvas.style.width = "calc(100% - 40px)";
      let h = window.innerHeight - 110;
      canvas.style.height = h+"px";
    }

    overlayCanvas.style.width = canvas.style.width;
    overlayCanvas.style.height = canvas.style.height;
    yAxis.height = 1024;
    yAxis.style.height = canvas.style.height;
    yAxis.width = 40;
    yAxis.style.height = canvas.style.height;

    specWidth = canvas.width;
    specHeight = canvas.height;

    syncOverlaySize();

    const timeline = document.getElementById('timeline');
    timeline.width = window.innerWidth*1.2;
    timeline.style.width = canvas.style.width;
    timeline.height = 40;

    imageBuffer = new ImageData(canvas.width, canvas.height);
    specWidth = canvas.width;
    specHeight = canvas.height;

    specCanvas.width = specWidth;
    specCanvas.height = specHeight;
    specCtx.clearRect(0, 0, specCanvas.width, specCanvas.height);
    specCtx.putImageData(imageBuffer, 0, 0);

    mags = new Float32Array(specWidth * specHeight);
    phases = new Float32Array(specWidth * specHeight);
    for(let i=0;i<specWidth*specHeight;i++){ mags[i]=0; phases[i]=0; }

    const startFrame = Math.max(0, Math.floor(iLow || 0));
    pos = startFrame * hop;
    x = startFrame;
    rendering = true;

    ctx.fillStyle = "black";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    startTime = performance.now();
    audioProcessed = 0;

    if (playing) stopSource(true);
    requestAnimationFrame(drawLoop);

    if (!autoPlay) {
        if (typeof drawTimeline === 'function') drawTimeline();
        else console.warn("drawTimeline() not defined yet — will run once axes.js loads");

        if (typeof drawYAxis === 'function') drawYAxis();
        else console.warn("drawYAxis() not defined yet — will run once axes.js loads");

        if (typeof drawLogScale === 'function') drawLogScale();
    }
}

function magPhaseToRGB(mag, phase){
    const h = (phase / (2*Math.PI) + 1) % 1; 
    const s = 1;
    const v = Math.min(mag/60,1);
    const c = v*s;
    const m = v - c;
    const hp = h*6;
    const x = c*(1-Math.abs(hp%2-1));
    let r=0,g=0,b=0;
    if(hp < 1){ r=c; g=x; b=0; }
    else if(hp < 2){ r=x; g=c; b=0; }
    else if(hp < 3){ r=0; g=c; b=x; }
    else if(hp < 4){ r=0; g=x; b=c; }
    else if(hp < 5){ r=x; g=0; b=c; }
    else { r=c; g=0; b=x; }
    return [Math.floor((r+m)*255), Math.floor((g+m)*255), Math.floor((b+m)*255)];
}

function rgbToMagPhase(r, g, b) {
    let rf=r/255,gf=g/255,bf=b/255;
    const mx=Math.max(rf,gf,bf), mn=Math.min(rf,gf,bf);
    const d=mx-mn;
    let h=0,s=0,v=mx;
    s=mx===0?0:d/mx;
    if(d!==0){
        if(mx===rf) h=((gf-bf)/d)%6;
        else if(mx===gf) h=(bf-rf)/d+2;
        else h=(rf-gf)/d+4;
        h/=6; if(h<0) h+=1;
    }
    const phase=h*2*Math.PI;
    const mag=v*60;
    return [mag, phase];
}

function getLogScaleSlider() { return Math.max(1, parseFloat(logScaleVal) || 1); }

function binToDisplayY(bin, h) {
    if (!h) return 0;
    const s = getLogScaleSlider();
    if (s <= 1.0000001) {
        return Math.round(h - 1 - bin); 
    } else {
        const a = s - 1;
        const denom = Math.log(1 + a * (h - 1));
        if (!isFinite(denom) || denom === 0) return Math.round(h - 1 - bin);
        const t = Math.log(1 + a * bin) / denom; 
        const y = (1 - t) * (h - 1);
        return Math.round(y);
    }
}

function displayYToBin(y, h) {
    if (!h) return 0;
    const s = getLogScaleSlider();
    if (s <= 1.0000001) {
        return Math.max(0, Math.min(h - 1, Math.round(h - 1 - y)));
    } else {
        const a = s - 1;
        const denom = Math.log(1 + a * (h - 1));
        if (!isFinite(denom) || denom === 0) return Math.max(0, Math.min(h - 1, Math.round(h - 1 - y)));
        const t = 1 - (y / (h - 1));
        const raw = (Math.exp(t * denom) - 1) / a;
        const clamped = Math.max(0, Math.min(h - 1, Math.round(raw)));
        return clamped;
    }
}

function drawFrame(w,h) {
    if (pos + fftSize > pcm.length) { rendering = false; status.style.display = "none"; return false; }

    const re = new Float32Array(fftSize);
    const im = new Float32Array(fftSize);
    for (let i = 0; i < fftSize; i++) { re[i] = (pcm[pos + i] || 0) * win[i]; im[i] = 0; }
    fft_inplace(re, im);

    for (let bin = 0; bin < h; bin++) {
        const mag = Math.hypot(re[bin] || 0, im[bin] || 0);
        const phase = Math.atan2(im[bin] || 0, re[bin] || 0);
        const idx = x * h + bin; 
        mags[idx] = mag;
        phases[idx] = phase;
    }

    for (let yy = 0; yy < h; yy++) {
        const mappedBin = displayYToBin(yy, h);
        const idx = x * h + mappedBin;
        const mag = mags[idx] || 0;
        const phase = phases[idx] || 0;
        const [r, g, b] = magPhaseToRGB(mag, phase);
        const pix = (yy * w + x) * 4; 
        imageBuffer.data[pix]     = r;
        imageBuffer.data[pix + 1] = g;
        imageBuffer.data[pix + 2] = b;
        imageBuffer.data[pix + 3] = 255;
    }
    pos += hop; x++;
    audioProcessed += hop;
    if (x >= w) {

      rendering = false;

      if (pendingHistory && snapshotMags && snapshotPhases && mags && phases) {
        pendingHistory = false; 

        newHistory();

        const lastEntry = historyStack.length ? historyStack[historyStack.length - 1] : null;
        if (!pendingRecomputeDone) {
          if (lastEntry) {
            recomputePCMForCols(lastEntry.minCol, lastEntry.maxCol, { oldMags: snapshotMags, oldPhases: snapshotPhases });
          }
        } else {

          pendingRecomputeDone = false;
          pendingRecomputeMinCol = pendingRecomputeMaxCol = null;
        }

        snapshotMags = null;
        snapshotPhases = null;
      }
      if (pendingPlayAfterRender) {
        pendingPlayAfterRender = false;
        try {
          playPCM(false,currentFrame); 
        } catch (e) { console.warn("playPCM() failed after render:", e); }
        const playPauseEl = document.getElementById("playPause");
        if (playPauseEl) playPauseEl.innerHTML = pauseHtml;
      }

      if (!painting && autoPlayOnFinish) {
          autoPlayOnFinish = false;
          playPCM(true,currentFrame);
      }
      status.style.display = "none";
      return false;
    }
    return true;
}

let requestSpecUpdate = false;      
let resolveSpecUpdate = null;       
const SPEC_UPDATE_TIMEOUT_MS = 2000; 

let pendingHistory = false;
let pendingPlayAfterRender = false;

let pendingRecomputeDone = false;
let pendingRecomputeMinCol = null;
let pendingRecomputeMaxCol = null;

function waitForSpecUpdate(timeout = SPEC_UPDATE_TIMEOUT_MS) {

  if (!rendering && !requestSpecUpdate) return Promise.resolve(true);

  return new Promise((resolve) => {

    resolveSpecUpdate = (ok = true) => {

      if (!resolveSpecUpdate) return;
      const r = resolve;
      resolveSpecUpdate = null;
      requestSpecUpdate = false;
      r(ok);
    };

    setTimeout(() => {
      if (resolveSpecUpdate) {
        resolveSpecUpdate(false); 
      }
    }, timeout);
  });
}

function drawLoop() {
    if (!rendering) return;

    const framesPerTick = Math.min(200, Math.max(4, Math.floor(specWidth/8)));

    const h = specHeight;
    const w = specWidth;

    for (let f = 0; f < framesPerTick; f++) {
        if (!drawFrame(w,h)) break;
    }

    specCtx.putImageData(imageBuffer, 0, 0);
    renderView();
    drawCursor(true);

    if (requestSpecUpdate && typeof resolveSpecUpdate === 'function') {

      resolveSpecUpdate(true);

    }

    const elapsedMS = performance.now() - startTime;
    const elapsedSec = elapsedMS / 1000;
    const speed = audioProcessed / Math.max(1e-6, elapsedSec); 
    const audioSec = pcm.length / sampleRate; 
    const processedSec = audioProcessed / sampleRate;
    status.textContent = `Progress: ${(100*pos/pcm.length).toFixed(1)}% | ` 
        + `Elapsed: ${elapsedSec.toFixed(2)}s | `
        + `Audio processed: ${processedSec.toFixed(2)}/${audioSec.toFixed(2)}s | `
        + `Speed: ${(speed/sampleRate).toFixed(2)}x realtime`;
    if (rendering) {
      status.style.display = "block";
      requestAnimationFrame(() => drawLoop());
    }
}

function drawCursor(clear){
    const x = (currentCursorX-iLow) * canvas.width / (iHigh-iLow);
    if (clear) overlayCtx.clearRect(0,0, canvas.width, canvas.height);
    overlayCtx.strokeStyle = "#0f0";
    overlayCtx.lineWidth = iWidth/500;
    overlayCtx.beginPath();
    overlayCtx.moveTo(x + 0.5, 0);
    overlayCtx.lineTo(x + 0.5, specHeight);
    overlayCtx.stroke();
    if (alignTime) {
      overlayCtx.strokeStyle = "#222";
      for (let i = 0; i < specWidth; i += (sampleRate/fftSize)/subBeat * (120/bpm)) {
        const x = (i-iLow)* canvas.width / (iHigh-iLow);
        overlayCtx.beginPath();
        overlayCtx.moveTo(x,0);
        overlayCtx.lineTo(x,specHeight);
        overlayCtx.stroke();
      }
    }
}

function updateCanvasScroll() {
    if (!imageBuffer || !specCanvas) return;

    const viewWidth = Math.max(1, Math.floor(iHigh - iLow));
    const fStart = Math.max(0, Math.floor(specHeight * (1 - fHigh / (sampleRate/2))));
    const fEnd = Math.min(specHeight, Math.floor(specHeight * (1 - fLow / (sampleRate/2))));
    const viewHeight = Math.max(1, fEnd - fStart);

    canvas.width = viewWidth;
    canvas.height = viewHeight;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(
        specCanvas,
        Math.max(0, Math.floor(iLow)), fStart, 
        viewWidth, viewHeight,                 
        0, 0,                                  
        canvas.width, canvas.height            
    );

    overlayCanvas.width = canvas.width;
    overlayCanvas.height = canvas.height;
    overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

    drawCursor(true);
}

function renderView() {
    if (!specCanvas || !imageBuffer) return;

    const viewWidth = Math.max(1, Math.floor(iHigh - iLow));
    const fStart = Math.max(0, Math.floor(specHeight * (1 - fHigh / (sampleRate/2))));
    const fEnd = Math.min(specHeight, Math.floor(specHeight * (1 - fLow / (sampleRate/2))));
    const viewHeight = Math.max(1, fEnd - fStart);

    canvas.width = viewWidth;
    canvas.height = viewHeight;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(
        specCanvas,
        Math.max(0, Math.floor(iLow)), fStart, 
        viewWidth, viewHeight,                 
        0, 0,                                  
        canvas.width, canvas.height            
    );

    overlayCanvas.width = canvas.width;
    overlayCanvas.height = canvas.height;
    overlayCanvas.style.width = canvas.style.width;
    overlayCanvas.style.height = canvas.style.height;
}

let painting=false;
let paintedPixels=null;

function getCanvasCoords(e,touch){
    const rect=canvas.getBoundingClientRect();
    const scaleX=canvas.width/rect.width;
    const scaleY=canvas.height/rect.height;
    let x; let y;
    if (touch && e.touches.length === 0) {
        x = _cx; y = _cy;
    } else {
        x = touch ? e.touches[0].clientX : e.clientX;
        y = touch ? e.touches[0].clientY : e.clientY;
        _cx = x; _cy = y;
    }
    return {cx:(x-rect.left)*scaleX, cy:(y-rect.top)*scaleY, scaleX, scaleY};
}

</script>
<script src="drawTools.js"></script>
<script>

function hzToNoteName(frequency) {
  if (frequency <= 0) return "0";
  const A4 = 440;
  const A4_MIDI = 69;
  const midi = Math.round(12 * Math.log2(frequency / A4) + A4_MIDI);
  const noteNames = ["C", "C#", "D", "D#", "E", "F", 
                     "F#", "G", "G#", "A", "A#", "B"];
  const note = noteNames[(midi+1200) % 12];
  const octave = Math.floor(midi / 12) - 1;
  const ret = `${note}${octave}`;
  return ret;
}
let sineOsc = null;
let sineGain = null;
function getSineFreq(cy) {
    const h = specHeight;
    const s = parseFloat(logScaleVal); 
    let bin;
    if (s <= 1.0000001) {
        bin = h - 1 - cy;
    } else {
        const a = s - 1;
        const denom = Math.log(1 + a * (h - 1));
        const t = 1 - cy / (h - 1);
        bin = (Math.exp(t * denom) - 1) / a;
    }
    bin = Math.max(0, Math.min(h - 1, bin));
    return bin * sampleRate / fftSize;
}
function setSineFreq(cy) {
    sineOsc.frequency.setTargetAtTime(getSineFreq(cy), audioCtx.currentTime, 0.01);
}
function visibleToSpecY(visY) {
    const fStart = Math.max(0, Math.floor(specHeight * (1 - fHigh / (sampleRate/2))));
    const fullY = Math.round(visY + fStart);
    return Math.max(0, Math.min(specHeight - 1, fullY));
}
let snapshotMags = null;
let snapshotPhases = null;

function cxToFrame(cx) {
  return Math.floor((cx/canvas.width*(iWidth/specWidth)+iLow)*specWidth);
}

function frameToCx(frame) {
  return ((frame-iLow)/(iWidth/specWidth)*1);
}

let sx2 = 0, sy2 = 0;

function canvasMouseDown(e,touch) {
    if (!mags || !phases) return;
    if (!touch && e.button !== 0) return;
    if (pendingHistory) return; 

    painting = true;

    snapshotMags = new Float32Array(mags);
    snapshotPhases = new Float32Array(phases);

    visited = new Uint8Array(mags.length);
    stopSource();
    paintedPixels = new Set();
    const {cx,cy,scaleX,scaleY} = getCanvasCoords(e,touch);
    startX = cx; startY = cy;
    if (alignTime) {
      const snapSize = 30/bpm/subBeat;
      const startTime = Math.floor((cx/(sampleRate/hopSizeEl.value))/snapSize)*snapSize;
      const startFrame0 = Math.round((startTime*(sampleRate/hopSizeEl.value)) + iLow);
      sx2 = cx; sy2 = cy;
      startX = startFrame0 - iLow;
    }
    overlayCtx.clearRect(0,0,overlayCanvas.width, overlayCanvas.height);
    const realY = visibleToSpecY(cy);
    if (!(currentTool === "rectangle" || currentTool === "line")) {
        paint(cx + iLow, realY);
    }
    if (document.getElementById("previewWhileDrawing").checked) {
      ensureAudioCtx();
      mouseDown = true;
      currentFrame = Math.floor(cx);
      playFrame(currentFrame);

      if (!sineOsc) {
          sineOsc = audioCtx.createOscillator();
          sineOsc.type = "sine";
          sineGain = audioCtx.createGain();
          sineGain.gain.value = 0.2;
          sineOsc.connect(sineGain).connect(audioCtx.destination);
          setSineFreq(realY); 
          sineOsc.start();
      }
    }
}
canvas.addEventListener("mousedown", e=>{
    canvasMouseDown(e,false);
});
canvas.addEventListener("touchstart", e=>{
    canvasMouseDown(e,true);
});

function canvasMouseMove(e,touch) {
    const {cx,cy,scaleX,scaleY} = getCanvasCoords(e,touch);
    if (!recording) {
      const hz = getSineFreq(visibleToSpecY(cy));
      const secs = Math.floor(cx/(sampleRate/hopSizeEl.value)*10000)/10000;
      const hx = Math.floor(cx);
      const hy = Math.floor(hz/(sampleRate/fftSize));
      const i = hx*specHeight+hy;
      let normalizedMag = Math.min(1, mags[i] / 256);
      let db = (20 * Math.log10(normalizedMag)).toFixed(1);
      info.innerHTML=`Pitch: ${hz.toFixed(0)}hz (${hzToNoteName(hz)}) <br>Time: ${secs}<br>Loudness: ${db} db`
    }
    if (!painting && currentTool === "brush" || currentTool === "eraser" || currentTool === "blur" || currentTool === "amplifier") {
        previewShape(cx, cy);
    }
    if(!painting && currentTool != "image") return;

    if (currentTool === "rectangle" || currentTool === "line" || currentTool === "image") {
        previewShape(cx, cy);
    } else {
        overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
        const realY = visibleToSpecY(cy);
        paint(cx + iLow, realY);
        drawCursor(true);
    }

    currentFrame = Math.floor(cx+iLow);
    if (mouseDown) {
        playFrame(currentFrame);
        if (sineOsc) setSineFreq( visibleToSpecY(cy) ); 
    }

    currentCursorX = currentFrame;
}
canvas.addEventListener("mousemove", e=>{
    canvasMouseMove(e,false);
});
canvas.addEventListener("touchmove", e=>{
    canvasMouseMove(e,true);
});

</script>
<script src="undoredo.js"></script>
<script>
function canvasMouseUp(e,touch) {
    if (!mags || !phases || !painting) return;
    visited = null;
    painting = false;
    paintedPixels = null;
    mouseDown = false;
    stopSource();
    if (sineOsc) {
        sineOsc.stop();
        sineOsc.disconnect();
        sineOsc = null;
        sineGain = null;
    }
    const { cx, cy } = getCanvasCoords(e,touch);
    if (currentTool === "rectangle" || currentTool === "line") {
        commitShape(cx, cy); 
        overlayCtx.clearRect(0,0,overlayCanvas.width,overlayCanvas.height);
    }
    if (alignTime && currentTool === "brush") {
      const startFrame = Math.round(cx + iLow);
      const snapSize = 30/bpm/subBeat;
      const brushS = brushSize*fWidth/sampleRate*fftSize/512;

      let startTime = Math.floor((sx2/(sampleRate/hopSizeEl.value))/snapSize)*snapSize + ((cx<startX) ? snapSize : 0);
      let startFrame0 = Math.round((startTime*(sampleRate/hopSizeEl.value)) + iLow);
      line(startFrame0, sx2, visibleToSpecY(sy2), visibleToSpecY(sy2),brushS);

      startTime = Math.floor((cx/(sampleRate/hopSizeEl.value))/snapSize)*snapSize + ((cx>startX) ? snapSize : 0);
      startFrame0 = Math.round((startTime*(sampleRate/hopSizeEl.value)) + iLow);
      line(startFrame0, cx, visibleToSpecY(cy), visibleToSpecY(cy),brushS);
    }

    startX=startY=null;

    startTime = performance.now();
    audioProcessed = 0;

    if (snapshotMags && snapshotPhases && mags && phases) {

      autoRecomputePCM(-1,-1);

      pendingHistory = true;
      pendingPlayAfterRender = true; 
    } else {

      playPCM(startFrame = currentFrame);
      const playPauseEl = document.getElementById("playPause");
      if (playPauseEl) playPauseEl.innerHTML = pauseHtml;
    }

    const startFrame = Math.max(0, Math.floor(iLow || 0));
    pos = startFrame * hop;
    x = startFrame;
    rendering = true;
    requestAnimationFrame(() => drawLoop());

    startTime = performance.now();
    audioProcessed = 0;

}

function autoRecomputePCM(min,max) {
  const epsMag = 1e-6;
  const epsPhase = 1e-3;
  const h = specHeight;
  const total = mags.length;
  let minCol, maxCol;
  if (min == -1) {
    minCol = Infinity; maxCol = -Infinity;
    for (let idx = 0; idx < total; idx++) {
      const oldM = (snapshotMags) ? snapshotMags[idx] : 0;
      const newM = mags[idx] ?? 0;
      if (Math.abs(oldM - newM) > epsMag) {
        const col = Math.floor(idx / h);
        if (col < minCol) minCol = col;
        if (col > maxCol) maxCol = col;
        continue;
      }
      const oldP = (snapshotPhases) ? snapshotPhases[idx] : 0;
      const newP = phases[idx] || 0;
      if (Math.abs(angleDiff(oldP, newP)) > epsPhase) {
        const col = Math.floor(idx / h);
        if (col < minCol) minCol = col;
        if (col > maxCol) maxCol = col;
      }
    }
  } else {
    minCol = min;
    maxCol = max;
  }

  if (isFinite(minCol)) {

    minCol = Math.max(0, minCol);
    maxCol = Math.min(specWidth - 1, maxCol);

    try {
      recomputePCMForCols(minCol, maxCol, { oldMags: snapshotMags, oldPhases: snapshotPhases });

      pendingRecomputeDone = true;
      pendingRecomputeMinCol = minCol;
      pendingRecomputeMaxCol = maxCol;
    } catch (e) {
      console.warn("Immediate recomputePCMForCols failed, will attempt recompute after render:", e);
      pendingRecomputeDone = false;
      pendingRecomputeMinCol = pendingRecomputeMaxCol = null;
    }
  } else {

    pendingRecomputeDone = false;
    pendingRecomputeMinCol = pendingRecomputeMaxCol = null;
  }
}

function newHistory() {
  const epsMag = 1e-6;         
  const epsPhase = 1e-3;       

  const changedIdxs = [];
  const prevMags = [];
  const prevPhases = [];

  const h = specHeight;
  const total = mags.length; 

  for (let idx = 0; idx < total; idx++) {
    const oldM = snapshotMags[idx] || 0;
    const newM = mags[idx] || 0;
    if (Math.abs(oldM - newM) > epsMag) {
      changedIdxs.push(idx);
      prevMags.push(oldM);
      prevPhases.push(snapshotPhases[idx] || 0);
      continue;
    }

    const oldP = snapshotPhases[idx] || 0;
    const newP = phases[idx] || 0;
    if (Math.abs(angleDiff(oldP, newP)) > epsPhase) {
      changedIdxs.push(idx);
      prevMags.push(oldM);
      prevPhases.push(oldP);
    }
  }

  if (changedIdxs.length > 0) {

    let minCol = Infinity, maxCol = -Infinity;
    for (let k = 0; k < changedIdxs.length; k++) {
      const col = Math.floor(changedIdxs[k] / h);
      if (col < minCol) minCol = col;
      if (col > maxCol) maxCol = col;
    }
    if (!isFinite(minCol)) { minCol = 0; maxCol = 0; }

    const indicesArr = new Uint32Array(changedIdxs);
    const prevMagsArr = new Float32Array(prevMags);
    const prevPhasesArr = new Float32Array(prevPhases);

    pushHistory({
        type: 'paint',
        indices: indicesArr,
        prevMags: prevMagsArr,
        prevPhases: prevPhasesArr,
        minCol: Math.max(0, minCol),
        maxCol: Math.min(specWidth - 1, maxCol),
        maxSize: specWidth,
        hopSize: hopSizeEl.value,
        fftSize: fftSize
    });
  }
}

document.addEventListener("mouseup", e => {
    canvasMouseUp(e,false);
});
document.addEventListener("touchend", e => {
    canvasMouseUp(e,true);
});

let sourceNode = null;
let playing = false;
let mouseDown = false;
let pausedAtSample = null; 
let sourceStartTime = 0; 
let wasPlayingDuringDrag = false;

initEmptyPCM();

function updateCursorLoop() {
    if (playing && !painting && pcm && sourceNode) {
        const elapsed = audioCtx.currentTime - sourceStartTime; 
        let samplePos = elapsed * sampleRate;

        if (sourceNode.loop) {
            samplePos = samplePos % pcm.length; 
        }

        const frame = Math.floor(samplePos / hop);
        currentCursorX = Math.min(frame, specWidth - 1);

        specCtx.putImageData(imageBuffer, 0, 0);
        renderView();
        drawCursor(true);
        drawEQ();
    }
    requestAnimationFrame(updateCursorLoop);
}
updateCursorLoop();

function stopSource(preservePaused=false){
    if(sourceNode){
        try { sourceNode.stop(); } catch(e) {  }
        try { sourceNode.disconnect(); } catch(e) {  }
        sourceNode = null;
    }

    if (!preservePaused) pausedAtSample = null;
    playing = false;
}

function _getPlaybackTarget() {

  if (typeof curveEQ !== 'undefined' && curveEQ && curveEQ.inited && curveEQ.eqInput) {

    if (typeof updateCurveEQ === 'function') {
      try { updateCurveEQ(); } catch (e) {  }
    }
    return curveEQ.eqInput;
  }

  if (typeof eqInput !== 'undefined' && eqInput) return eqInput;

  return audioCtx.destination;
}

async function playPCM(loop = true, startFrame = null) {
  if (!pcm) return;
  ensureAudioCtx();

  if (audioCtx.state === 'suspended') {
    try { await audioCtx.resume(); } catch (e) { console.warn("audioCtx.resume() failed:", e); }
  }

  stopSource(true);

  let startSample = 0;
  if (startFrame !== null && !isNaN(startFrame)) {
      startSample = Math.max(0, Math.min(pcm.length - 1, startFrame * hop));
  } else if (pausedAtSample !== null) {
      startSample = Math.max(0, Math.min(pcm.length - 1, pausedAtSample));
  } else {
      startSample = 0;
  }

  sourceNode = audioCtx.createBufferSource();
  const buffer = audioCtx.createBuffer(1, pcm.length, sampleRate);
  buffer.copyToChannel(pcm, 0);
  sourceNode.buffer = buffer;
  sourceNode.loop = !!loop;

  try {
    const targetNode = _getPlaybackTarget();
    sourceNode.connect(targetNode);
  } catch (e) {

    try { sourceNode.connect(audioCtx.destination); } catch (e2) { console.warn("connect fallback failed", e2); }
  }

  const offsetSec = startSample / sampleRate;
  sourceStartTime = audioCtx.currentTime - offsetSec;
  try {
      sourceNode.start(0, offsetSec);
  } catch (e) {

      const remaining = pcm.length - startSample;
      const shortBuf = audioCtx.createBuffer(1, Math.max(1, remaining), sampleRate);
      shortBuf.copyToChannel(pcm.subarray(startSample, startSample + remaining), 0);
      try { sourceNode.stop(); } catch(_) {}
      try { sourceNode.disconnect(); } catch(_) {}
      sourceNode = audioCtx.createBufferSource();
      sourceNode.buffer = shortBuf;
      sourceNode.loop = !!loop;
      try {
        const targetNode = _getPlaybackTarget();
        sourceNode.connect(targetNode);
      } catch (e2) {
        try { sourceNode.connect(audioCtx.destination); } catch (_) {}
      }
      sourceStartTime = audioCtx.currentTime;
      sourceNode.start();
  }

  playing = true;
  pausedAtSample = null;
}

async function playFrame(frameX) {
  currentCursorX = frameX;
  if (!pcm) return;
  ensureAudioCtx();

  if (audioCtx.state === 'suspended') {
    try { await audioCtx.resume(); } catch (e) { console.warn("audioCtx.resume() failed:", e); }
  }

  stopSource(true);
  const start = frameX * hop;
  const end = Math.min(start + fftSize, pcm.length);
  if (end <= start) return;
  const frameLen = end - start;

  const buffer = audioCtx.createBuffer(1, frameLen, sampleRate);
  buffer.copyToChannel(pcm.subarray(start, end), 0);

  sourceNode = audioCtx.createBufferSource();
  sourceNode.buffer = buffer;
  sourceNode.loop = true; 

  try {
    const targetNode = _getPlaybackTarget();
    sourceNode.connect(targetNode);
  } catch (e) {
    try { sourceNode.connect(audioCtx.destination); } catch (_) {}
  }

  sourceStartTime = audioCtx.currentTime - (start / sampleRate);
  sourceNode.start();
  playing = true;
  pausedAtSample = null;
}

function renderFullSpectrogramToImage() {
    if (!imageBuffer || !mags || !phases) return;
    const w = specWidth, h = specHeight;
    for(let xx=0; xx<w; xx++){

        for(let yy=0; yy<h; yy++){

            const bin = displayYToBin(yy, h);
            const idx = xx * h + bin;
            const mag = mags[idx] || 0;
            const phase = phases[idx] || 0;
            const [r,g,b] = magPhaseToRGB(mag, phase);
            const pix = (yy * w + xx) * 4;
            imageBuffer.data[pix] = r;
            imageBuffer.data[pix+1] = g;
            imageBuffer.data[pix+2] = b;
            imageBuffer.data[pix+3] = 255;
        }
    }
    specCtx.putImageData(imageBuffer, 0, 0);
    renderView();
}

</script>
<script src="downloads.js"></script>
<script>

function processPendingFramesLive(){

  if (!pcm || !fftSize) return;

  while (pos + fftSize <= pcm.length) {

    if (!drawFrame(specWidth, specHeight)) break;
  }

  if (imageBuffer && specCtx) specCtx.putImageData(imageBuffer, 0, 0);
  renderView();
  drawCursor(true);
}

</script>
<script src="brushPreview.js"></script>
<script src="rightClick.js"></script>
<script>

updateBrushPreview();
updateTimelineCursor();

drawTimeline();
drawYAxis();
drawLogScale();
renderFullSpectrogramToImage();
window.addEventListener('beforeunload', function (e) {
    // Standard message browsers show, custom text is ignored in most browsers
    const confirmationMessage = "Changes may not be saved.";

    e.preventDefault(); // Some browsers require this
    e.returnValue = confirmationMessage; // Standard way to trigger the dialog
});
</script>
<script src="eq.js"></script>
<!-- Tutorial overlay (single-page buttons + per-step dialogs) -->

<div id="tutorialDialog" class="tutorial-dialog hide" role="dialog" aria-live="polite">
    <h3 id="tdTitle">Title</h3>
    <p id="tdText">Text</p>
    <div class="tutorial-actions" id="tdActions">
      <!-- Buttons created dynamically per-step -->
    </div>
  </div>

<script src="tutorial.js"></script>

</body>
</html>