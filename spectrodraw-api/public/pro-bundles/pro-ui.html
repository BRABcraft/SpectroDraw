<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="description" content="Use the SpectroDraw web app to draw, visualize, and sculpt sound directly on the spectrogram. Free, browser-based sound design.">
  <meta property="og:title" content="SpectroDraw Web App - Interactive Spectrogram Editor">
  <meta property="og:description" content="Draw directly on audio with the SpectroDraw web app. Visual sound editing, real-time playback, and more â€” all in your browser.">
  <link rel="canonical" href="https://spectrodraw.com/app">
  <title>SpectroDraw - Interactive spectrogram editor</title>

<script>
/*
  Manifest-driven loader.
  - Place this at the top of <head> (before any <img>, <link>, <script src>, etc.)
  - manifestUrl should point to the manifest JSON published to KV/site (see sample manifest above)
  - Elements may also be annotated with data-manifest="<logical-name>" to override the detected name.
  - For safety you can set loaderTimeoutMs to a small value to not block page too long.
*/
(async function () {
  const manifestUrl = 'https://api.spectrodraw.com/spectrodraw-pro/manifest.json'; // adjust if needed
  const loaderTimeoutMs = 3000;

  function isAbsolute(u) {
    return /^[a-zA-Z][a-zA-Z0-9+.-]*:\/\//.test(u) || u.startsWith('//');
  }

  // Utility: canonicalize path used as key into manifest
  function normalizeKey(ref) {
    if (!ref) return null;
    // remove leading ./ or /
    return ref.replace(/^[.\/]+/, '');
  }

  // Fetch manifest (with timeout)
  const manifestPromise = (async () => {
    try {
      const controller = new AbortController();
      const id = setTimeout(() => controller.abort(), loaderTimeoutMs);
      const r = await fetch(manifestUrl, { method: 'GET',cache: 'no-cache', signal: controller.signal });
      clearTimeout(id);
      if (!r.ok) throw new Error('manifest fetch failed');
      return await r.json();
    } catch (e) {
      console.warn('Manifest load failed:', e);
      return null;
    }
  })();

  const manifest = await manifestPromise;
  if (!manifest) return; // fallback to regular behavior (existing src/href will load)

  // Convert manifest keys to normalized form for lookup
  const map = {};
  for (const k of Object.keys(manifest)) map[normalizeKey(k)] = manifest[k];

  // Helper to map a logical ref -> actual served path
  function resolveManifestUrl(ref) {
    if (!ref) return null;
    if (isAbsolute(ref)) return null; // skip external URLs
    const key = normalizeKey(ref);
    const hashed = map[key];
    if (!hashed) return null;
    // Adjust prefix if your assets live under a different base path:
    return 'https://api.spectrodraw.com/spectrodraw-pro/' + hashed;
  }

  // --- Rewrite logic for many element types ---

  // 1) Replace src/href attributes for common elements (img, script, audio, video, source, track, iframe)
  const selectors = [
    'img[src]',
    'script[src]',
    'link[rel="stylesheet"][href]',
    'audio[src]',
    'video[src]',
    'source[src]',
    'track[src]',
    'iframe[src]',
    'img[data-src]',         // also support data-src usage
    'script[data-src]',
    'link[data-href]',
    '[data-manifest]'        // any element with data-manifest attribute
  ];
  const elems = Array.from(document.querySelectorAll(selectors.join(',')));

  // For scripts we need to preserve execution order. Collect scripts and handle separately.
  const scriptsToLoad = [];

  for (const el of elems) {
    // Determine original reference: data-manifest > data-src/data-href > src/href
    const manifestName = el.getAttribute('data-href') ||
                         el.getAttribute('data-src') ||
                         el.getAttribute('data-manifest') ||
                         el.getAttribute('src') ||
                         el.getAttribute('href');
    let ref = manifestName;

    if (!ref) continue;
    // if absolute URL, skip
    if (isAbsolute(ref)) continue;

    const resolved = resolveManifestUrl(ref);
    if (!resolved) {
      // no mapping: don't modify, let the browser try original path (may 404)
      continue;
    }

    // special handling for different element types
    const tag = el.tagName && el.tagName.toLowerCase();
    if (tag === 'script') {
      // prevent the browser from immediately loading original src by removing attribute if present
      el.removeAttribute('src');
      scriptsToLoad.push({
        original: el,
        src: resolved,
        async: el.hasAttribute('async'),
        defer: el.hasAttribute('defer'),
        type: el.getAttribute('type') || 'text/javascript',
        module: el.getAttribute('type') === 'module'
      });
    } else if (tag === 'link') {
      // set href to resolved
      el.setAttribute('href', resolved);
    } else if (tag === 'img' || tag === 'iframe' || tag === 'video' || tag === 'audio' || tag.tagName === undefined) {
      // for img/iframe/video/audio/source/track just set src (or data-src -> src)
      if (el.hasAttribute('src') || el.hasAttribute('data-src')) {
        el.setAttribute('src', resolved);
      } else if (el.hasAttribute('href') || el.hasAttribute('data-href')) {
        el.setAttribute('href', resolved);
      } else {
        // fallback
        try { el.src = resolved; } catch (e) {}
      }
    } else if (tag === 'source' || tag === 'track') {
      el.setAttribute('src', resolved);
    } else {
      // apply to generic elements with background-image inline style
      const bg = el.style && (el.style.backgroundImage || el.style.background);
      if (bg && bg.indexOf('url(') !== -1) {
        el.style.cssText = el.style.cssText.replace(/url\((['"]?)([^)'"]+)\1\)/g, (m, q, u) => {
          const r = resolveManifestUrl(u);
          return r ? `url('${r}')` : m;
        });
      }
    }
  }

  // 2) Rewrite CSS url(...) inside <style> elements and in document.styleSheets where accessible
  // Note: cross-origin stylesheets may be inaccessible (skip those).
  const styleEls = Array.from(document.querySelectorAll('style'));
  for (const s of styleEls) {
    let text = s.textContent;
    if (!text) continue;
    text = text.replace(/url\((['"]?)([^)'"]+)\1\)/g, (m, q, u) => {
      if (isAbsolute(u)) return m;
      const r = resolveManifestUrl(u);
      return r ? `url('${r}')` : m;
    });
    s.textContent = text;
  }

  // Try to patch accessible stylesheet rules (may throw on CORS'd sheets)
  for (const sheet of Array.from(document.styleSheets)) {
    try {
      const rules = sheet.cssRules || [];
      for (let i = 0; i < rules.length; i++) {
        const rule = rules[i];
        if (!rule || !rule.cssText) continue;
        const newText = rule.cssText.replace(/url\((['"]?)([^)'"]+)\1\)/g, (m, q, u) => {
          if (isAbsolute(u)) return m;
          const r = resolveManifestUrl(u);
          return r ? `url('${r}')` : m;
        });
        if (newText !== rule.cssText) {
          // replace the whole rule
          sheet.deleteRule(i);
          sheet.insertRule(newText, i);
        }
      }
    } catch (e) {
      // ignore CORS / read-only stylesheets
    }
  }

  // 3) Load scripts sequentially to preserve order. We replaced original script src attributes earlier.
  // scriptsToLoad is in document order.
  async function loadScriptsSequentially(items) {
    for (const it of items) {
      const original = it.original;
      const newScript = document.createElement('script');
      if (it.module) newScript.type = 'module'; else newScript.type = it.type;
      if (it.async) newScript.async = true;
      if (it.defer) newScript.defer = true;
      // copy other common attributes
      if (original.getAttribute('nonce')) newScript.setAttribute('nonce', original.getAttribute('nonce'));
      if (original.id) newScript.id = original.id;

      await new Promise((resolve, reject) => {
        newScript.onload = () => resolve();
        newScript.onerror = (e) => {
          console.warn('Failed to load managed script', it.src, e);
          resolve(); // don't break the chain; continue gracefully
        };
        newScript.src = it.src;
        // replace original with new script node so DOM order is maintained
        original.parentNode && original.parentNode.replaceChild(newScript, original);
        // If async, the onload may fire out-of-order; we still await resolve for sequential guarantee
        if (it.async) {
          // async scripts run independently; resolve immediately (so chain doesn't block)
          resolve();
        }
      });
    }
  }

  // Start loading scripts (but don't block the rest of the page)
  loadScriptsSequentially(scriptsToLoad).catch(e => console.warn('Script loader error', e));

})();
</script>


  <link rel="stylesheet" type="text/css" data-href="style.css">
  <link rel="icon" type="image/x-icon" data-href="favicon.ico">
  
</head>
<body>
<div class="app">
  <header class="top-bar">
    <a href="/" id="home" title="Home" style="margin-left:10px;"><img data-manifest="BannerLogo2.png" style="background:transparent; height: 32px;"></a>
    <button id="fileB" title="Upload Audio" style="margin-left: 10px">
      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20" fill="none" stroke="#333" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
        <line x1="10" y1="16" x2="10" y2="6" />
        <polyline points="6 10 10 6 14 10" />
        <line x1="4" y1="16" x2="16" y2="16" />
      </svg>
    </button>
    <button id="rec" title="Record (Ctrl + space)"></button>
    <input id="file" title="Import audio (Ctrl + O)" type="file" accept="audio/*,video/*" style="display:none;"/>
    <button id="playPause" title="Play (space)" style="margin-left: 20px">
      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="#333" viewBox="9 8 16 16"><path d="M16 0 M14 22V10l8 6z"/></svg>
    </button>
    <button id="stop" title="Stop">
      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="#333" viewBox="0 0 20 20">
        <rect x="0" y="0" width="18" height="18" rx="2" ry="2"/>
      </svg>
    </button>
    <button class="shape-btn" data-shape="brush" id="brushBtn" style="margin-left: 20px" title="Brush (b)">
      <svg xmlns="http://www.w3.org/2000/svg" 
           width="20" height="20" 
           viewBox="5 4 18 18" 
           fill="black">
        <path d="M20.71 4.63a2 2 0 0 0-2.83 0l-9.9 9.9a3 3 0 0 0-.78 1.37l-.69 2.76a1 1 0 0 0 1.21 1.21l2.76-.69a3 3 0 0 0 1.37-.78l9.9-9.9a2 2 0 0 0 0-2.83zm-11.24 11.3l-.88.22.22-.88 9.19-9.19.66.66z"/>
      </svg>
    </button>
    <button class="shape-btn" data-shape="rectangle" id="rectBtn" title="Rectangle (r)">
      <svg xmlns="http://www.w3.org/2000/svg" 
           width="20" height="20" viewBox="0 0 20 20" 
           fill="none"
           stroke = "black" stroke-width = "5">
        <path d="M0 0 H 20 V 20 H 0 V -20"/>
      </svg>
    </button>
    <button class="shape-btn" data-shape="line" id="lineBtn" title="Line (l)">
      <svg xmlns="http://www.w3.org/2000/svg" 
           width="20" height="20" viewBox="0 0 20 20" 
           fill="none"
           stroke = "black" stroke-width = "3">
        <path d="M20 0 L 0 20"/>
      </svg>
    </button>
    <button class="shape-btn" data-shape="image" id="imageBtn" title="Image Overlay (i)">
      <svg width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="#333" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="18" cy="6" r="3" fill="#333" stroke="none"/>
        <polygon points="1,20 8,10 15,20" fill="#333"/>
        <polygon points="8,20 15,12 23,20" fill="#333"/>
      </svg>
    </button>
    <input type="file" id="overlayFile" accept="image/*" style="display:none;">
    <button class="tool-btn" data-tool="color" id="colorBtn" title="Color (c)" style="margin-left:10px;">
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#333">
        <circle cx="12" cy="12" r="9"/>
      </svg>
    </button>
    <button class="tool-btn" data-tool="blur" id="blurBtn" title="Blur (u)">
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#333">
        <path d="M12 2C12 2 7 10 7 14a5 5 0 0 0 10 0c0-4-5-12-5-12z"/>
      </svg>
    </button>
    <button class="tool-btn" data-tool="eraser" id="eraserBtn" title="Eraser (e)">
      <svg width="20" height="20" viewBox="-1 -1 16 16">
        <path d="M5,0 L0,5 L5,10 L10,5 Z " fill="#333" stroke="#333" stroke-width="1"/>
        <path d="M5,10 L10,5 L15,10 L12,13 L8,13 Z" fill="white" stroke="#333" stroke-width="1"/>
      </svg>
    </button>
    <button class="tool-btn" data-tool="amplifier" id="amplifierBtn" title="Amplifier / Reducer (a)">
      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20" fill="none">
        <path d="M2 8V12C2 12.55 2.45 13 3 13H5L7 17C7.18 17.36 7.56 17.59 7.95 17.59C8.63 17.59 9.08 16.86 8.79 16.25L7.2 13H9L16 17V3L9 7H5V7H3C2.45 7 2 7.45 2 8Z" fill="#333"/>
        <path d="M18 7C18.55 7 19 7.45 19 8V12C19 12.55 18.55 13 18 13" stroke="#333" stroke-width="1.2" stroke-linecap="round"/>
      </svg>
    </button>
    <button class="tool-btn" data-tool="noiseRemover" id="noiseRemoverBtn" title="Noise Remover (x)">
      <img data-manifest="assets/toothbrush.svg"></button>
    <button id="trueScale" title="Use true aspect ratio" style="margin-left: 20px">
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" aria-hidden="true" role="img">
        <g fill="none" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M3 9V3h6" />
          <path d="M21 15v6h-6" />
        </g>
      </svg>
    </button>
    <button id="yAxisMode" title="Toggle Y axis label mode (y)">
      <svg xmlns="http://www.w3.org/2000/svg" 
         width="28" height="28" viewBox="0 0 20 20" 
         fill="none" stroke="black" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
        <text x="0" y="18" font-size="8" fill="black" stroke-width="0.5">1.0k</text>
        <text x="10" y="6" font-size="8" fill="black" stroke-width="0.5">a5</text>
        <line x1="4" y1="4" x2="18" y2="14" />
      </svg>
    </button>
     <button id="downloadWav" style="margin-left:20px" title="Download audio (ctrl + s)">
      <svg width="20" height="20" viewBox="2 2 20 21" fill="none" stroke="#333" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M4 14v-2a8 8 0 0 1 16 0v2" />
        <path d="M5 14v4h2v-4H6z" />
        <path d="M17 14v4h2v-4h-2z" />
        <path d="M12 12v10" />
        <path d="M9 19l3 3 3 -3" />
      </svg>
    </button>
    <button id="downloadButton" title="Download spectrogram (ctrl + shift + s)">
      <svg width="20" height="20" viewBox="2 2 20 21" fill="none" stroke="#333" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <rect x="3" y="3" width="18" height="14" rx="2" ry="2" />
        <circle cx="17" cy="7" r="2" />
        <polyline points="3 17 10 10 14 14 21 7" />
        <path d="M12 12v10" />
        <path d="M9 19l3 3 3 -3" />
      </svg>
    </button>
    <button id="resetButton" onClick="onReset();" title="Reset audio">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#333" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <rect x="5" y="7" width="14" height="14" rx="2" ry="2" />
        <line x1="8" x2="8" y1="11" y2 = "17" stroke-width="1"/>
        <line x1="12" x2="12" y1="11" y2 = "17" stroke-width="1"/>
        <line x1="16" x2="16" y1="11" y2 = "17" stroke-width="1"/>
        <rect x="3" y="4" width="18" height="3" rx="2" ry="2" />
        <rect x="8" y="1" width="8" height="2" rx="2" ry="2" stroke-width="1"/>
      </svg>
    </button>
    <button id="undoBtn" title="Undo (Ctrl+Z)">
      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M9 14H5V10"/>
        <path d="M20 20a9 9 0 0 0-15-6.7L5 10"/>
      </svg>
    </button>
    <button id="redoBtn" title="Redo (Ctrl+Y)">
      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M15 14h4v-4"/>
        <path d="M4 20a9 9 0 0 1 15-6.7L19 10"/>
      </svg>
    </button>
  </header>
  <aside class="left-bar">
    <!-- Project info -->
    <button class="panel-btn" id="settingsBtn" title="General (g)" data-tool="0">
      <svg xmlns="http://www.w3.org/2000/svg" 
          width="20" height="20" viewBox="0 0 24 24" 
          fill="none" stroke="white" stroke-width="2" 
          stroke-linecap="round" stroke-linejoin="round">
        <circle cx="12" cy="12" r="3"/>
        <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 1 1-2.83 2.83l-.06-.06a1.65 
                1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 
                1 1-4 0v-.09a1.65 1.65 0 0 0-1-1.51 
                1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 
                1 1-2.83-2.83l.06-.06a1.65 
                1.65 0 0 0 .33-1.82 1.65 
                1.65 0 0 0-1.51-1H3a2 2 0 
                1 1 0-4h.09a1.65 1.65 0 
                0 0 1.51-1 1.65 1.65 0 
                0 0-.33-1.82l-.06-.06a2 
                2 0 1 1 2.83-2.83l.06.06a1.65 
                1.65 0 0 0 1.82.33H9a1.65 
                1.65 0 0 0 1-1.51V3a2 2 
                0 1 1 4 0v.09a1.65 1.65 0 
                0 0 1 1.51 1.65 1.65 0 
                0 0 1.82-.33l.06-.06a2 
                2 0 1 1 2.83 2.83l-.06.06a1.65 
                1.65 0 0 0-.33 1.82V9c0 
                .69.28 1.35.77 1.82.49.47 
                1.15.77 1.82.77h.09a2 2 
                0 1 1 0 4h-.09c-.69 0-1.35.28-1.82.77z"/>
      </svg>
    </button>
    
    <!--Tool editor-->
    <button class="panel-btn" id="toolEditBtn" title="Tool Editor" data-tool="1">
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 20 20" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M12.58,11.21 C11.62,12.17 10.91,12.66 10.36,12.85 C10.19,12.35 9.92,11.88 9.52,11.49 C9.12,11.10 8.65,10.82 8.15,10.64 C8.35,10.09 8.84,9.38 9.79,8.43 C12.06,6.15 16.10,3.36 16.87,4.13 C17.64,4.90 14.85,8.94 12.58,11.21 Z 
        M8.39,15.41 C8.02,15.77 7.53,15.96 7.05,15.99 L7.05,16.00 L6.93,16.00 C3.68,16.11 2.26,12.44 3.38,12.83 C4.84,13.33 5.44,12.60 5.46,12.58 C6.27,11.81 7.58,11.81 8.39,12.58 C9.20,13.36 9.20,14.64 8.39,15.41 Z"/>
      </svg>
    </button>

    <!--Sprite-->
    <button class="panel-btn" id="spritesBtn" title="Sprites" data-tool="2">
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <polygon points="12,3 20,7 20,17 12,21 4,17 4,7" />
        <line x1="12" y1="11" x2="12" y2="21" />
        <line x1="4" y1="7" x2="12" y2="11" />
        <line x1="20" y1="7" x2="12" y2="11" />
      </svg>
    </button>

    <!--Uploads-->
    <button class="panel-btn" id="uploadsBtn" title="Uploads" data-tool="3">
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 22 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M2 6h18v11a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V6z" />
        <path d="M2 6V3h9v2" />
      </svg>
    </button>

    <!-- Midi -->
    <button class="panel-btn" id="pianoBtn" title="Piano (p)" data-tool="4">
      <svg xmlns="http://www.w3.org/2000/svg" 
          width="24" height="24" viewBox="0 0 24 22" 
          fill="none" stroke="white" stroke-width="2" 
          stroke-linecap="round" stroke-linejoin="round">
        <rect x="2" y="2" width="20" height="20" rx="2" ry="2"/>
        <line x1="7" y1="4" x2="7" y2="15" stroke-width="3"/>
        <line x1="17" y1="4" x2="17" y2="15" stroke-width="3"/>
        <line x1="12" y1="4" x2="12" y2="15" stroke-width="3"/>
      </svg>
    </button>

    <!-- EQ curve -->
    <button class="panel-btn" id="eqBtn" title="Equalizer (q)" data-tool="5">
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M3 17c2-4 4-6 8-6s6 4 10 4"/>
        <circle cx="3" cy="17" r="1.5" fill="white"/>
        <circle cx="11" cy="11" r="1.5" fill="white"/>
        <circle cx="21" cy="15" r="1.5" fill="white"/>
      </svg>
    </button>
    
    <!--Macros-->
    <button class="panel-btn" id="macrosBtn" title="Macros" data-tool="6">
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <polyline points="6 8 10 12 6 16" />
        <line x1="13" y1="16" x2="18" y2="16" />
      </svg>
    </button>
  </aside>

  <aside class="left-panel">
    <div style="border:1px solid #888; padding: 4px; margin-top:-11px" id="midiv" title="Hold 'n' to preview pitch"><label id="mouseInfo">Pitch: 0hz<br>Time: 0.0<br>Loudness: -inf dB</label><br></div>
    <!--Project settings-->
    <div id="d0">
      <h2 style="margin-bottom:10px;margin-top:10px;">General</h2>
      <div id="fftParameters">
        <label class="h1">FFT Parameters
          <a id="fftLearnMore" class="learn-more" href="/faq/fft/#notes" title="Learn more about FFT / STFT" target="_blank" rel="noopener noreferrer" style="color:#777;font-size:10px;display:inline-block;transform:translateY(-1px)">Learn more</a>
        </label>
        <div class="slider-row">
          <label class="h2" title="Height of spectrogram in pixels.">Pitch resolution:</label>
          <select id="fftSize" style="margin-left:87px;">
            <option value="16384">16384</option>
            <option value="8192">8192</option>
            <option value="4096" selected>4096</option>
            <option value="2048">2048</option>
            <option value="1024">1024</option>
            <option value="512">512</option>
            <option value="256">256</option>
            <option value="128">128</option>
            <option value="64">64</option>
          </select>
        </div>
        <div class="slider-row" style="align-items:center;">
          <label class="h2" title="Number of audio samples given to each frame (x pixel).">Time resolution:</label>
          <button id="lockHopBtn" class="lock-btn" aria-pressed="true" title="Lock time resolution to prevent phase interference" style="background:none; border:none; margin-left:55px;" onclick="toggleLockHop();"></button>
          <input id="hopSize" type="number" value="1024" step="1" min="1" style="margin-left: 8px;">
        </div>
      </div>
      <label class="h1">Preset Audio<audio data-manifest=""></audio><br>
      </label>
      <label class="h2" for="presets">Use presets</label>
      <select id="presets">
        <option value="silence">Silence</option>
        <option value="male">Male sing</option>
        <option value="female">Female sing</option>
        <option value="dog">Dog</option>
        <option value="birdChirp">Bird chirp</option>
        <option value="lionRoar">Lion roar</option>
        <option value="seaLion">Sea lion</option>
        <option value="violin">Violin</option>
        <option value="trumpet">Trumpet</option>
        <option value="timpani">Timpani</option>
        <option value="piano">Piano</option>
        <option value="flute">Flute</option>
        <option value="cymbal">Cymbal</option>
        <option value="computerBeeps">Computer beeps</option>
        <option value="scream">Scream</option>
        <option value="bomb">Bomb</option>
        <option value="engine">Engine</option>
        <option value="fullSpectra">Loud noise</option>
        <option value="bass808">808 bass</option>
        <option value="hardstyle">Hardstyle</option>
        <option value="kick">Kick</option>
        <option value="hihat">Hihat</option>
        <option value="clap">Clap</option>
        <option value="cave14">Cave14.ogg</option>
        <option value="sine">Sine wave</option>
        <option value="triangle">Triangle wave</option>
        <option value="square">Square wave</option>
        <option value="saw">Saw wave</option>
      </select>
      <div id ="es" class="slider-row" title="Empty audio seconds">
        <label class="h2">Empty audio seconds</label>
        <input id="emptyAudioLength" type="range" min="0.01" max="100" step="0.01" value="10">
        <input id="emptyAudioLengthInput" type="number" value="10" min="0.01" max="100">
      </div>
      <div class="slider-row" title="Preview sound while drawing">
          <label class="h2">Sound while drawing</label>
          <input id="previewWhileDrawing" type="checkbox" checked>
      </div>
    </div>
    <!--Brush editor-->
    <div id="d1" style="display:none;">
      <div id="brushSettings">
        <label class="h1">Brush settings</label>
        <canvas id="strokePreview" width="300" height="100" style="border:1px solid #ccc; display:block; margin-top:10px;"></canvas>
        <div class="slider-row" title="Brush size/image size" id="brushSizeDiv">
          <label class="h2">Brush Size</label>
          <input id="brushSize" type="range" min="1" max="200" value="40">
          <input id="brushSizeInput" type="number" value="10" min="1" max="200">
        </div>
        <div class="slider-row" title="Brightness" id="brushColorDiv">
            <label class="h2">Brush Brightness</label>
            <input id="brushColor" type="range" min="0" max="255" value="255">
            <input id="brushColorInput" type="number" value="255" min="0" max="255">
        </div>
        <div class="slider-row" title="Blur Radius" style="display:none;" id="blurRadiusDiv">
            <label class="h2">Blur Radius</label>
            <input id="blurRadius"  type="range" min="0" max="10" value="1.5" step="0.1">
            <input id="blurRadiusInput" type="number" value="1.5" min="0" max="10">
        </div>
        <div class="slider-row" title="Blur Radius" style="display:none;" id="amplifyDiv">
            <label class="h2">Amplifier</label>
            <input id="amp"  type="range" min="0" max="2" value="2" step="0.01">
            <input id="ampInput" type="number" value="2" min="0" max="2">
        </div>
        <div class="slider-row" title="Remove noise below this threshold" style="display:none;" id="noiseFloorDiv">
            <label class="h2">Noise Threshold (dB)</label>
            <input id="noiseRemoveFloor"  type="range" min="-60" max="0" value="-10" step="0.1">
            <input id="noiseRemoveFloorInput" type="number" value="-10" min="-60" max="0">
        </div>
        <div id="ev" class="slider-row" title="Phase texture">
          <label class="h2" for="phaseTexture">Phase texture</label>
          <select id="phaseTexture">
            <option value="Harmonics">Harmonics</option>
            <option value="Static">Static</option>
            <option value="Flat">Flat</option>
          </select>
        </div>
        <div class="slider-row" title="Phase" id="phaseDiv">
            <label class="h2">Phase shift</label>
            <input id="penPhase"  type="range" min="0" max="3.1415" value="0" step="0.0001">
            <input id="penPhaseInput" type="number" value="0" min="0" max="3.1415">
        </div>
        <div class="slider-row" title="Brightness strength">
            <label class="h2">Opacity</label>
            <input id="brushOpacity"  type="range" min="0" max="100" value="100">
            <input id="brushOpacityInput" type="number" value="100" min="0" max="100">
        </div>
        <div class="slider-row" title="Phase strength" id="phaseStrengthDiv">
            <label class="h2">Phase Strength</label>
            <input id="phaseOpacity"  type="range" min="0" max="100" value="0">
            <input id="phaseOpacityInput" type="number" value="0" min="0" max="100">
        </div>
      </div> 
    </div>
    <!--Sprites-->
    <div id="d2" style="display:none;">
      <h3 style="margin:6px 0 10px 0;">Sprites</h3>
      <div id="spriteTableWrap">
        <table id="spriteTable" role="grid" aria-label="Sprites table">
          <thead>
            <tr>
              <th style="width:55%;">Name</th>
              <th style="width:15%;">Enabled</th>
              <th style="width:30%;">Tool</th>
            </tr>
          </thead>
          <tbody id="spriteTableBody">
            <!-- rows inserted dynamically -->
          </tbody>
        </table>
      </div>
      <strong id="selectedName">No sprite selected</strong>
      <span class="small" id="selectedTool"></span>
      <span class="small" id="selectedMeta"></span>
      <div id="spriteEditor">
        <button id="moveSpriteBtn" class="leftBtn">Move Sprite</button>
        <button id="deleteSpriteBtn" class="leftBtn" style="color:Red;">Delete Sprite</button>
      </div>
    </div>
    <!--Uploads-->
    <div id="d3" style="display:none;"></div>
    <!--Midi-->
    <div id="d4" style="display:none;">
      <h2 style="margin-bottom:10px;margin-top:10px;">Piano</h2>
      <label class="h1">Brush Alignment</label>
      <!--Auto align pitch-->
      <button class="leftBtn" id="alignPitch" title="Auto align pitch (j)">Auto Align Pitch</button>
      <div id="startOnPitchDiv" style="display:none;">
        <div class="slider-row" title="Base Pitch">
          <label class="h2">Base Hz</label>
          <input id="startOnPitch" type="range" min="261.63" max="523.3" step="0.01" value="440">
          <input id="startOnPitchInput" type="number" value="440">
        </div>
        <!--Notes per octave (achieve with pitch bends)-->
        <div class="slider-row" title="Notes Per Octave">
          <label class="h2">Notes per octave</label>
          <input id="npo" type="range" min="1" max="48" step="1" value="12">
          <input id="npoInput" type="number" value="12" min="1" max="384">
        </div>
      </div>
      <!--Auto align time-->
      <button class="leftBtn" id="alignTime" title="Auto align time (k)">Auto Align Time</button>
      <div id ="bpmDiv" class="slider-row" title="BPM" style="display:none;">
        <label class="h2">BPM</label>
        <input id="bpm" type="range" min="0.001" max="500" step="0.01" value="120">
        <input id="bpmInput" type="number" value="120" min="0.001" max="5000">
      </div>
      <!--Remove harmonics button-->
      <button class="leftBtn" id="removeHarmonicsBtn" title="Auto Remove Harmonics" onClick="removeHarmonics()">Remove Harmonics</button>
      <label class="h1">MIDI Export</label>
      <input type="checkbox" id="useMidiAI" title="Use AI model (Ideal for songs)">Use BasicPitch AI</input>
      <div class="slider-row" title="Duration cutoff">
        <label class="h2">Duration cutoff (secs)</label>
        <input id="durationCutoff" type="range" min="0" max="1" step="0.001" value="0.05">
        <input id="durationCutoffInput" type="number" value="0.05" min="0" max="1">
      </div>
      <div id="nonAiMidiDiv">
        <!--Noise floor cutoff-->
        <div class="slider-row" title="Noise floor cutoff">
          <label class="h2">Noise floor (dB)</label>
          <input id="noiseFloorCutoff" type="range" min="-50" max="0" step="0.1" value="-30">
          <input id="noiseFloorCutoffInput" type="number" value="-30" min="-50" max="0">
        </div>
        <input type="checkbox" id="midiAlignTime" title="Midi export time filter" checked>Align to tempo</input>
        <div id="matOptions">
          <div id ="midiBpmDiv" class="slider-row" title="Note BPM">
            <label class="h2">BPM</label>
            <input id="midiBpm" type="range" min="0.001" max="500" step="0.01" value="120">
            <input id="midiBpmInput" type="number" value="120" min="0.001" max="5000">
          </div>
          <div id ="subBeatDiv" class="slider-row" title="Sub beats">
            <label class="h2">Sub beats</label>
            <input id="subBeat" type="range" min="1" max="24" step="1" value="8">
            <input id="subBeatInput" type="number" value="8" min="1" max="24">
          </div>
        </div>
        <button class="leftBtn" title="Use volume controllers (Not recommended)" id="useVolumeControllers">Use Volume Controllers</button>
      </div>
      <div id="AiMidiDiv" style="display:none;">
        <label class="h1">Time Quantize</label>
        <div class="slider-row" title="Time quantize strength">
          <label class="h2">Strength</label>
          <input id="tQs" type="range" min="0" max="100" step="1" value="0">
          <input id="tQsInput" type="number" value="0" min="0" max="100">
        </div>
        <div class="slider-row" title="Time quantize strength">
          <label class="h2">Tempo</label>
          <input id="tQt" type="range" min="1" max="300" step="1" value="120">
          <input id="tQtInput" type="number" value="120" min="1" max="300">
        </div>
        <div class="slider-row" title="Phase texture">
          <label class="h2" for="tQd">Time division</label>
          <select id="tQd">
            <option value="1">1/1</option>
            <option value="2">1/2</option>
            <option value="3">1/3</option>
            <option value="4">1/4</option>
            <option value="5">1/5</option>
            <option value="6">1/6</option>
            <option value="7">1/7</option>
            <option value="8" selected="selected">1/8</option>
            <option value="12">1/12</option>
            <option value="16">1/16</option>
            <option value="24">1/24</option>
            <option value="32">1/32</option>
          </select>
        </div>
      </div>
      <!--Export button-->
      <button class="leftBtn" id="exportMIDI" title="Export Midi (ctrl + m)" onclick="exportMidi()">Export MIDI</button>
    </div>
    <!--EQ-->
    <div id="d5" style="display:none; height: 80%">
      <h2 style="margin-bottom:10px;margin-top:10px;">Equalizer</h2>
      <h5 style="margin-top:0px; margin-bottom:10px;">Note: Does not update on the spectrogram to save lag</h5>
      <div class="slider-row" title="Global gain">
        <label class="h2">Global gain</label>
        <input id="globalGain" type="range" min="-30" max="30" step="0.1" value="0">
        <input id="globalGainInput" type="number" value="0" min="-30" max="30">
      </div>
      <div class="slider-row" title="EQ Presets">
        <label class="h2" for="eqPresets">Presets</label>
        <select id="eqPresets">
          <option value="Flat">Flat</option>
          <option value="Bass boost">Bass boost</option>
          <option value="Lowpass">Lowpass</option>
          <option value="Mid boost">Mid boost</option>
          <option value="Midpass">Midpass</option>
          <option value="High boost">High boost</option>
          <option value="Highpass">Highpass</option>
          <option value="Custom">Custom</option>
        </select>
      </div>
      <canvas id="eqCanvas" width="300" height="440" style="border:1px solid #ccc; display:block; margin-top:10px;"></canvas>
    </div>
    <!--Macros-->
    <div id="d6" style="display:none;"></div>
  </aside>

  <main class="main-area">
    <!-- paste your canvas wrapper here -->
    <div id="canvasWrapper" style="position:absolute; width:100%;">
      <canvas id="timeline" style="height:40px; background:#222; position: absolute;left:40px;z-index: 9998; top:0px"></canvas>
      <canvas id="canvas" style="cursor:crosshair; position: absolute; left: 40px; top:40px"></canvas>
      <canvas id="overlay" style="background: transparent; position:absolute; left:40px; pointer-events:none; z-index:10; top:40px"></canvas>
      <canvas id="freq" style="width:40px; background:#222; position:absolute; left:0; ; top:40px"></canvas>
      <canvas id="logscale" width=40 height = 40 style="position:absolute; top:0px; background: #111;z-index: 999; top:0px"></canvas>
    </div>
  </main>
</div>
<div id="status" style="position:absolute;bottom:0px;"></div>
</body>
<!-- <script>alert("Warning: You have claimed SpectroDraw Pro on this account, but it is still in development. Please sign in on an account without pro to return to the standard app.")</script> -->

<script data-manifest="fft.js"></script>
<script>

const fileEl=document.getElementById("file");
const canvas=document.getElementById("canvas");
const ctx=canvas.getContext("2d");
const overlayCanvas = document.getElementById("overlay");
const overlayCtx = overlayCanvas.getContext("2d");
const status=document.getElementById("status");
const fftSizeEl=document.getElementById("fftSize");
const hopSizeEl=document.getElementById("hopSize");
const brushSizeEl=document.getElementById("brushSize");
const brushOpacityEl=document.getElementById("brushOpacity");
const phaseOpacityEl=document.getElementById("phaseOpacity");
const brushColorEl=document.getElementById("brushColor");
const blurRadiusEl=document.getElementById("blurRadius");
const ampEl=document.getElementById("amp");
const noiseRemoveFloorEl=document.getElementById("noiseRemoveFloor");
const penPhaseEl=document.getElementById("penPhase");
const logscaleEl = document.getElementById("logscale");
const emptyAudioLengthEl = document.getElementById("emptyAudioLength");
const phaseTextureEl = document.getElementById("phaseTexture");
const recordBtn = document.getElementById("rec");
const preset = document.getElementById("presets");
const es = document.getElementById("es");
const ev = document.getElementById("ev");
const yAxis=document.getElementById("freq");
const yctx=yAxis.getContext("2d");
const yAxisMode=document.getElementById("yAxisMode");
const info = document.getElementById("mouseInfo");
const alignPitchBtn = document.getElementById("alignPitch");
const startOnPitchDiv = document.getElementById("startOnPitchDiv");
const alignTimeBtn = document.getElementById("alignTime");
const bpmDiv = document.getElementById("bpmDiv");
const midiAlignTimeBtn = document.getElementById("midiAlignTime");
const useAIEl = document.getElementById("useMidiAI");
const nonAIMidiOptions = document.getElementById("nonAiMidiDiv");
const matOptions = document.getElementById("matOptions");
const midiBpmDiv = document.getElementById("midiBpmDiv");
const subBeatDiv = document.getElementById("subBeatDiv");
const AIMidiOptions = document.getElementById("AiMidiDiv");
const tQs = document.getElementById("tQs");
const tQt = document.getElementById("tQt");
const tQd = document.getElementById("tQd");
const WORKLET_CODE = `
class RecorderProcessor extends AudioWorkletProcessor {
  process(inputs) {
    const input = inputs[0];
    if (input && input[0] && input[0].length > 0) {
      const chunk = new Float32Array(input[0].length);
      chunk.set(input[0]);

      this.port.postMessage(chunk, [chunk.buffer]);
    }
    return true;
  }
}
registerProcessor('recorder-processor', RecorderProcessor);
`;
const micHTML = `
<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="2 5 19 19" fill="none" stroke="#333" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
  <path d="M8 15a4 4 0 0 0 8 0" />
  <rect x="10" y="7" width="4" height="8" rx="2" ry="2" fill="black"/>
  <line x1="12" y1="18" x2="12" y2="17"/>
  <line x1="9" y1="21" x2="15" y2="21"/>
</svg>`;
const recHTML = `
<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="red">
  <circle cx="12" cy="12" r="8" />
</svg>`;
const lockHTML = `<svg viewBox="0 0 24 24" width="18" height="18" aria-hidden="true" focusable="false">
  <path d="M8 10a4 4 0 0 1 8 0" fill="none" stroke="white" stroke-width="2"/>
  <rect x="6" y="10" width="12" height="10" fill="white"/>
</svg>`;
const unlockHTML = `<svg viewBox="0 0 24 24" width="18" height="18" aria-hidden="true" focusable="false">
  <path d="M0 10a4 4 0 0 1 8 0" fill="none" stroke="white" stroke-width="2"/>
  <rect x="6" y="10" width="12" height="10" fill="white"/>
</svg>`;
const toolButtons = document.querySelectorAll(".tool-btn");
const shapeButtons = document.querySelectorAll(".shape-btn");
const panelButtons = document.querySelectorAll(".panel-btn");
const trueScale = document.getElementById("trueScale");
const overlayFile = document.getElementById("overlayFile");
const uvcb = document.getElementById("useVolumeControllers");
const EQcanvas = document.getElementById("eqCanvas");
const eCtx = EQcanvas.getContext("2d"); 
const eqPresets = document.getElementById("eqPresets");
const lockHopBtn = document.getElementById("lockHopBtn");

const historyStack = []; const redoStack = [];
const MAX_HISTORY_ENTRIES = 80;

let pcm=null, sampleRate=48000, pos=0, fftSize=1024, hop=512, win=hann(1024);
let framesTotal=0, x=0, rendering=false;
let imageBuffer=null;
let visited = null;
let currentCursorX = 0;
let iLow = null;
let iHigh = null;
let fLow = null;
let fHigh = null;
let specCanvas = document.createElement("canvas");
let specCtx = specCanvas.getContext("2d");
let logScaleVal = 1.12;

let mags = null;     
let phases = null;   
let specWidth = 0;
let specHeight = 0;
let pcmChunks = null;
let trueScaleVal=false;
let overlayImage = null;
let useHz = false;
let autoPlayOnFinish = true;
let alignPitch=false;let alignTime=false;midiAlignTime=true;useMidiAI=true;
let subBeat = 1;mSubBeat=16;midiBpm=120;
let tQTempo=120;tQStrength=0;
let useVolumeControllers = false;

let startX = null, startY = null;
let cx_ = null, cy_ = null;
let zooming = false;

let brushSize=parseInt(brushSizeEl.value);
let brushOpacity=parseInt(brushOpacityEl.value)/100;
let phaseOpacity=parseInt(phaseOpacityEl.value)/100;
let brushColor=parseInt(brushColorEl.value);
let blurRadius=parseInt(blurRadiusEl.value);
let amp=parseInt(ampEl.value);
let noiseRemoveFloor = parseInt(noiseRemoveFloorEl.value);
let penPhase=parseInt(penPhaseEl.value)/10000;
let currentTool = "color";
let currentShape = "brush";
let currentPanel = "0";
let bpm = 120; let npo = 12;
let noiseFloor = document.getElementById("noiseFloorCutoff").value; let startOnP = 440;
let dCutoff = document.getElementById("durationCutoff").value;
let globalGain = 0;
let playingTutorial = false;
let currentFrame = 0;
let lockHop = false;
let sprites = [];
let nextSpriteId = 1;
let currentSprite = null;
let spriteRedoQueue = [];
sliders[0][0].addEventListener('input', () =>{sliders[0][1].value = sliders[0][0].value;});
sliders[0][1].addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    let val = parseFloat(sliders[0][1].value);
    const min = parseFloat(sliders[0][0].min);
    const max = parseFloat(sliders[0][0].max);
    if (isNaN(val)) val = 0;      
    if (val < min) val = min;
    if (val > max) val = max;
    sliders[0][1].value = val;      
    sliders[0][0].value = val;
    initEmptyPCM();
  }
});
sliders[1][0].addEventListener("input", ()=>{brushSize   =parseInt  (sliders[1][0].value); updateBrushPreview();});
sliders[1][1].addEventListener("input", ()=>{brushSize   =parseInt  (sliders[1][1].value); updateBrushPreview();});
sliders[2][0].addEventListener("input", ()=>{brushColor  =parseInt  (sliders[2][0].value); updateBrushPreview();});
sliders[2][1].addEventListener("input", ()=>{brushColor  =parseInt  (sliders[2][1].value); updateBrushPreview();});
sliders[3][0].addEventListener("input", ()=>{penPhase    =parseFloat(sliders[3][0].value); updateBrushPreview();});
sliders[3][1].addEventListener("input", ()=>{penPhase    =parseFloat(sliders[3][1].value); updateBrushPreview();});
sliders[4][0].addEventListener("input", ()=>{brushOpacity=parseInt  (sliders[4][0].value)/100; updateBrushPreview();});
sliders[4][1].addEventListener("input", ()=>{brushOpacity=parseInt  (sliders[4][1].value)/100; updateBrushPreview();});
sliders[5][0].addEventListener("input", ()=>{phaseOpacity=parseInt  (sliders[5][0].value)/100; updateBrushPreview();});
sliders[5][1].addEventListener("input", ()=>{phaseOpacity=parseInt  (sliders[5][1].value)/100; updateBrushPreview();});
sliders[6][0].addEventListener("input", ()=>{npo         =parseInt  (sliders[6][0].value);});
sliders[6][1].addEventListener("input", ()=>{if (!isNaN(sliders[6][1].value)) npo=parseInt  (sliders[6][1].value);});
sliders[7][0].addEventListener('input', () =>{noiseFloor=parseFloat(sliders[7][0].value); sliders[7][1].value = noiseFloor;});
sliders[7][1].addEventListener('keydown', (e) => {if (e.key === 'Enter') {let val = parseFloat(sliders[7][1].value);const min = parseFloat(sliders[7][0].min);const max = parseFloat(sliders[7][0].max);
    if (isNaN(val)) val = noiseFloor;      if (val < min) val = min;if (val > max) val = max;sliders[7][1].value = val;sliders[7][0].value = val;noiseFloor = val;}});
sliders[8][0].addEventListener("input", ()=>{bpm         =parseFloat(sliders[8][0].value);drawCursor(true);});
sliders[8][1].addEventListener("input", ()=>{bpm         =parseFloat(sliders[8][1].value);drawCursor(true);});
sliders[9][0].addEventListener('input', () => {startOnP = parseFloat(sliders[9][0].value); sliders[9][1].value = startOnP;});
sliders[9][1].addEventListener('keydown', (e) => {if (e.key === 'Enter') {let val = parseFloat(sliders[9][1].value);const min = parseFloat(sliders[9][0].min);const max = parseFloat(sliders[9][0].max);
    if (isNaN(val)) val = startOnP;if (val < min) val = min;if (val > max) val = max;sliders[9][1].value = val;sliders[9][0].value = val;startOnP = val;}});
sliders[10][0].addEventListener('input', () => {dCutoff = parseFloat(sliders[10][0].value); sliders[10][1].value = dCutoff;});
sliders[10][1].addEventListener('keydown', (e) => {if (e.key === 'Enter') {let val = parseFloat(sliders[10][1].value);const min = parseFloat(sliders[10][0].min);const max = parseFloat(sliders[10][0].max);
    if (isNaN(val)) val = dCutoff;if (val < min) val = min;if (val > max) val = max;sliders[10][1].value = val;sliders[10][0].value = val;dCutoff = val;}});
sliders[11][0].addEventListener('input', () => {globalGain = parseFloat(sliders[11][0].value); sliders[11][1].value = globalGain; updateEQ();});
sliders[11][1].addEventListener('keydown', (e) => {if (e.key === 'Enter') {let val = parseFloat(sliders[11][1].value);const min = parseFloat(sliders[11][0].min);const max = parseFloat(sliders[11][0].max);
    if (isNaN(val)) val = globalGain;if (val < min) val = min;if (val > max) val = max;sliders[11][1].value = val;sliders[11][0].value = val;globalGain = val;updateEQ();}});
sliders[12][0].addEventListener('input', () => {midiBpm = parseFloat(sliders[12][0].value); sliders[12][1].value = midiBpm;});
sliders[12][1].addEventListener('keydown', (e) => {if (e.key === 'Enter') {let val = parseFloat(sliders[12][1].value);const min = parseFloat(sliders[12][0].min);const max = parseFloat(sliders[12][0].max);
    if (isNaN(val)) val = midiBpm;if (val < min) val = min;if (val > max) val = max;sliders[12][1].value = val;sliders[12][0].value = val;midiBpm = val;}}); 
sliders[13][0].addEventListener('input', () => {mSubBeat = parseFloat(sliders[13][0].value); sliders[13][1].value = mSubBeat;});
sliders[13][1].addEventListener('keydown', (e) => {if (e.key === 'Enter') {let val = parseFloat(sliders[13][1].value);const min = parseFloat(sliders[13][0].min);const max = parseFloat(sliders[13][0].max);
    if (isNaN(val)) val = mSubBeat;if (val < min) val = min;if (val > max) val = max;sliders[13][1].value = val;sliders[13][0].value = val;mSubBeat = val;}});
sliders[14][0].addEventListener('input', () => {tQStrength = parseFloat(sliders[14][0].value); sliders[14][1].value = tQStrength; updateEQ();});
sliders[14][1].addEventListener('keydown', (e) => {if (e.key === 'Enter') {let val = parseFloat(sliders[14][1].value);const min = parseFloat(sliders[14][0].min);const max = parseFloat(sliders[14][0].max);
    if (isNaN(val)) val = tQStrength;if (val < min) val = min;if (val > max) val = max;sliders[14][1].value = val;sliders[11][0].value = val;tQStrength = val;}});
sliders[15][0].addEventListener('input', () => {tQTempo = parseFloat(sliders[15][0].value); sliders[15][1].value = tQTempo;});
sliders[15][1].addEventListener('keydown', (e) => {if (e.key === 'Enter') {let val = parseFloat(sliders[15][1].value);const min = parseFloat(sliders[15][0].min);const max = parseFloat(sliders[15][0].max);
    if (isNaN(val)) val = tQTempo;if (val < min) val = min;if (val > max) val = max;sliders[15][1].value = val;sliders[15][0].value = val;tQTempo = val;}});
sliders[16][0].addEventListener("input", ()=>{blurRadius  =parseInt  (sliders[16][0].value); updateBrushPreview();});
sliders[16][1].addEventListener("input", ()=>{blurRadius  =parseInt  (sliders[16][1].value); updateBrushPreview();});
sliders[17][0].addEventListener("input", ()=>{amp  =  (sliders[17][0].value); updateBrushPreview();});
sliders[17][1].addEventListener("input", ()=>{amp  =  (sliders[17][1].value); updateBrushPreview();});
sliders[18][0].addEventListener('input', () => {noiseRemoveFloor = parseFloat(sliders[18][0].value); sliders[18][1].value = noiseRemoveFloor;updateBrushPreview();});
sliders[18][1].addEventListener('keydown', (e) => {if (e.key === 'Enter') {let val = parseFloat(sliders[18][1].value);const min = parseFloat(sliders[18][0].min);const max = parseFloat(sliders[18][0].max);
    if (isNaN(val)) val = noiseRemoveFloor;if (val < min) val = min;if (val > max) val = max;sliders[18][1].value = val;sliders[18][0].value = val;noiseRemoveFloor = val;updateBrushPreview();}});
recordBtn.innerHTML = micHTML;
lockHopBtn.innerHTML = unlockHTML;

function angleDiff(a, b) {
  const d = a - b;
  return Math.atan2(Math.sin(d), Math.cos(d));
}
function pushHistory(entry, clearRedo = true) {
  while (historyStack.length >= MAX_HISTORY_ENTRIES) historyStack.shift();
  historyStack.push(entry);
  if (clearRedo) redoStack.length = 0;
}

panelButtons.forEach(btn => {
  if(btn.dataset.tool === currentPanel) {
    btn.style.background = "#4af"; 
  }
});
panelButtons.forEach(btn => {
  btn.addEventListener("click", () => {
    currentPanel = btn.dataset.tool;

    // Reset all button backgrounds
    panelButtons.forEach(b => b.style.background = "");
    btn.style.background = "#4af";

    // Hide all panels and show only the current one
    let i = 0;
    while (true) {
      const panel = document.getElementById("d" + i);
      if (!panel) break; // stop when no more panels
      panel.style.display = (i == currentPanel) ? "block" : "none";
      i++;
    }

    // Call drawEQ if panel 2 is active
    if (currentPanel == "2") drawEQ();
  });
});

toolButtons.forEach(btn => {
  if(btn.dataset.tool === currentTool) {
    btn.style.background = "#4af"; 
  }
});
toolButtons.forEach(btn => {
  btn.addEventListener("click", () => {
    currentTool = btn.dataset.tool;
    toolButtons.forEach(b => b.style.background = "");
    btn.style.background = "#4af"; 
    if (currentTool === "blur") {
      document.getElementById("brushColorDiv").style.display="none";
      document.getElementById("blurRadiusDiv").style.display="flex";
      document.getElementById("amplifyDiv").style.display="none";
      document.getElementById("noiseFloorDiv").style.display="none";
    } else if (currentTool === "amplifier") {
      document.getElementById("brushColorDiv").style.display="none";
      document.getElementById("blurRadiusDiv").style.display="none";
      document.getElementById("amplifyDiv").style.display="flex";
      document.getElementById("noiseFloorDiv").style.display="none";
    } else if (currentTool === "noiseRemover") {
      document.getElementById("brushColorDiv").style.display="none";
      document.getElementById("blurRadiusDiv").style.display="none";
      document.getElementById("amplifyDiv").style.display="none";
      document.getElementById("noiseFloorDiv").style.display="flex";
    } else {
      document.getElementById("brushColorDiv").style.display="flex";
      document.getElementById("blurRadiusDiv").style.display="none";
      document.getElementById("amplifyDiv").style.display="none";
      document.getElementById("noiseFloorDiv").style.display="none";
    }
    if (currentTool === 'noiseRemover') {
      document.getElementById("ev").style.display="none";
      document.getElementById("phaseDiv").style.display="none";
      document.getElementById("phaseStrengthDiv").style.display="none";
    } else {
      document.getElementById("ev").style.display="flex";
      document.getElementById("phaseDiv").style.display="flex";
      document.getElementById("phaseStrengthDiv").style.display="flex";
    }
    document.getElementById("brushSizeDiv").style.display=(currentTool === 'rectangle')?"none":"flex";
    updateBrushPreview();
  });
});
shapeButtons.forEach(btn => {
  if(btn.dataset.shape === currentShape) {
    btn.style.background = "#4af"; 
  }
});
shapeButtons.forEach(btn => {
  btn.addEventListener("click", () => {
    currentShape = btn.dataset.shape;
    shapeButtons.forEach(b => b.style.background = "");
    btn.style.background = "#4af"; 
    if(currentShape === "image") overlayFile.click();
    document.getElementById("brushSizeDiv").style.display=(currentShape === 'rectangle')?"none":"flex";
    updateBrushPreview();
  });
});
fileB.addEventListener("click", () => {
  file.click();
});
trueScale.addEventListener("click", () =>  {trueScaleVal = !trueScaleVal; trueScale.style.background = trueScaleVal?"#4af":"var(--accent-gradient)"; restartRender(false);});
yAxisMode.addEventListener("click", () =>  {useHz        = !useHz;        yAxisMode.style.background = useHz       ?"#4af":"var(--accent-gradient)"; drawYAxis();});
uvcb.addEventListener("click",()=>{useVolumeControllers=!useVolumeControllers;uvcb.style.background = useVolumeControllers?"#4af":"var(--accent-gradient)";});
alignPitchBtn.addEventListener("click",()=>{alignPitch=!alignPitch;alignPitchBtn.style.background = alignPitch?"#4af":"var(--accent-gradient)"; startOnPitchDiv.style.display=alignPitch?"block":"none";});
alignTimeBtn.addEventListener("click",()=>{alignTime=!alignTime;alignTimeBtn.style.background = alignTime?"#4af":"var(--accent-gradient)"; bpmDiv.style.display=alignTime?"block":"none";drawCursor(true);});
midiAlignTimeBtn.addEventListener("change",()=>{midiAlignTime=midiAlignTimeBtn.checked;midiAlignTimeBtn.style = midiAlignTime?"background:#4af;margin:none;":"background:var(--accent-gradient);margin-bottom:15px;";matOptions.style.display=midiAlignTime?"block":"none";});
useAIEl.addEventListener("change",()=>{useMidiAI=useAIEl.checked;nonAIMidiOptions.style.display=useMidiAI?"none":"block";AIMidiOptions.style.display=!useMidiAI?"none":"block";});
overlayFile.addEventListener("change", e => {
  const f = e.target.files[0];
  if (!f) return;
  const img = new Image();
  img.onload = () => {overlayImage = img; updateBrushPreview();}
  img.src = URL.createObjectURL(f);
});
let ogHSv = hopSizeEl.value;
function toggleLockHop() {
  if (lockHop) {
    lockHopBtn.innerHTML=unlockHTML;
    hopSize.classList.remove("disabled");
    hopSizeEl.value = ogHSv;
    iLow = 0; iHigh = Math.max(1, Math.floor((pcm.length - fftSize) / ogHSv) + 1);
    restartRender();
  } else {
    lockHopBtn.innerHTML=lockHTML;
    hopSize.classList.add("disabled");
    ogHSv = hopSizeEl.value;
    hopSizeEl.value = fftSizeEl.value;
    iLow = 0; iHigh = Math.max(1, Math.floor((pcm.length - fftSize) / fftSizeEl.value) + 1);
    restartRender();
  }
  lockHop = !lockHop;
}
let $x = 0, $y = 0;
document.addEventListener('mousemove', e=>{
  const {cx,cy,scaleX,scaleY} = getCanvasCoords(e,false);
  $x=cx;$y=cy;
  if (pressedN) {
    const realY = visibleToSpecY($y);
    if (sineOsc) {
      setSineFreq(realY);
    }
  }
});

function keyBind(event) {
  if (event.target.tagName === 'INPUT' || event.target.tagName === 'SELECT' || event.target.tagName === 'TEXTAREA') {
    return; 
  }
  const key = event.key.toLowerCase();
  if (key === 'b') {
    document.getElementById("brushBtn").click();
  } else if (key === 'e') {
    document.getElementById("eraserBtn").click();
  } else if (key === 'p') {
    document.getElementById("pianoBtn").click();
  } else if (key === 'g') {
    document.getElementById("settingsBtn").click();
  } else if (key === 'q') {
    document.getElementById("eqBtn").click();
  } else if (key === 'r') {
    document.getElementById("rectBtn").click();
  } else if (key === 'a') {
    document.getElementById("amplifierBtn").click();
  } else if (key === 'u') {
    document.getElementById("blurBtn").click();
  } else if (key === 'i' && !event.shiftKey && !event.ctrlKey && !event.metaKey) {
    document.getElementById("imageBtn").click();
  } else if (key === 'l') {
    document.getElementById("lineBtn").click();
  } else if ((event.ctrlKey || event.metaKey) && key === 'o') {
    event.preventDefault();
    fileEl.click();
  } else if ((event.ctrlKey || event.metaKey) && event.shiftKey && key === 's') {
    event.preventDefault();
    document.getElementById('downloadButton').click();
  } else if ((event.ctrlKey || event.metaKey) && key === 's') {
    event.preventDefault();
    document.getElementById('downloadWav').click();
  } else if ((event.ctrlKey || event.metaKey) && key === 'm') {
    exportMidi();
  } else if ((event.ctrlKey || event.metaKey) && key === ' ') {
    recordBtn.click();
  } else if (key === 'y' && !event.shiftKey && !event.ctrlKey && !event.metaKey) {
    yAxisMode.click();
  } else if (key === 'j') {
    alignPitchBtn.click();
  } else if (key === 'k') {
    alignTimeBtn.click();
  } else if (key === 'x') {
    document.getElementById("noiseRemoverBtn").click();
  }
}
document.addEventListener("keydown", (e) => {
  const active = document.activeElement;
  if (active && active.matches("input[type=range], .leftBtn")) {
    if (["ArrowLeft","ArrowRight","ArrowUp","ArrowDown","Tab"].includes(e.key)) {
      return; 
    }

    active.blur();
    setTimeout(() => {
      const evt = new KeyboardEvent('keydown', {
        key: e.key,
        code: e.code,
        keyCode: e.keyCode,
        bubbles: true,
        cancelable: true,
        ctrlKey: e.ctrlKey,
        shiftKey: e.shiftKey,
        altKey: e.altKey,
        metaKey: e.metaKey
      });
      document.dispatchEvent(evt);
    }, 0);

    e.preventDefault();
    e.stopPropagation();
  }
});
document.addEventListener('keydown', (event) => {
  keyBind(event);
});
let pressedN=false;
document.addEventListener('keydown', (e)=>{
  if (e.key==='n') {
    pressedN=true;
    if (!sineOsc) {
      const realY = visibleToSpecY($y);
      sineOsc = audioCtx.createOscillator();
      sineOsc.type = "sine";
      sineGain = audioCtx.createGain();
      sineGain.gain.value = 0.2;
      sineOsc.connect(sineGain).connect(audioCtx.destination);
      setSineFreq(realY); 
      sineOsc.start();
    }
  }
});
document.addEventListener('keyup', (e)=>{
  if (e.key==='n'){
    pressedN=false;
    if (sineOsc) {
      sineOsc.stop();
      sineOsc.disconnect();
      sineOsc = null;
      sineGain = null;
    }
  }
});

let selectedSpriteId = null;

// utility to find sprite index by id
function getSpriteIndexById(id) {
  if (!sprites) return -1;
  return sprites.findIndex(s => s && s.id === id);
}

function getSpriteById(id) {
  const idx = getSpriteIndexById(id);
  return idx >= 0 ? sprites[idx] : null;
}

// Render the sprites table
function renderSpritesTable() {
  console.log('Rendering sprites table, selectedSpriteId=', selectedSpriteId);
  const tbody = document.getElementById('spriteTableBody');
  tbody.innerHTML = '';
  if (sprites.length == 0) {
    const tr = document.createElement('tr');
    tr.innerHTML = '<td colspan="3" class="muted">No sprites</td>';
    tbody.appendChild(tr);
    updateEditorSelection(null);
    return;
  }

  sprites.forEach(sprite => {
    if (!sprite) return;
    const tr = document.createElement('tr');
    tr.className = 'sprite-row' + (selectedSpriteId === sprite.id ? ' selected' : '');
    tr.dataset.spriteId = sprite.id;

    // NAME
    const name = sprite.name || ('Sprite #' + sprite.id);
    const tdName = document.createElement('td');
    tdName.textContent = name;

    // ENABLED checkbox
    const tdEnabled = document.createElement('td');
    const cb = document.createElement('input');
    cb.type = 'checkbox';
    cb.checked = !!sprite.enabled;
    cb.title = 'Toggle sprite enabled';
    cb.addEventListener('change', (ev) => {
      ev.stopPropagation();
      toggleSpriteEnabled(sprite.id, cb.checked);
      renderSpritesTable();
    });
    tdEnabled.appendChild(cb);

    // TOOL
    const tdTool = document.createElement('td');
    tdTool.textContent = sprite.tool || '';

    tr.appendChild(tdName);
    tr.appendChild(tdEnabled);
    tr.appendChild(tdTool);

    // click selects
    tr.addEventListener('click', () => {
      selectedSpriteId = sprite.id;
      renderSpritesTable();
      updateEditorSelection(sprite.id);
    });

    tbody.appendChild(tr);
  });
}

// Update editor info for selected sprite
function updateEditorSelection(spriteId) {
  const nameEl = document.getElementById('selectedName');
  const toolEl = document.getElementById('selectedTool');
  const metaEl = document.getElementById('selectedMeta');
  console.log(spriteId);
  if (spriteId === null) {
    selectedSpriteId = null;
    nameEl.textContent = 'No sprite selected';
    toolEl.textContent = '';
    metaEl.textContent = 'Select a sprite to edit â€” move or delete it.';
    return;
  }
  const s = getSpriteById(spriteId);
  if (!s) { updateEditorSelection(null); return; }
  const displayName = s.name || ('Sprite #' + s.id);
  nameEl.textContent = displayName;
  toolEl.textContent = ' â€” ' + (s.tool || '');
  const info = `Pixels columns: ${s.pixels ? Array.from(s.pixels.keys()).length : 0}  â€¢  Enabled: ${!!s.enabled}`;
  metaEl.textContent = info;
  // ensure inputs reset
  document.getElementById('moveDeltaX').value = 0;
  document.getElementById('moveDeltaY').value = 0;
}

// Toggle sprite (apply prev or next values)
function toggleSpriteEnabled(spriteId, enable) {
  const sprite = getSpriteById(spriteId);
  if (!sprite) return;
  const minCol = Math.max(0, sprite.minCol || 0);
  const maxCol = Math.min(specWidth - 1, sprite.maxCol || (specWidth - 1));

  // apply prev (disable) or next (enable)
  if (enable) {
    // write next values at recorded coords
    forEachSpritePixelInOrder(sprite, (x, y, _prevMag, _prevPhase, nextMag, nextPhase) => {
      const id = y * specWidth + x;
      mags[id] = nextMag;
      phases[id] = nextPhase;
    });
    sprite.enabled = true;
  } else {
    // write prev values back
    forEachSpritePixelInOrder(sprite, (x, y, prevMag, prevPhase) => {
      const id = y * specWidth + x;
      mags[id] = prevMag;
      phases[id] = prevPhase;
    });
    sprite.enabled = false;
  }

  // update image buffer and PCM for affected columns
  renderSpectrogramColumnsToImageBuffer(minCol, maxCol);
  recomputePCMForCols(minCol, maxCol);
  restartRender(false);
  updateCanvasScroll();

  if (playing) {
    stopSource(true);
    playPCM(true);
  }
}

// Move sprite by dx (frames) and dy (bins). Best-effort handling.
function moveSprite(spriteId, dx, dy) {
  const sprite = getSpriteById(spriteId);
  if (!sprite) return;
  // 1) restore prev values at old positions
  forEachSpritePixelInOrder(sprite, (x, y, prevMag, prevPhase) => {
    const idOld = y * specWidth + x;
    mags[idOld] = prevMag;
    phases[idOld] = prevPhase;
  });

  // 2) build new pixel map shifted by dx/dy, clamped
  const newMap = new Map();
  let newMin = Infinity, newMax = -Infinity;

  const cols = Array.from(sprite.pixels.keys()).sort((a,b)=>a-b);
  for (const oldX of cols) {
    const col = sprite.pixels.get(oldX);
    for (let i = 0; i < col.ys.length; i++) {
      const oldY = col.ys[i];
      const prevMag = col.prevMags[i];
      const prevPhase = col.prevPhases[i];
      const nextMag = col.nextMags[i];
      const nextPhase = col.nextPhases[i];

      const nx = oldX + dx;
      const ny = oldY + dy;
      if (nx < 0 || nx >= specWidth || ny < 0 || ny >= specHeight) {
        // skip out-of-bounds pixels (they are effectively removed)
        continue;
      }
      // ensure column entry exists
      let ncol = newMap.get(nx);
      if (!ncol) {
        ncol = { ys: [], prevMags: [], prevPhases: [], nextMags: [], nextPhases: [] };
        newMap.set(nx, ncol);
      }
      // Because we've already restored prev at old locations, for the new location we want:
      // - prev values should be whatever is currently in mags/phases at that destination BEFORE we write next.
      //   However we can store the previous as the current mags/phases (which reflect other layers).
      //   But to be conservative, capture current mags/phases as prev for this moved sprite.
      const destIdx = ny * specWidth + nx;
      const currentDestMag = mags[destIdx] || 0;
      const currentDestPhase = phases[destIdx] || 0;
      ncol.ys.push(ny);
      ncol.prevMags.push(currentDestMag);
      ncol.prevPhases.push(currentDestPhase);
      ncol.nextMags.push(nextMag);
      ncol.nextPhases.push(nextPhase);

      if (nx < newMin) newMin = nx;
      if (nx > newMax) newMax = nx;
    }
  }

  // 3) write next values into mags/phases for the new positions
  const newCols = Array.from(newMap.keys()).sort((a,b)=>a-b);
  for (const x of newCols) {
    const col = newMap.get(x);
    for (let i = 0; i < col.ys.length; i++) {
      const y = col.ys[i];
      const nextMag = col.nextMags[i];
      const nextPhase = col.nextPhases[i];
      const idNew = y * specWidth + x;
      mags[idNew] = nextMag;
      phases[idNew] = nextPhase;
    }
  }

  // 4) replace sprite.pixels, update bounds
  sprite.pixels = newMap;
  sprite.minCol = newMin === Infinity ? Infinity : Math.max(0, newMin);
  sprite.maxCol = Math.max(-Infinity, newMax === -Infinity ? -1 : Math.min(specWidth-1, newMax));

  // recompute/render affected columns (old range & new range)
  const affectedMin = Math.max(0, Math.min(sprite.minCol || 0, newMin === Infinity ? specWidth-1 : newMin));
  const affectedMax = Math.min(specWidth - 1, Math.max(sprite.maxCol || 0, newMax === -Infinity ? 0 : newMax));
  // safer: recompute whole union of previous and new; but we restored prev at old coords earlier.

  renderSpectrogramColumnsToImageBuffer(affectedMin, affectedMax);
  recomputePCMForCols(affectedMin, affectedMax);
  restartRender(false);
  updateCanvasScroll();

  if (playing) {
    stopSource(true);
    playPCM(true);
  }

  renderSpritesTable();
  updateEditorSelection(spriteId);
}

// Delete sprite: disable (restore prev) then remove from sprites array
function deleteSprite(spriteId) {
  const idx = getSpriteIndexById(spriteId);
  if (idx === -1) return;
  const sprite = sprites[idx];

  // restore prev values
  forEachSpritePixelInOrder(sprite, (x, y, prevMag, prevPhase) => {
    const id = y * specWidth + x;
    mags[id] = prevMag;
    phases[id] = prevPhase;
  });

  const minCol = Math.max(0, sprite.minCol || 0);
  const maxCol = Math.min(specWidth - 1, sprite.maxCol || (specWidth - 1));
  // remove from array
  sprites.splice(idx, 1);

  renderSpectrogramColumnsToImageBuffer(minCol, maxCol);
  recomputePCMForCols(minCol, maxCol);
  restartRender(false);
  updateCanvasScroll();

  if (playing) {
    stopSource(true);
    playPCM(true);
  }

  selectedSpriteId = null;
  renderSpritesTable();
  updateEditorSelection(null);
}

document.getElementById('deleteSpriteBtn').addEventListener('click', () => {
  if (!selectedSpriteId) return;
  if (!confirm('Delete selected sprite? This cannot be undone.')) return;
  deleteSprite(selectedSpriteId);
});

// initial render
renderSpritesTable();

</script>
<script data-manifest="axes.js"></script>
<script data-manifest="midi.js"></script>
<script data-manifest="recordingAndPresets.js"></script>
<script data-manifest="renderer.js"></script>
<script data-manifest="drawTools.js"></script>
<script data-manifest="undoredo.js"></script>
<script data-manifest="interactive.js"></script>
<script data-manifest="downloads.js"></script>
<script data-manifest="brushPreview.js"></script>
<script data-manifest="rightClick.js"></script>
<script data-manifest="initialRenders.js"></script>
<script data-manifest="eq.js"></script>