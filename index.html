<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Phase-aware Spectrogram Editor — Fixed</title>
<style>
body { background:#111; color:#eee; font-family:sans-serif; margin:0; padding:1em; }
.controls { margin-bottom:1em; }
label { margin-right:1em; display:inline-block; margin-top:0.5em; }
canvas { display:block; background:#000; cursor:crosshair; }
#timeline { display:block; height:40px; }
#status { margin-top:0.5em; font-size:13px; }
</style>
</head>
<body>
<div class="controls">
  <input id="file" type="file" accept=".wav"/>
  <label>FFT exponent (2^exp):
    <input id="fftSize" type="number" value="11" step="1" min="6" max="14">
  </label>
  <label>Hop size:
    <input id="hopSize" type="number" value="512" step="1" min="1">
  </label>
  <label>Brush size:
    <input id="brushSize" type="range" min="1" max="200" value="40">
  </label>
  <label>Brush brightness:
    <input id="brushColor" type="range" min="0" max="255" value="255">
  </label>
  <label>Brush phase:
    <input id="penPhase" type="range" min="0" max="31415" value="0">
  </label>
  <label>Brightness opacity:
    <input id="brushOpacity" type="range" min="0" max="100" value="100">
  </label>
  <label>Phase opacity:
    <input id="phaseOpacity" type="range" min="0" max="100" value="0">
  </label>
  <label>Logscale:
    <input id="logscale" type="range" min="1" max="2" step="0.01" value="1.12">
    <span id="logscaleValue">1.00</span>
  </label>
  <label title="Displays the spectrogram like how it looks when it's downloaded">True scale 
    <input id="trueScale" type="checkbox">
  </label>
  <div class="controls">
    <button class="tool-btn" data-tool="brush">Brush</button>
    <button class="tool-btn" data-tool="rectangle">Rectangle</button>
    <button class="tool-btn" data-tool="line">Line</button>
    <button class="tool-btn" data-tool="blur">Blur</button>
    <button class="tool-btn" data-tool="eraser">Eraser</button>
    <button class="tool-btn" data-tool="image">Image Overlay</button>
    <input type="file" id="overlayFile" accept="image/*" style="display:none;">
  </div>

  <button id="downloadWav">Download WAV</button>
  <button id="downloadButton">Download Spectrogram</button>
  <button id="resetButton" onClick="initEmptyPCM()">Reset audio</button>
  
  <label>Empty audio length:
    <input id="emptyAudioLength" type="range" min="0.01" max="100" step="0.01" value="10">
    <span id="emptyAudioLengthValue">10</span>
  </label>
</div>
<div class="controls">
  <button id="playPause">Play</button>
  <button id="stop">Stop</button>
</div>

<!-- Timeline canvas -->
<canvas id="timeline" style="height:20px; background:#222;"></canvas>
<div id="canvasWrapper" style="position:relative; display:inline-block; width:100%">
  <canvas id="canvas"></canvas>
  <canvas id="overlay" style="background: transparent; position:absolute; left:0; top:0; pointer-events:none; z-index:10;"></canvas>
</div>

<div id="status"></div>

<script>
let currentTool = "brush";
const toolButtons = document.querySelectorAll(".tool-btn");
toolButtons.forEach(btn => {
  if(btn.dataset.tool === currentTool) {
    btn.style.background = "#444"; // highlight color
  }
});
toolButtons.forEach(btn => {
  btn.addEventListener("click", () => {
    currentTool = btn.dataset.tool;
    toolButtons.forEach(b => b.style.background = "");
    btn.style.background = "#444"; // highlight selected
    if(currentTool === "image") overlayFile.click();
  });
});

const overlayFile = document.getElementById("overlayFile");
let overlayImage = null;
overlayFile.addEventListener("change", e => {
  const f = e.target.files[0];
  if (!f) return;
  const img = new Image();
  img.onload = () => overlayImage = img;
  img.src = URL.createObjectURL(f);
});

// --- Provided FFT / IFFT helpers ---
function nextPow2(v) { return 1 << Math.ceil(Math.log2(v)); }

function fft_inplace(re, im) {
  const n = re.length;
  if (n !== im.length) throw new Error('Mismatched lengths');
  const levels = Math.floor(Math.log2(n));
  if ((1 << levels) !== n) throw new Error('Length must be power of 2');

  // bit-reversed addressing
  for (let i = 0; i < n; i++) {
    let j = 0;
    for (let k = 0; k < levels; k++) j = (j << 1) | ((i >>> k) & 1);
    if (j > i) {
      [re[i], re[j]] = [re[j], re[i]];
      [im[i], im[j]] = [im[j], im[i]];
    }
  }

  for (let size = 2; size <= n; size <<= 1) {
    const half = size >>> 1;
    const theta = -2 * Math.PI / size;
    const wpr = Math.cos(theta);
    const wpi = Math.sin(theta);
    for (let i = 0; i < n; i += size) {
      let wr = 1, wi = 0;
      for (let j = 0; j < half; j++) {
        const k = i + j;
        const l = k + half;
        const tr = wr * re[l] - wi * im[l];
        const ti = wr * im[l] + wi * re[l];
        re[l] = re[k] - tr;
        im[l] = im[k] - ti;
        re[k] += tr;
        im[k] += ti;
        const tmp = wr;
        wr = tmp * wpr - wi * wpi;
        wi = tmp * wpi + wi * wpr;
      }
    }
  }
}

function ifft_inplace(re, im) {
  for (let i = 0; i < re.length; i++) im[i] = -im[i];
  fft_inplace(re, im);
  for (let i = 0; i < re.length; i++) { re[i] /= re.length; im[i] = -im[i] / re.length; }
}

function hann(N) {
  const w = new Float32Array(N);
  for (let i = 0; i < N; i++) w[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (N - 1)));
  return w;
}

function overlapAdd(signal, N) {
  const hop = N / 2; // 50% overlap
  const window = hann(N);
  const out = new Float32Array(signal.length + N); // extra space for overlap
  const re = new Float32Array(N);
  const im = new Float32Array(N);

  for (let pos = 0; pos < signal.length; pos += hop) {
    // copy frame and apply window
    for (let i = 0; i < N; i++) {
      re[i] = (pos + i < signal.length ? signal[pos + i] : 0) * window[i];
      im[i] = 0;
    }

    // FFT -> (optional processing) -> IFFT
    fft_inplace(re, im);
    // Example: no modification
    ifft_inplace(re, im);

    // overlap-add
    for (let i = 0; i < N; i++) {
      out[pos + i] += re[i] * window[i]; // apply window again for synthesis
    }
  }

  return out.subarray(0, signal.length); // trim extra tail
}

// DOM
const fileEl=document.getElementById("file");
const canvas=document.getElementById("canvas");
const ctx=canvas.getContext("2d");
const overlayCanvas = document.getElementById("overlay");
const overlayCtx = overlayCanvas.getContext("2d");
const status=document.getElementById("status");
const fftSizeEl=document.getElementById("fftSize");
const hopSizeEl=document.getElementById("hopSize");
const brushSizeEl=document.getElementById("brushSize");
const brushOpacityEl=document.getElementById("brushOpacity");
const phaseOpacityEl=document.getElementById("phaseOpacity");
const brushColorEl=document.getElementById("brushColor");
const penPhaseEl=document.getElementById("penPhase");
const logscaleEl = document.getElementById("logscale");
const logscaleValueEl = document.getElementById("logscaleValue");
const emptyAudioLengthEl = document.getElementById("emptyAudioLength");
const emptyAudioLengthValueEl = document.getElementById("emptyAudioLengthValue");
let trueScale = document.getElementById("trueScale").checked;

let pcm=null, sampleRate=44100, pos=0, fftSize=1024, hop=512, win=hann(1024);
let framesTotal=0, x=0, rendering=false;
let imageBuffer=null;
let currentCursorX = 0;

// spectrogram numeric storage
let mags = null;     // Float32Array(width * height) column-major: idx = x * height + bin
let phases = null;   // Float32Array(width * height)
let specWidth = 0;
let specHeight = 0;

// Brush
let brushSize=parseInt(brushSizeEl.value);
let brushOpacity=parseInt(brushOpacityEl.value)/100;
let phaseOpacity=parseInt(phaseOpacityEl.value)/100;
let brushColor=parseInt(brushColorEl.value); // 0..255 (display)
let penPhase=parseInt(penPhaseEl.value)/10000;
brushSizeEl.addEventListener("input",()=>brushSize=parseInt(brushSizeEl.value));
brushOpacityEl.addEventListener("input",()=>brushOpacity=parseInt(brushOpacityEl.value)/100);
phaseOpacityEl.addEventListener("input",()=>phaseOpacity=parseInt(phaseOpacityEl.value)/100);
brushColorEl.addEventListener("input",()=>brushColor=parseInt(brushColorEl.value));
penPhaseEl.addEventListener("input", ()=>penPhase = parseInt(penPhaseEl.value) / 10000);

// Default: 20s of silence (882000 samples @ 44100Hz)
function initEmptyPCM() {
    const sampleRateLocal = 44100;
    const duration = emptyAudioLengthEl.value; // seconds
    const length = sampleRateLocal * duration; // 882000 samples
    const tinyNoiseAmplitude = 0.0001; // adjust how "tiny" the samples are

    const pcmArray = new Float32Array(length);
    for (let i = 0; i < length; i++) {
        pcmArray[i] = (Math.random() * 2 - 1) * tinyNoiseAmplitude; // tiny random values between -0.001 and 0.001
    }

    pcm = pcmArray;
    sampleRate = sampleRateLocal;

    // Run the same init pipeline as if a file was loaded
    restartRender();
}

// update displayed slider value
logscaleValueEl.textContent = parseFloat(logscaleEl.value).toFixed(2);
logscaleEl.addEventListener("input", ()=> {
  logscaleValueEl.textContent = parseFloat(logscaleEl.value).toFixed(2);
  renderFullSpectrogramToImage();
});


emptyAudioLengthValueEl.textContent = parseFloat(emptyAudioLengthEl.value).toFixed(2);
emptyAudioLengthEl.addEventListener("input", ()=> {
  emptyAudioLengthValueEl.textContent = parseFloat(emptyAudioLengthEl.value).toFixed(2);
  renderFullSpectrogramToImage();
});

// Audio context: create on first user gesture to avoid browser autoplay block
let audioCtx = null;
function ensureAudioCtx(){
  if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
}

let startTime=0; // new
let audioProcessed=0; // total audio samples processed
// Load WAV
fileEl.addEventListener("change", async e=>{
    const f=e.target.files[0]; if(!f)return;
    const buf=await f.arrayBuffer();
    ensureAudioCtx();
    const ab = await audioCtx.decodeAudioData(buf.slice(0));
    pcm = new Float32Array(ab.getChannelData(0));
    sampleRate = ab.sampleRate || 44100;
    
    status.textContent=`Loaded ${f.name}, ${pcm.length} samples @ ${sampleRate} Hz`;
    restartRender();
});

fftSizeEl.addEventListener("change",restartRender);
hopSizeEl.addEventListener("change",restartRender);
document.getElementById("trueScale").addEventListener("change",restartRender);


function restartRender(){
    if(!pcm) return;
    // fftSize input is exponent (like 10 -> 1024) in existing UI - preserve that behavior
    
    trueScale = document.getElementById("trueScale").checked;
    const exponent = Math.max(6, Math.min(14, parseInt(fftSizeEl.value)||10));
    fftSize = 1 << exponent;
    hop = Math.max(1, parseInt(hopSizeEl.value) || Math.floor(fftSize/2));
    win = hann(fftSize);

    // framesTotal includes final partial (we use floor+1)
    framesTotal = Math.max(1, Math.floor((pcm.length - fftSize) / hop) + 1);
    // set canvas pixel dimensions to frame x freqBins
    const freqBins = Math.floor(fftSize / 2);
    canvas.width = framesTotal;
    canvas.height = freqBins;
    console.log(trueScale);
    if (trueScale) {
      const maxHeight = 600;
      const containerWidth = canvas.parentElement.clientWidth;
      const scaleX = containerWidth / framesTotal;
      const scaleY = maxHeight / freqBins;
      const scale = Math.min(scaleX, scaleY, 1);
      
      canvas.style.width = (canvas.width * scale) + "px";
      canvas.style.height = (canvas.height * scale) + "px";
    } else {
      canvas.style.width = "100%";
      canvas.style.height = "500px";
    }
    
    overlayCanvas.style.width = canvas.style.width;
    overlayCanvas.style.height = canvas.style.height;

    specWidth = canvas.width;
    specHeight = canvas.height;
    
    syncOverlaySize();

    // update timeline canvas pixel width so coordinates match
    const timeline = document.getElementById('timeline');
    timeline.width = window.innerWidth*1.2;
    timeline.style.width = canvas.style.width;
    timeline.height = 20;

    // allocate image buffer and numeric arrays
    imageBuffer = ctx.createImageData(canvas.width, canvas.height);
    mags = new Float32Array(specWidth * specHeight);
    phases = new Float32Array(specWidth * specHeight);
    for(let i=0;i<specWidth*specHeight;i++){ mags[i]=0; phases[i]=0; }

    pos = 0; x = 0; rendering = true;
    // clear visual canvas
    ctx.fillStyle = "black";
    ctx.fillRect(0,0,canvas.width,canvas.height);
    
    startTime = performance.now();
    audioProcessed = 0;
    // stop any playing audio but keep pausedAtSample as-is
    stopSource(true);
    requestAnimationFrame(drawLoop);
}

// --- Convert mag+phase to RGB (HSV-like) ---
function magPhaseToRGB(mag, phase){
    // phase -> hue, mag scaled by 60 (v = mag/60 clipped)
    const h = (phase / (2*Math.PI) + 1) % 1; // normalize 0..1
    const s = 1;
    const v = Math.min(mag/60,1);
    const c = v*s;
    const m = v - c;
    const hp = h*6;
    const x = c*(1-Math.abs(hp%2-1));
    let r=0,g=0,b=0;
    if(hp < 1){ r=c; g=x; b=0; }
    else if(hp < 2){ r=x; g=c; b=0; }
    else if(hp < 3){ r=0; g=c; b=x; }
    else if(hp < 4){ r=0; g=x; b=c; }
    else if(hp < 5){ r=x; g=0; b=c; }
    else { r=c; g=0; b=x; }
    return [Math.floor((r+m)*255), Math.floor((g+m)*255), Math.floor((b+m)*255)];
}

// Convert displayed RGB back to numeric mag/phase (kept for completeness)
function rgbToMagPhase(r, g, b) {
    let rf=r/255,gf=g/255,bf=b/255;
    const mx=Math.max(rf,gf,bf), mn=Math.min(rf,gf,bf);
    const d=mx-mn;
    let h=0,s=0,v=mx;
    s=mx===0?0:d/mx;
    if(d!==0){
        if(mx===rf) h=((gf-bf)/d)%6;
        else if(mx===gf) h=(bf-rf)/d+2;
        else h=(rf-gf)/d+4;
        h/=6; if(h<0) h+=1;
    }
    const phase=h*2*Math.PI;
    const mag=v*60;
    return [mag, phase];
}

// ---------- Log-scale mapping helpers ----------
function getLogScaleSlider() { return Math.max(1, parseFloat(logscaleEl.value) || 1); }

function binToDisplayY(bin, h) {
    if (!h) return 0;
    const s = getLogScaleSlider();
    if (s <= 1.0000001) {
        return Math.round(h - 1 - bin); // linear invert so bin 0 -> bottom
    } else {
        const a = s - 1;
        const denom = Math.log(1 + a * (h - 1));
        if (!isFinite(denom) || denom === 0) return Math.round(h - 1 - bin);
        const t = Math.log(1 + a * bin) / denom; // 0..1 where 0 => bin=0 bottom, 1 => bin=h-1 top
        const y = (1 - t) * (h - 1);
        return Math.round(y);
    }
}

function displayYToBin(y, h) {
    if (!h) return 0;
    const s = getLogScaleSlider();
    if (s <= 1.0000001) {
        return Math.max(0, Math.min(h - 1, Math.round(h - 1 - y)));
    } else {
        const a = s - 1;
        const denom = Math.log(1 + a * (h - 1));
        if (!isFinite(denom) || denom === 0) return Math.max(0, Math.min(h - 1, Math.round(h - 1 - y)));
        const t = 1 - (y / (h - 1));
        const raw = (Math.exp(t * denom) - 1) / a;
        const clamped = Math.max(0, Math.min(h - 1, Math.round(raw)));
        return clamped;
    }
}

// ---------- Draw spectrogram (compute FFT frames and store numeric spectrogram) ----------
function drawLoop() {
    if (!rendering) return;
    // cap per-tick to avoid blocking—adaptive based on canvas width
    const framesPerTick = Math.min(200, Math.max(4, Math.floor(specWidth/8)));

    const h = specHeight;
    const w = specWidth;

    for (let f = 0; f < framesPerTick; f++) {
        if (pos + fftSize > pcm.length) { rendering = false; break; }

        // prepare re/im arrays for fft_inplace
        const re = new Float32Array(fftSize);
        const im = new Float32Array(fftSize);
        for (let i = 0; i < fftSize; i++) { re[i] = (pcm[pos + i] || 0) * win[i]; im[i] = 0; }
        fft_inplace(re, im);

        // fill numeric mags/phases for every FFT bin (0..h-1)
        for (let bin = 0; bin < h; bin++) {
            const mag = Math.hypot(re[bin] || 0, im[bin] || 0);
            const phase = Math.atan2(im[bin] || 0, re[bin] || 0);
            const idx = x * h + bin; // column-major
            mags[idx] = mag;
            phases[idx] = phase;
        }

        // now map numeric bins to display rows using the mapping functions
        for (let yy = 0; yy < h; yy++) {
            const mappedBin = displayYToBin(yy, h);
            const idx = x * h + mappedBin;
            const mag = mags[idx] || 0;
            const phase = phases[idx] || 0;
            const [r, g, b] = magPhaseToRGB(mag, phase);
            const pix = (yy * w + x) * 4; // row-major imageBuffer
            imageBuffer.data[pix]     = r;
            imageBuffer.data[pix + 1] = g;
            imageBuffer.data[pix + 2] = b;
            imageBuffer.data[pix + 3] = 255;
        }

        pos += hop; x++;
        audioProcessed += hop;
        if (x >= w) { rendering = false; 
            if (!painting) playPCM(true);
            break;
        }
    }

    ctx.putImageData(imageBuffer, 0, 0);
    drawCursor();
    const elapsedMS = performance.now() - startTime;
    const elapsedSec = elapsedMS / 1000;
    const speed = audioProcessed / Math.max(1e-6, elapsedSec); // samples/sec
    const audioSec = pcm.length / 44100; // total audio duration approx
    const processedSec = audioProcessed / 44100;

    status.textContent = `Progress: ${(100*pos/pcm.length).toFixed(1)}% | ` 
        + `Elapsed: ${elapsedSec.toFixed(2)}s | `
        + `Audio processed: ${processedSec.toFixed(2)}/${audioSec.toFixed(2)}s | `
        + `Speed: ${(speed/44100).toFixed(2)}x realtime`;
    if (rendering) requestAnimationFrame(drawLoop);
}

function drawCursor(){
    // Draw green cursor line on top of current spectrogram image
    overlayCtx.putImageData(imageBuffer, 0, 0);
    overlayCtx.strokeStyle = "#0f0";
    overlayCtx.lineWidth = Math.max(1, Math.min(4, framesTotal/500));
    overlayCtx.beginPath();
    overlayCtx.moveTo(currentCursorX + 0.5, 0);
    overlayCtx.lineTo(currentCursorX + 0.5, specHeight);
    overlayCtx.stroke();
}

// --- Painting ---
let painting=false;
let paintedPixels=null;

let startX = 0; startY = 0;

function getCanvasCoords(e){
    const rect=canvas.getBoundingClientRect();
    const scaleX=canvas.width/rect.width;
    const scaleY=canvas.height/rect.height;
    return {cx:(e.clientX-rect.left)*scaleX, cy:(e.clientY-rect.top)*scaleY, scaleX, scaleY};
}

// helper to keep overlay sized when spectrogram sizes change
function syncOverlaySize() {
  overlayCanvas.width = canvas.width;
  overlayCanvas.style.width = canvas.style.width;
  overlayCanvas.height = canvas.height;
  // ensure CSS height still matches the visible canvas height
  overlayCanvas.style.height = canvas.style.height;
}

// rAF-throttled overlay preview
let pendingPreview = false;
let lastPreviewCoords = null;

function previewShape(cx, cy) {
  // store last coords and schedule a single rAF draw
  lastPreviewCoords = { cx, cy };
  if (pendingPreview) return;
  pendingPreview = true;
  requestAnimationFrame(() => {
    pendingPreview = false;
    const coords = lastPreviewCoords;
    overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

    // visible stroke style
    overlayCtx.strokeStyle = "#fff";
    overlayCtx.lineWidth = Math.max(1, Math.min(4, Math.floor(framesTotal / 500)));

    if (currentTool === "rectangle" && startX !== null && startY !== null) {
      overlayCtx.strokeRect(startX + 0.5, startY + 0.5, coords.cx - startX, coords.cy - startY);
    } else if (currentTool === "line" && startX !== null && startY !== null) {
      overlayCtx.beginPath();
      overlayCtx.moveTo(startX + 0.5, startY + 0.5);
      overlayCtx.lineTo(coords.cx + 0.5, coords.cy + 0.5);
      overlayCtx.stroke();
    }
  });
}

// commit rectangle/line to spectrogram data (fixed: integer indices + Bresenham for line)
function commitShape(cx, cy) {
    const w = canvas.width, h = canvas.height;
    const bo = brushOpacity;
    const po = phaseOpacity;
    const brushMag = (brushColor / 255) * 128;
    const brushPhase = penPhase;

    function drawPixelInt(xx, yy, mag, phase, bo, po) {
        const xI = Math.round(xx);
        const yI = Math.round(yy);
        if (xI < 0 || xI >= w || yI < 0 || yI >= h) return;
        const bin = displayYToBin(yI, specHeight);
        const idx = xI * specHeight + bin;
        if (idx < 0 || idx >= mags.length) return;
        const oldMag = mags[idx] || 0;
        const oldPhase = phases[idx] || 0;
        const newMag = oldMag * (1 - bo) + mag * bo;
        const newPhase = oldPhase + po * (phase - oldPhase);
        mags[idx] = newMag;
        phases[idx] = newPhase;
        const displayY = binToDisplayY(bin, specHeight);
        const pix = (displayY * w + xI) * 4;
        const [r, g, b] = magPhaseToRGB(newMag, newPhase);
        imageBuffer.data[pix] = r;
        imageBuffer.data[pix + 1] = g;
        imageBuffer.data[pix + 2] = b;
        imageBuffer.data[pix + 3] = 255;
    }

    if (currentTool === "rectangle") {
        const minX = Math.max(0, Math.floor(Math.min(startX, cx)));
        const maxX = Math.min(w - 1, Math.ceil(Math.max(startX, cx)));
        const minY = Math.max(0, Math.floor(Math.min(startY, cy)));
        const maxY = Math.min(h - 1, Math.ceil(Math.max(startY, cy)));
        for (let yy = minY; yy <= maxY; yy++) {
            for (let xx = minX; xx <= maxX; xx++) {
                drawPixelInt(xx, yy, brushMag, brushPhase, bo, po);
            }
        }
    } else if (currentTool === "line") {
        // Bresenham integer line so we visit exact pixel coords
        let x0 = Math.round(startX), y0 = Math.round(startY);
        const x1 = Math.round(cx), y1 = Math.round(cy);
        const dx = Math.abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
        const dy = Math.abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
        let err = (dx > dy ? dx : -dy) / 2;
        while (true) {
            drawPixelInt(x0, y0, brushMag, brushPhase, bo, po);
            if (x0 === x1 && y0 === y1) break;
            const e2 = err;
            if (e2 > -dx) { err -= dy; x0 += sx; }
            if (e2 < dy)  { err += dx; y0 += sy; }
        }
    }

    ctx.putImageData(imageBuffer, 0, 0);
}

function paint(cx, cy, scaleX, scaleY, startX, startY) {
    if (!mags || !phases) return;
    const w = canvas.width, h = canvas.height;
    const po = currentTool === "eraser" ? 1 : phaseOpacity;
    const bo = currentTool === "eraser" ? 1 : brushOpacity;

    function drawPixel(xx, yy, mag, phase, bo, po, save) {
        const bin = displayYToBin(yy, specHeight);
        const idx = xx * specHeight + bin;
        if(idx < 0 || idx >= mags.length) return;
        const oldMag = mags[idx] || 0;
        const oldPhase = phases[idx] || 0;
        const newMag = oldMag * (1 - bo) + mag * bo;
        let newPhase = oldPhase + po*(phase-oldPhase);
        mags[idx] = newMag;
        phases[idx] = newPhase;
        const displayY = binToDisplayY(bin, specHeight);
        const pix = (displayY * w + xx) * 4;
        const [r,g,b] = magPhaseToRGB(newMag, newPhase);
        imageBuffer.data[pix] = r;
        imageBuffer.data[pix+1] = g;
        imageBuffer.data[pix+2] = b;
        imageBuffer.data[pix+3] = 255;
    }

    if(currentTool === "brush" || currentTool === "eraser") {
        const radiusX = brushSize / (scaleY/scaleX || 1);
        const radiusY = brushSize;
        const minX = Math.max(0, Math.floor(cx - radiusX));
        const maxX = Math.min(w-1, Math.ceil(cx + radiusX));
        const minY = Math.max(0, Math.floor(cy - radiusY));
        const maxY = Math.min(h-1, Math.ceil(cy + radiusY));
        const brushMag = currentTool === "eraser" ? 0 : (brushColor/255)*128;
        const brushPhase = currentTool === "eraser" ? 0 : penPhase;
        for(let yy=minY; yy<=maxY; yy++){
            for(let xx=minX; xx<=maxX; xx++){
                const dx=xx-cx, dy=yy-cy;
                if((dx*dx)/(radiusX*radiusX)+(dy*dy)/(radiusY*radiusY)>1) continue;
                drawPixel(xx, yy, brushMag, brushPhase, bo, po, true);
            }
        }
    } else if(currentTool === "blur") {
        const radius = brushSize;
        const minX = Math.max(0, Math.floor(cx - radius));
        const maxX = Math.min(w-1, Math.ceil(cx + radius));
        const minY = Math.max(0, Math.floor(cy - radius));
        const maxY = Math.min(h-1, Math.ceil(cy + radius));
        for(let yy=minY; yy<=maxY; yy++){
            for(let xx=minX; xx<=maxX; xx++){
                const idx = xx*specHeight+displayYToBin(yy, specHeight);
                if(idx<0||idx>=mags.length) continue;
                // simple 3x3 blur
                let sumMag=0, sumPhase=0, count=0;
                for(let oy=-1;oy<=1;oy++){
                    for(let ox=-1;ox<=1;ox++){
                        const nx=xx+ox, ny=yy+oy;
                        if(nx<0||ny<0||nx>=w||ny>=h) continue;
                        const nidx = nx*specHeight+displayYToBin(ny,specHeight);
                        sumMag += mags[nidx]||0;
                        sumPhase += phases[nidx]||0;
                        count++;
                    }
                }
                drawPixel(xx, yy, sumMag/count, sumPhase/count, bo, po, true);
            }
        }
    } else if(currentTool === "image" && overlayImage) {
        // scale overlay to brush size
        const scale = brushSize / Math.max(overlayImage.width, overlayImage.height) * fftSize/400; // largest dimension = brushSize
        const overlayW = Math.max(1, Math.round(overlayImage.width * scale));
        const overlayH = Math.max(1, Math.round(overlayImage.height * scale));
        const ox = Math.floor(cx - overlayW / 2);
        const oy = Math.floor(cy - overlayH / 2);
    
        const tempCanvas = document.createElement("canvas");
        tempCanvas.width = overlayW;
        tempCanvas.height = overlayH;
        const tctx = tempCanvas.getContext("2d");
        tctx.drawImage(overlayImage, 0, 0, overlayW, overlayH);
        const imgData = tctx.getImageData(0, 0, overlayW, overlayH);
    
        for (let yy = 0; yy < overlayH; yy++) {
            for (let xx = 0; xx < overlayW; xx++) {
                const pix = (yy * overlayW + xx) * 4;
                const r = imgData.data[pix];
                const g = imgData.data[pix + 1];
                const b = imgData.data[pix + 2];
                const [mag, phase] = rgbToMagPhase(r, g, b);
    
                const cxPix = ox + xx;
                const cyPix = oy + yy;
                if (cxPix >= 0 && cyPix >= 0 && cxPix < w && cyPix < h) {
                    drawPixel(cxPix, cyPix, mag, phase, brushOpacity, phaseOpacity);
                }
            }
        }
    }

    ctx.putImageData(imageBuffer,0,0);
}


// Merge painting and audio/frame handlers so we don't duplicate mousedown/mouseup logic
let sineOsc = null;
let sineGain = null;
function setSineFreq(cy) {
    const h = specHeight;
    const s = parseFloat(logscaleEl.value); // 1..2 slider

    let bin;
    if (s <= 1.0000001) {
        // linear mapping
        bin = h - 1 - cy;
    } else {
        // non-linear logscale mapping (invert of binToDisplayY)
        const a = s - 1;
        const denom = Math.log(1 + a * (h - 1));
        const t = 1 - cy / (h - 1);
        bin = (Math.exp(t * denom) - 1) / a;
    }

    // clamp bin
    bin = Math.max(0, Math.min(h - 1, bin));

    // convert bin to frequency
    const freq = bin * sampleRate / fftSize;

    // set sine oscillator frequency
    sineOsc.frequency.setTargetAtTime(freq, audioCtx.currentTime, 0.01);
}

canvas.addEventListener("mousedown", e=>{
    if (!mags || !phases) return;
    painting = true;
    stopSource();
    paintedPixels = new Set();
    const {cx,cy,scaleX,scaleY} = getCanvasCoords(e);
    startX = cx; startY = cy;
    overlayCtx.clearRect(0,0,overlayCanvas.width, overlayCanvas.height);
     
    if (!(currentTool === "rectangle" || currentTool === "line")) {
        paint(cx,cy,scaleX,scaleY,startX,startY);
    }
    
    // audio: play current frame while mouse is down
    ensureAudioCtx();
    mouseDown = true;
    currentFrame = Math.floor(cx);
    playFrame(currentFrame);

    // also start sine oscillator
    if (!sineOsc) {
        sineOsc = audioCtx.createOscillator();
        sineOsc.type = "sine";
        sineGain = audioCtx.createGain();
        sineGain.gain.value = 0.2;
        sineOsc.connect(sineGain).connect(audioCtx.destination);
        setSineFreq(cy);
        sineOsc.start();
    }
});

canvas.addEventListener("mousemove", e=>{
    if(!painting) return;
    const {cx,cy,scaleX,scaleY} = getCanvasCoords(e);
    
    if (currentTool === "rectangle" || currentTool === "line") {
      previewShape(cx, cy);
    } else {
      overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
      paint(cx,cy,scaleX,scaleY,startX,startY);
    }

    currentFrame = Math.floor(cx);
    if (mouseDown) {
        playFrame(currentFrame);

        // update sine frequency based on Y
        if (sineOsc) setSineFreq(cy);
    }
    
    currentCursorX = currentFrame;
    drawCursor();
});

document.addEventListener("mouseup", e => {
    if (!mags || !phases || !painting) return;

    painting = false;
    paintedPixels = null;
    mouseDown = false;
    stopSource();
    if (sineOsc) {
        sineOsc.stop();
        sineOsc.disconnect();
        sineOsc = null;
        sineGain = null;
    }
    if (!pcm) { 
        playPCM(); 
        return; 
    }
    const { cx, cy } = getCanvasCoords(e);
    if (currentTool === "rectangle" || currentTool === "line") {
        commitShape(cx, cy); // write to mags/phases
        overlayCtx.clearRect(0,0,overlayCanvas.width,overlayCanvas.height);
    }
    
    startX=startY=null;

    const newPCM = new Float32Array(pcm.length);
    const overlapCount = new Float32Array(pcm.length);
    const window = new Float32Array(fftSize);
    for (let i = 0; i < fftSize; i++) window[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (fftSize - 1)));

    const h = specHeight;
    const w = specWidth;

    // For reconstruction we must iterate each FFT bin (0..h-1) and use mags at that bin.
    for (let xCol = 0; xCol < w; xCol++) {
        const re = new Float32Array(fftSize);
        const im = new Float32Array(fftSize);

        for (let bin = 0; bin < h; bin++) {
            const idx = xCol * h + bin;
            let mag = mags[idx] || 0;
            const phase = phases[idx] || 0;

            re[bin] = mag * Math.cos(phase);
            im[bin] = mag * Math.sin(phase);

            // symmetric conjugate for real signal
            if (bin > 0 && bin < fftSize / 2) {
                const sym = fftSize - bin;
                re[sym] = re[bin];
                im[sym] = -im[bin];
            }
        }

        ifft_inplace(re, im);

        for (let i = 0; i < fftSize; i++) {
            const posPCM = xCol * hop + i;
            if (posPCM >= pcm.length) break;

            newPCM[posPCM] += re[i] * window[i];
            overlapCount[posPCM] += window[i] * window[i];
        }
    }

    // Normalize overlap-add
    for (let i = 0; i < pcm.length; i++) {
        if (overlapCount[i] > 0) newPCM[i] /= overlapCount[i];
    }

    pcm.set(newPCM);
    pos = 0;
    x = 0;
    rendering = true;
    requestAnimationFrame(drawLoop);
    
    startTime = performance.now();
    audioProcessed = 0;

    playPCM();
    console.log("PCM updated from phase-aware spectrogram!");
});

// Audio playback
let sourceNode = null;
let playing = false;
let mouseDown = false;
let currentFrame = 0; // frame under mouse when painting
let pausedAtSample = null; // sample index where playback is paused (null = not paused / play from start)
let sourceStartTime = 0; // audioCtx time when current source started adjusted to account for offset
let wasPlayingDuringDrag = false;

initEmptyPCM();

function updateCursorLoop() {
    if (playing && !painting && pcm && sourceNode) {
        const elapsed = audioCtx.currentTime - sourceStartTime; // seconds since conceptual 'zero' of source
        let samplePos = elapsed * sampleRate;

        if (sourceNode.loop) {
            samplePos = samplePos % pcm.length; // wrap if looping
        }

        const frame = Math.floor(samplePos / hop);
        currentCursorX = Math.min(frame, specWidth - 1);

        // redraw spectrogram + cursor
        ctx.putImageData(imageBuffer, 0, 0);
        drawCursor();
    }
    requestAnimationFrame(updateCursorLoop);
}
updateCursorLoop();

function stopSource(preservePaused=false){
    if(sourceNode){
        try { sourceNode.stop(); } catch(e) { /*ignore*/ }
        try { sourceNode.disconnect(); } catch(e) { /*ignore*/ }
        sourceNode = null;
    }
    // If preservePaused==false we clear pausedAtSample (stop -> reset)
    if (!preservePaused) pausedAtSample = null;
    playing = false;
}

// Play entire PCM from optional startFrame (frame index). If startFrame omitted and pausedAtSample exists, resume from it.
function playPCM(loop = true, startFrame = null) {
    if (!pcm) return;
    ensureAudioCtx();
    stopSource(true);

    // decide start sample
    let startSample = 0;
    if (startFrame !== null && !isNaN(startFrame)) {
        startSample = Math.max(0, Math.min(pcm.length - 1, startFrame * hop));
    } else if (pausedAtSample !== null) {
        startSample = Math.max(0, Math.min(pcm.length - 1, pausedAtSample));
    } else {
        startSample = 0;
    }

    sourceNode = audioCtx.createBufferSource();
    const buffer = audioCtx.createBuffer(1, pcm.length, sampleRate);
    buffer.copyToChannel(pcm, 0);
    sourceNode.buffer = buffer;
    sourceNode.loop = !!loop;
    sourceNode.connect(audioCtx.destination);

    // Start playback from offset (in seconds). Use start(when, offset).
    const offsetSec = startSample / sampleRate;
    // For correct position calculations we treat sourceStartTime as the conceptual "time zero" meaning:
    // audioCtx.currentTime - sourceStartTime = elapsedSecondsFromBufferStart
    // So set sourceStartTime = audioCtx.currentTime - offsetSec
    sourceStartTime = audioCtx.currentTime - offsetSec;
    try {
        sourceNode.start(0, offsetSec);
    } catch (e) {
        // fallback: if requested offset too close to end, create a truncated buffer
        const remaining = pcm.length - startSample;
        const shortBuf = audioCtx.createBuffer(1, Math.max(1, remaining), sampleRate);
        shortBuf.copyToChannel(pcm.subarray(startSample, startSample + remaining), 0);
        sourceNode.stop();
        sourceNode.disconnect();
        sourceNode = audioCtx.createBufferSource();
        sourceNode.buffer = shortBuf;
        sourceNode.loop = !!loop;
        sourceNode.connect(audioCtx.destination);
        sourceStartTime = audioCtx.currentTime;
        sourceNode.start();
    }

    playing = true;
    pausedAtSample = null; // we are playing now
}

// Function to play only a single frame (used during painting preview)
function playFrame(frameX) {
    currentCursorX = frameX;
    if (!pcm) return;
    ensureAudioCtx();
    stopSource(true);
    const start = frameX * hop;
    const end = Math.min(start + fftSize, pcm.length);
    if (end <= start) return;
    const frameLen = end - start;

    const buffer = audioCtx.createBuffer(1, frameLen, sampleRate);
    buffer.copyToChannel(pcm.subarray(start, end), 0);

    sourceNode = audioCtx.createBufferSource();
    sourceNode.buffer = buffer;
    sourceNode.loop = true; // loop the frame while mouse is down
    sourceNode.connect(audioCtx.destination);
    sourceStartTime = audioCtx.currentTime - (start / sampleRate);
    sourceNode.start();
    playing = true;
    pausedAtSample = null;
}

// Utility: convert current entire spectrogram to imageBuffer
function renderFullSpectrogramToImage() {
    if (!imageBuffer || !mags || !phases) return;
    const w = specWidth, h = specHeight;
    for(let xx=0; xx<w; xx++){
        // numeric bins 0..h-1 are stored in mags for each column
        for(let yy=0; yy<h; yy++){
            // map display row yy -> numeric bin (so visual arrangement respects logscale)
            const bin = displayYToBin(yy, h);
            const idx = xx * h + bin;
            const mag = mags[idx] || 0;
            const phase = phases[idx] || 0;
            const [r,g,b] = magPhaseToRGB(mag, phase);
            const pix = (yy * w + xx) * 4;
            imageBuffer.data[pix] = r;
            imageBuffer.data[pix+1] = g;
            imageBuffer.data[pix+2] = b;
            imageBuffer.data[pix+3] = 255;
        }
    }
    ctx.putImageData(imageBuffer, 0, 0);
}

// Float -> 16-bit helpers and WAV download
function floatTo16BitPCM(float32Array) {
    const buffer = new ArrayBuffer(float32Array.length * 2);
    const view = new DataView(buffer);
    for (let i = 0; i < float32Array.length; i++) {
        let s = Math.max(-1, Math.min(1, float32Array[i]));
        view.setInt16(i * 2, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
    }
    return view;
}

function writeWavHeader(view, sampleRate, numSamples) {
    const blockAlign = 2; // 16-bit mono
    const byteRate = sampleRate * blockAlign;

    function writeString(view, offset, str) {
        for (let i = 0; i < str.length; i++) view.setUint8(offset + i, str.charCodeAt(i));
    }

    writeString(view, 0, 'RIFF');
    view.setUint32(4, 36 + numSamples * 2, true);
    writeString(view, 8, 'WAVE');
    writeString(view, 12, 'fmt ');
    view.setUint32(16, 16, true);       // PCM chunk size
    view.setUint16(20, 1, true);        // PCM format
    view.setUint16(22, 1, true);        // channels
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, byteRate, true);
    view.setUint16(32, blockAlign, true);
    view.setUint16(34, 16, true);       // bits per sample
    writeString(view, 36, 'data');
    view.setUint32(40, numSamples * 2, true);
}

document.getElementById('downloadWav').addEventListener('click', () => {
    if (!pcm) return alert('No PCM loaded!');
    const numSamples = pcm.length;
    const buffer = new ArrayBuffer(44 + numSamples * 2);
    const view = new DataView(buffer);

    writeWavHeader(view, sampleRate, numSamples);

    const pcm16 = floatTo16BitPCM(pcm);
    for (let i = 0; i < pcm16.byteLength; i++) {
        view.setUint8(44 + i, pcm16.getUint8(i));
    }

    const blob = new Blob([view], { type: 'audio/wav' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'output.wav';
    a.click();
    URL.revokeObjectURL(url);
});
document.getElementById('downloadButton').addEventListener('click', function() {
            // Convert canvas to data URL (PNG format)
            let canvasUrl = canvas.toDataURL('image/png');

            // Create a temporary anchor element
            const downloadLink = document.createElement('a');

            // Set href and download attributes
            downloadLink.href = canvasUrl;
            downloadLink.download = 'my-drawing.png';

            // Simulate a click to trigger download
            downloadLink.click();

            // Clean up the temporary anchor element
            downloadLink.remove();
        });

// TIMELINE
const timeline = document.getElementById('timeline');
const tctx = timeline.getContext('2d');

let timelineWidth = timeline.width; // match main canvas width
let timelineHeight = timeline.height = 20;
let timelineCursorX = 0;
let draggingTimeline = false;

// Draw timeline background and cursor
function drawTimeline() {
    tctx.clearRect(0, 0, timeline.width, timeline.height);

    // Timeline background
    tctx.fillStyle = "#333";
    tctx.fillRect(0, 0, timeline.width, timeline.height);

    const ts = 20; // triangle size
    const tx = timelineCursorX * timeline.width / framesTotal;

    // Draw cursor triangle (upside-down)
    tctx.fillStyle = "#0f0";
    tctx.beginPath();
    tctx.moveTo(tx, ts);
    tctx.lineTo(tx - ts/4, 0);
    tctx.lineTo(tx + ts/4, 0);
    tctx.closePath();
    tctx.fill();

    // Draw time labels
    if (!pcm) return;
    const totalSeconds = pcm.length / sampleRate;

    // Determine a “nice” interval for time markers
    let interval = 0.01; // default to 0.01s
    if (totalSeconds > 0.3) interval = 0.1;
    if (totalSeconds > 1) interval = 0.3;
    if (totalSeconds > 3) interval = 1;
    if (totalSeconds > 10) interval = 3;
    if (totalSeconds > 30) interval = 10;
    if (totalSeconds > 100) interval = 30;

    tctx.fillStyle = "#eee";
    tctx.font = "20px sans-serif";
    tctx.textAlign = "center";
    tctx.textBaseline = "top";

    for (let t = 0; t <= totalSeconds; t += interval) {
        const markerX = t / totalSeconds * timeline.width;
        tctx.fillText(t.toFixed(interval < 1 ? 2 : interval < 10 ? 1 : 0), markerX, 1);
    }
}

// Convert mouse X (clientX-left) to frame
function timelineXToFrame(clientXLeft) {
    const rect = timeline.getBoundingClientRect();
    return clientXLeft/rect.width*framesTotal;
}

// Drag handling
timeline.addEventListener("mousedown", e => {
    const rect = timeline.getBoundingClientRect();
    draggingTimeline = true;
    wasPlayingDuringDrag = playing;
    // stop audio while dragging but preserve paused offset
    stopSource(true);
    timelineCursorX = timelineXToFrame(e.clientX - rect.left);
    // reflect immediate visual change
    currentCursorX = timelineCursorX;
    drawTimeline();
    drawCursor();
});
window.addEventListener("mousemove", e => {
    if (!draggingTimeline) return;
    const rect = timeline.getBoundingClientRect();
    timelineCursorX = timelineXToFrame(e.clientX - rect.left);
    currentCursorX = timelineCursorX;
    drawTimeline();
    drawCursor();
});
window.addEventListener("mouseup", e => {
    if (!draggingTimeline) return;
    draggingTimeline = false;
    const frame = timelineCursorX;
    // set pausedAtSample to this frame's sample index so position is tracked
    pausedAtSample = frame * hop;

    // if playback was running before drag, resume from selected frame
    if (wasPlayingDuringDrag) {
        playPCM(true, frame);
        document.getElementById("playPause").textContent = "Pause";
    } else {
        // not playing: just update visuals (do not auto-play)
        ctx.putImageData(imageBuffer, 0, 0);
        drawCursor();
    }
    drawTimeline();
});

// Play/pause buttons
const playPauseBtn = document.getElementById("playPause");
const stopBtn = document.getElementById("stop");

playPauseBtn.addEventListener("click", () => {
    ensureAudioCtx();
    if (playing) {
        // Pause: calculate current sample position and stop source but keep pausedAtSample
        const elapsed = audioCtx.currentTime - sourceStartTime;
        let samplePos = Math.floor(elapsed * sampleRate);
        if (sourceNode && sourceNode.loop) {
            samplePos = samplePos % pcm.length;
        }
        pausedAtSample = Math.max(0, Math.min(pcm.length - 1, samplePos));
        stopSource(true);
        playPauseBtn.textContent = "Play";
    } else {
        // Start/resume: start from pausedAtSample if present, else start at 0
        const startFrame = (pausedAtSample !== null) ? Math.floor(pausedAtSample / hop) : 0;
        playPCM(true, startFrame);
        playPauseBtn.textContent = "Pause";
    }
});

stopBtn.addEventListener("click", () => {
    stopSource(false); // clear pausedAtSample (reset)
    timelineCursorX = 0;
    currentCursorX = 0;
    drawTimeline();
    ctx.putImageData(imageBuffer, 0, 0);
    drawCursor();
    playPauseBtn.textContent = "Play";
});

// Update timeline cursor based on playback
function updateTimelineCursor() {
    if (playing && !draggingTimeline && pcm && sourceNode) {
        const elapsed = audioCtx.currentTime - sourceStartTime;
        let samplePos = elapsed * sampleRate;

        if (sourceNode.loop) {
            samplePos = samplePos % pcm.length;
        }

        const frame = Math.floor(samplePos / hop);
        timelineCursorX = Math.min(frame, specWidth-1);
        currentCursorX = timelineCursorX;
        drawTimeline();
        drawCursor();
    }
    requestAnimationFrame(updateTimelineCursor);
}
updateTimelineCursor();

// initial draw
drawTimeline();
renderFullSpectrogramToImage();
</script>
</body>
</html>
