<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>SpectroDraw - Interactive spectrogram editor</title>
  <link rel="stylesheet" type="text/css" href="style.css">
  <link rel="icon" href="/favicon32x32.ico"/>
</head>
<body>
  <!-- New page layout -->
<div class="app">
  <header class="top-bar">
    <a href="/" id="home" title="Home" style="margin-left:10px;"><img src="/favicon32x32.ico" style="background:transparent;"></a>
    <button id="fileB" title="Upload Audio" style="margin-left: 10px">
      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20" fill="none" stroke="#333" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
        <line x1="10" y1="16" x2="10" y2="6" />
        <polyline points="6 10 10 6 14 10" />
        <line x1="4" y1="16" x2="16" y2="16" />
      </svg>
    </button>
    <button id="rec" title="Record">
      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="2 5 19 19" fill="none" stroke="#333" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M8 15a4 4 0 0 0 8 0" />
        <rect x="10" y="7" width="4" height="8" rx="2" ry="2" fill="black"/>
        <line x1="12" y1="18" x2="12" y2="17"/>
        <line x1="9" y1="21" x2="15" y2="21"/>
      </svg>
    </button>
    <input id="file" type="file" accept="audio/*,video/*" style="display:none;"/>
    <button id="playPause" title="play" style="margin-left: 20px">
      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="#333" viewBox="9 8 16 16"><path d="M16 0 M14 22V10l8 6z"/></svg>
    </button>
    <button id="stop" title="stop">
      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="#333" viewBox="0 0 20 20">
        <rect x="0" y="0" width="18" height="18" rx="2" ry="2"/>
      </svg>
    </button>
    <button class="tool-btn" data-tool="brush" style="margin-left: 20px" title="Brush">
      <svg xmlns="http://www.w3.org/2000/svg" 
           width="20" height="20" 
           viewBox="5 4 18 18" 
           fill="black">
        <path d="M20.71 4.63a2 2 0 0 0-2.83 0l-9.9 9.9a3 3 0 0 0-.78 1.37l-.69 2.76a1 1 0 0 0 1.21 1.21l2.76-.69a3 3 0 0 0 1.37-.78l9.9-9.9a2 2 0 0 0 0-2.83zm-11.24 11.3l-.88.22.22-.88 9.19-9.19.66.66z"/>
      </svg>
    </button>
    <button class="tool-btn" data-tool="rectangle" title="Rectangle">
      <svg xmlns="http://www.w3.org/2000/svg" 
           width="20" height="20" viewBox="0 0 20 20" 
           fill="none"
           stroke = "black" stroke-width = "5">
        <path d="M0 0 H 20 V 20 H 0 V -20"/>
      </svg>
    </button>
    <button class="tool-btn" data-tool="line" title="Line">
      <svg xmlns="http://www.w3.org/2000/svg" 
           width="20" height="20" viewBox="0 0 20 20" 
           fill="none"
           stroke = "black" stroke-width = "3">
        <path d="M20 0 L 0 20"/>
      </svg>
    </button>
    <button class="tool-btn" data-tool="blur" title="Blur">
      <svg xmlns="http://www.w3.org/2000/svg" 
           width="24" height="24" 
           viewBox="0 0 24 24" 
           fill="black">
        <path d="M12 2C12 2 7 10 7 14a5 5 0 0 0 10 0c0-4-5-12-5-12z"/>
      </svg>
    </button>
    <button class="tool-btn" data-tool="eraser" title="Eraser">
      <svg width="20" height="20" viewBox="-1 -1 16 16">
        <path d="M5,0 L0,5 L5,10 L10,5 Z " fill="#333" stroke="#333" stroke-width="1"/>
        <path d="M5,10 L10,5 L15,10 L12,13 L8,13 Z" fill="white" stroke="#333" stroke-width="1"/>
      </svg>
    </button>
    <button class="tool-btn" data-tool="amplifier" title="Amplifier / Reducer">
      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20" fill="none">
        <path d="M2 8V12C2 12.55 2.45 13 3 13H5L7 17C7.18 17.36 7.56 17.59 7.95 17.59C8.63 17.59 9.08 16.86 8.79 16.25L7.2 13H9L16 17V3L9 7H5V7H3C2.45 7 2 7.45 2 8Z" fill="#333"/>
        <path d="M18 7C18.55 7 19 7.45 19 8V12C19 12.55 18.55 13 18 13" stroke="#333" stroke-width="1.2" stroke-linecap="round"/>
    </svg>
    </button>
    <button class="tool-btn" data-tool="image" title="Image Overlay">
      <svg width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="#333" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="18" cy="6" r="3" fill="#333" stroke="none"/>
        <polygon points="1,20 8,10 15,20" fill="#333"/>
        <polygon points="8,20 15,12 23,20" fill="#333"/>
      </svg>
    </button>
    <input type="file" id="overlayFile" accept="image/*" style="display:none;">
    <button id="trueScale" title="Use true aspect ratio" style="margin-left: 20px">
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" aria-hidden="true" role="img">
        <title>Enter fullscreen</title>
        <g fill="none" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M3 9V3h6" />
          <path d="M15 3h6v6" />
          <path d="M3 15v6h6" />
          <path d="M21 15v6h-6" />
        </g>
      </svg>
    </button>
    <button id="yAxisMode" title="Toggle Y axis label mode">
      <svg xmlns="http://www.w3.org/2000/svg" 
         width="28" height="28" viewBox="0 0 20 20" 
         fill="none" stroke="black" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
        <text x="0" y="18" font-size="8" fill="black" stroke-width="0.5">1.0k</text>
        <text x="10" y="6" font-size="8" fill="black" stroke-width="0.5">a5</text>
        <line x1="4" y1="4" x2="18" y2="14" />
      </svg>
    </button>
     <button id="downloadWav" style="margin-left:20px" title="Download audio">
      <svg width="20" height="20" viewBox="2 2 20 21" fill="none" stroke="#333" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M4 14v-2a8 8 0 0 1 16 0v2" />
        <path d="M5 14v4h2v-4H6z" />
        <path d="M17 14v4h2v-4h-2z" />
        <path d="M12 12v10" />
        <path d="M9 19l3 3 3 -3" />
      </svg>
    </button>
    <button id="downloadButton" title="Download spectrogram">
      <svg width="20" height="20" viewBox="2 2 20 21" fill="none" stroke="#333" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <rect x="3" y="3" width="18" height="14" rx="2" ry="2" />
        <circle cx="17" cy="7" r="2" />
        <polyline points="3 17 10 10 14 14 21 7" />
        <path d="M12 12v10" />
        <path d="M9 19l3 3 3 -3" />
      </svg>
    </button>
    <button id="resetButton" onClick="initEmptyPCM()" title="Reset audio">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#333" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <rect x="5" y="7" width="14" height="14" rx="2" ry="2" />
        <line x1="8" x2="8" y1="11" y2 = "17" stroke-width="1"/>
        <line x1="12" x2="12" y1="11" y2 = "17" stroke-width="1"/>
        <line x1="16" x2="16" y1="11" y2 = "17" stroke-width="1"/>
        <rect x="3" y="4" width="18" height="3" rx="2" ry="2" />
        <rect x="8" y="1" width="8" height="2" rx="2" ry="2" stroke-width="1"/>
      </svg>
    </button>
    <button id="undoBtn" title="Undo (Ctrl+Z)">
      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M9 14H5V10"/>
        <path d="M20 20a9 9 0 0 0-15-6.7L5 10"/>
      </svg>
    </button>
    <button id="redoBtn" title="Redo (Ctrl+Y)">
      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M15 14h4v-4"/>
        <path d="M4 20a9 9 0 0 1 15-6.7L19 10"/>
      </svg>
    </button>
  </header>

  <aside class="left-panel">
    <div style="border:1px solid #888; padding: 4px;"><label id="mouseInfo">Pitch: 0hz<br>Time: 0.0<br>Loudness: -inf dB</label><br></div>
    <label class="h1">Spectrogram properties</label>
    <div class= "slider-row">
      <label class="h2" title="An exponent of 2, height of spectrogram in pixels.">Pitch resolution:</label>
      <input id="fftSize" type="number" value="11" step="1" min="6" max="14" style="margin-left: 102px;">
    </div>
    <div class= "slider-row">
      <label class="h2" title="Number of audio samples given to each frame (x pixel).">Time resolution:</label>
      <input id="hopSize" type="number" value="1024" step="1" min="1" style="margin-left: 102px;">
    </div>
    <label class="h1">Preset audio (Reset audio to apply)<br>
    </label>
    <label class="h2" for="presets">Use presets</label>
    <select id="presets">
      <option value="silence">Silence</option>
      <option value="male">Male sing</option>
      <option value="female">Female sing</option>
      <option value="dog">Dog</option>
      <option value="birdChirp">Bird chirp</option>
      <option value="lionRoar">Lion roar</option>
      <option value="seaLion">Sea lion</option>
      <option value="violin">Violin</option>
      <option value="trumpet">Trumpet</option>
      <option value="timpani">Timpani</option>
      <option value="piano">Piano</option>
      <option value="flute">Flute</option>
      <option value="cymbal">Cymbal</option>
      <option value="computerBeeps">Computer beeps</option>
      <option value="scream">Scream</option>
      <option value="bomb">Bomb</option>
      <option value="engine">Engine</option>
      <option value="fullSpectra">Loud noise</option>
      <option value="bass808">808 bass</option>
      <option value="cave14">Cave14.ogg</option>
      <option value="sine">Sine wave</option>
      <option value="triangle">Triangle wave</option>
      <option value="square">Square wave</option>
      <option value="saw">Saw wave</option>
    </select>
    <div id ="es" class="slider-row" title="Empty audio seconds">
      <label class="h2">Empty audio seconds</label>
      <input id="emptyAudioLength" type="range" min="0.01" max="100" step="0.01" value="10">
      <input id="emptyAudioLengthInput" type="number" value="10" min="0.01" max="100">
    </div>
    <div id="ev" class="slider-row" title="Background phase">
      <label class="h2" for="phaseType">Background phase</label>
      <select id="phaseType">
        <option value="Static">Static</option>
        <option value="Slow sine">Slow sine</option>
        <option value="Fast sine">Fast sine</option>
        <option value="Empty">Empty</option>
      </select>
    </div>
    <label class="h1">Brush settings</label>
    <canvas id="strokePreview" width="300" height="100" style="border:1px solid #ccc; display:block; margin-top:10px;"></canvas>
    <div class="slider-row" title="Brush size/image size" id="sliderStart">
      <label class="h2">Brush Size</label>
      <input id="brushSize" type="range" min="1" max="200" value="40">
      <input id="brushSizeInput" type="number" value="40" min="1" max="200">
    </div>
    <div class="slider-row" title="Brightness">
        <label class="h2">Brush Brightness</label>
        <input id="brushColor"  type="range" min="0" max="255" value="255">
        <input id="brushColorInput" type="number" value="255" min="0" max="255">
    </div>
    <div class="slider-row" title="Phase">
        <label class="h2">Brush Phase</label>
        <input id="penPhase"  type="range" min="0" max="3.1415" value="0" step="0.0001">
        <input id="penPhaseInput" type="number" value="0" min="0" max="3.1415">
    </div>
    <div class="slider-row" title="Brightness strength">
        <label class="h2">Brush Opacity</label>
        <input id="brushOpacity"  type="range" min="0" max="100" value="100">
        <input id="brushOpacityInput" type="number" value="100" min="0" max="100">
    </div>
    <div class="slider-row" title="Phase strength">
        <label class="h2">Phase Opacity</label>
        <input id="phaseOpacity"  type="range" min="0" max="100" value="0">
        <input id="phaseOpacityInput" type="number" value="0" min="0" max="100">
    </div> 
  
  </aside>

  <main class="main-area">
    <!-- paste your canvas wrapper here -->
    <div id="canvasWrapper" style="position:absolute; width:100%;">
      <canvas id="timeline" style="height:40px; background:#222; position: absolute;left:40px;z-index: 9998; top:0px"></canvas>
      <canvas id="canvas" style="cursor:crosshair; position: absolute; left: 40px; top:40px"></canvas>
      <canvas id="overlay" style="background: transparent; position:absolute; left:40px; pointer-events:none; z-index:10;; top:40px"></canvas>
      <canvas id="freq" style="width:40px; background:#222; position:absolute; left:0; ; top:40px"></canvas>
      <canvas id="logscale" width=40 height = 40 style="position:absolute; top:0px; background: #111;z-index: 99999; top:0px"></canvas>
    </div>
  </main>
</div>

<div id="status" style="position:absolute;bottom:0px;"></div>
<script>
  function syncNumberAndRange(numberInput, rangeInput) {
    // Update range when number changes
    numberInput.addEventListener('input', () => {
      let val = parseInt(numberInput.value);
      if (val < rangeInput.min) val = rangeInput.min;
      if (val > rangeInput.max) val = rangeInput.max;
      rangeInput.value = val;
      numberInput.value = val; // clamp value
    });

    // Update number when range changes
    rangeInput.addEventListener('input', () => {
      numberInput.value = rangeInput.value;
    });
  }

  const sliders = [[document.getElementById('emptyAudioLength'), document.getElementById('emptyAudioLengthInput')],
                   [document.getElementById('brushSize'), document.getElementById('brushSizeInput')],
                   [document.getElementById('brushColor'), document.getElementById('brushColorInput')],
                   [document.getElementById('penPhase'), document.getElementById('penPhaseInput')],
                   [document.getElementById('brushOpacity'), document.getElementById('brushOpacityInput')],
                   [document.getElementById('phaseOpacity'), document.getElementById('phaseOpacityInput')]];
  sliders.forEach(pair => syncNumberAndRange(pair[1], pair[0]));
</script>
<script src="fft.js"></script>
<script>

const fileEl=document.getElementById("file");
const canvas=document.getElementById("canvas");
const ctx=canvas.getContext("2d");
const overlayCanvas = document.getElementById("overlay");
const overlayCtx = overlayCanvas.getContext("2d");
const status=document.getElementById("status");
const fftSizeEl=document.getElementById("fftSize");
const hopSizeEl=document.getElementById("hopSize");
const brushSizeEl=document.getElementById("brushSize");
const brushOpacityEl=document.getElementById("brushOpacity");
const phaseOpacityEl=document.getElementById("phaseOpacity");
const brushColorEl=document.getElementById("brushColor");
const penPhaseEl=document.getElementById("penPhase");
const logscaleEl = document.getElementById("logscale");
const emptyAudioLengthEl = document.getElementById("emptyAudioLength");
const phaseTypeEl = document.getElementById("phaseType");
const recordBtn = document.getElementById("rec");
const preset = document.getElementById("presets");
const es = document.getElementById("es");
const ev = document.getElementById("ev");
const yAxis=document.getElementById("freq");
const yctx=yAxis.getContext("2d");
const yAxisMode=document.getElementById("yAxisMode");
const info = document.getElementById("mouseInfo");
const WORKLET_CODE = `
class RecorderProcessor extends AudioWorkletProcessor {
  process(inputs) {
    const input = inputs[0];
    if (input && input[0] && input[0].length > 0) {
      const chunk = new Float32Array(input[0].length);
      chunk.set(input[0]);

      this.port.postMessage(chunk, [chunk.buffer]);
    }
    return true;
  }
}
registerProcessor('recorder-processor', RecorderProcessor);
`;
const toolButtons = document.querySelectorAll(".tool-btn");
const trueScale = document.getElementById("trueScale");
const overlayFile = document.getElementById("overlayFile");

const historyStack = []; const redoStack = [];
const MAX_HISTORY_ENTRIES = 80;

let pcm=null, sampleRate=48000, pos=0, fftSize=1024, hop=512, win=hann(1024);
let framesTotal=0, x=0, rendering=false;
let imageBuffer=null;
let visited = null;
let currentCursorX = 0;
let iLow = null;
let iHigh = null;
let fLow = null;
let fHigh = null;
let specCanvas = document.createElement("canvas");
let specCtx = specCanvas.getContext("2d");
let logScaleVal = 1.12;

let mags = null;     
let phases = null;   
let specWidth = 0;
let specHeight = 0;
let pcmChunks = null;
let trueScaleVal=false;
let overlayImage = null;
let useHz = false;
let autoPlayOnFinish = true;

let startX = null, startY = null;
let cx_ = null, cy_ = null;

let brushSize=parseInt(brushSizeEl.value);
let brushOpacity=parseInt(brushOpacityEl.value)/100;
let phaseOpacity=parseInt(phaseOpacityEl.value)/100;
let brushColor=parseInt(brushColorEl.value); 
let penPhase=parseInt(penPhaseEl.value)/10000;
let currentTool = "brush";
brushSizeEl.addEventListener("input",()=>{brushSize=parseInt(brushSizeEl.value); updateBrushPreview();});
brushOpacityEl.addEventListener("input",()=>{brushOpacity=parseInt(brushOpacityEl.value)/100; updateBrushPreview();});
phaseOpacityEl.addEventListener("input",()=>{phaseOpacity=parseInt(phaseOpacityEl.value)/100; updateBrushPreview();});
brushColorEl.addEventListener("input",()=>{brushColor=parseInt(brushColorEl.value); updateBrushPreview();});
penPhaseEl.addEventListener("input", ()=>{penPhase = parseFloat(penPhaseEl.value); updateBrushPreview();});
sliders[1][1].addEventListener("input",()=>{brushSize=parseInt(   sliders[1][1].value); updateBrushPreview();});
sliders[4][1].addEventListener("input",()=>{brushOpacity=parseInt(sliders[4][1].value)/100; updateBrushPreview();});
sliders[5][1].addEventListener("input",()=>{phaseOpacity=parseInt(sliders[5][1].value)/100; updateBrushPreview();});
sliders[2][1].addEventListener("input",()=>{brushColor=parseInt(  sliders[2][1].value); updateBrushPreview();});
sliders[3][1].addEventListener("input", ()=>{penPhase = parseFloat( sliders[3][1].value); updateBrushPreview();});


function angleDiff(a, b) {
  const d = a - b;
  return Math.atan2(Math.sin(d), Math.cos(d));
}
function pushHistory(entry, clearRedo = true) {
  while (historyStack.length >= MAX_HISTORY_ENTRIES) historyStack.shift();
  historyStack.push(entry);
  if (clearRedo) redoStack.length = 0;
}

toolButtons.forEach(btn => {
  if(btn.dataset.tool === currentTool) {
    btn.style.background = "#4af"; 
  }
});
toolButtons.forEach(btn => {
  btn.addEventListener("click", () => {
    currentTool = btn.dataset.tool;
    toolButtons.forEach(b => b.style.background = "");
    btn.style.background = "#4af"; 
    if(currentTool === "image") overlayFile.click();
    updateBrushPreview();
  });
});
fileB.addEventListener("click", () => {
  file.click();
});
trueScale.addEventListener("click", () => {
    trueScaleVal = !trueScaleVal;
    trueScale.style.background = trueScaleVal?"#4af":"#f3f3f3";
    restartRender(false);
  });
yAxisMode.addEventListener("click", () => {
        useHz = !useHz;
        yAxisMode.style.background = useHz ? "#4af" : "#f3f3f3";
        drawYAxis();
      });

overlayFile.addEventListener("change", e => {
  const f = e.target.files[0];
  if (!f) return;
  const img = new Image();
  img.onload = () => {overlayImage = img; updateBrushPreview();}
  img.src = URL.createObjectURL(f);
});

</script>
<script src="axes.js"></script>
<script>

function initEmptyPCM() {
    const sampleRateLocal = 48000;
    const duration = emptyAudioLengthEl.value; 
    const type = phaseTypeEl.value;
    const length = sampleRateLocal * duration; 
    const tinyNoiseAmplitude = 0.0001; 

    const pcmArray = new Float32Array(length);
    for (let i = 0; i < length; i++) {
      // console.log((5*Math.sin(i/100)+5))
      if (type === "Slow sine") pcmArray[i] = Math.sin(i / 1) * tinyNoiseAmplitude;
      else if (type === "Fast sine") pcmArray[i] = Math.sin(i / 1000) * tinyNoiseAmplitude;
      else if (type === "Static") pcmArray[i] = (Math.random() * 2 - 1) * tinyNoiseAmplitude;
      else if (type === "Empty")  pcmArray[i] = 0;
    }

    pcm = pcmArray;
    sampleRate = sampleRateLocal;

    iLow = null;
    restartRender(false);
}
function drawLogScale() {
  const lctx = logscaleEl.getContext("2d");

  const w = 40, h = 40;
  lctx.clearRect(0, 0, w, h);

  lctx.beginPath();
  const steps = 40;
  for (let i = 0; i <= steps; i++) {
    const x = i / steps;              
    const y = 1-Math.pow(0-(x-1), Math.pow(logScaleVal,2)); 
    const px = x * w;                 
    const py = h - y * h;             
    if (i === 0) lctx.moveTo(px, py);
    else lctx.lineTo(px, py);
  }
  lctx.strokeStyle = "white";
  lctx.lineWidth = 3;
  lctx.stroke();
}
let changingLogScale = false;
function getMouseXY(e,touch) {
  if (touch) {
    return [e.touches[0].clientX, e.touches[0].clientY];
  } else {
    return [e.clientX, e.clientY];
  }
}
logscaleEl.addEventListener("mousedown", e=> {
  console.log("mouse",e);
  logScaleMouseDown(e,false);
});
logscaleEl.addEventListener("touchstart", e=> {
  console.log("touch",e);
  logScaleMouseDown(e.true);
});
function logScaleMouseDown(e,touch) {
  const rect= logscaleEl.getBoundingClientRect();
  changingLogScale = true;
  [startX, startY] = getMouseXY(e,touch);
  renderFullSpectrogramToImage();
  drawLogScale();
}
logscaleEl.addEventListener("mousedown", e=> {
  console.log("mouse",e);
  logScaleMouseDown(e,false);
});
logscaleEl.addEventListener("touchstart", e=> {
  console.log("touch",e);
  logScaleMouseDown(e,true);
});

function logScaleMouseMove(e,touch) {
  logscaleEl.style.cursor = "n-resize";
  if (!changingLogScale) return;
  const rect= logscaleEl.getBoundingClientRect();
  logScaleVal -= (getMouseXY(e,touch)[1] - startY - (getMouseXY(e,touch)[0] - startX))/400;
  if (logScaleVal < 1) logScaleVal = 1;
  if (logScaleVal > 2) logScaleVal = 2;
  [startX, startY] = getMouseXY(e,touch);
  renderFullSpectrogramToImage();
  drawLogScale();
  drawYAxis();
}

document.addEventListener("mousemove", e=> {
  logScaleMouseMove(e,false);
});
document.addEventListener("touchmove", e=> {
  logScaleMouseMove(e,true);
});

logscaleEl.addEventListener("mousemove", e=> {
  logscaleEl.title = "Log scale: " + logScaleVal;
});

document.addEventListener("mouseup", e=>{changingLogScale=false;})
document.addEventListener("touchend", e=>{changingLogScale=false;})

emptyAudioLengthEl.addEventListener("input", ()=> {
  initEmptyPCM();

  if (typeof drawTimeline === 'function') drawTimeline();
  else console.warn("drawTimeline not available yet");

  if (typeof drawLogScale === 'function') drawLogScale();
  else console.warn("drawLogScale not available yet");

  if (typeof drawYAxis === 'function') drawYAxis();
  else console.warn("drawYAxis not available yet");

  iLow = 0;
  iHigh = framesTotal;
});
phaseTypeEl.addEventListener("input", ()=> {
  initEmptyPCM();
});

let recording = false;
let mediaStream = null;
let mediaSource = null;
let processor = null;
let workletNode = null;

function countdown(seconds) {
  return new Promise(resolve => {
    let remaining = seconds;
    function tick() {
      status.textContent = `Recording starts in ${remaining}...`;
      if (remaining === 0) {
        resolve();
      } else {
        remaining--;
        setTimeout(tick, 1000);
      }
    }
    tick();
  });
}

async function startRecording() {  
  ensureAudioCtx();
  fHigh = sampleRate/2;
  fWidth = fHigh;

  stopSource();
  const beep = new Audio("beep.mp3");
beep.load();

info.textContent = "Recording in 3";
beep.currentTime = 0; beep.play();
await countdown(1);
if (!recording) return;

info.textContent = "Recording in 2";
beep.currentTime = 0; beep.play();
await countdown(1);
if (!recording) return;

info.textContent = "Recording in 1";
beep.currentTime = 0; beep.play();
await countdown(1);
if (!recording) return;
  info.textContent = "Recording...";
  status.textContent = "Recording...";
  if (!recording) return;
  pcmChunks = [];        
  pcm = new Float32Array(0);
  pos = 0;
  x = 0;
  rendering = false;

  try {
    mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    mediaSource = audioCtx.createMediaStreamSource(mediaStream);

    await audioCtx.resume();
    sampleRate = audioCtx.sampleRate || sampleRate;

    const blob = new Blob([WORKLET_CODE], { type: 'application/javascript' });
    const url = URL.createObjectURL(blob);
    await audioCtx.audioWorklet.addModule(url);

    workletNode = new AudioWorkletNode(audioCtx, 'recorder-processor', {
      numberOfInputs: 1,
      numberOfOutputs: 1,
      outputChannelCount: [1],
      channelCount: 1
    });

    pcmChunks = [];
    pcm = new Float32Array(0);

    workletNode.port.onmessage = (ev) => {
      const chunk = ev.data;
      if (!(chunk instanceof Float32Array)) return;
      pcmChunks.push(chunk);

      let total = 0;
      for (let c of pcmChunks) total += c.length;
      const merged = new Float32Array(total);
      let off = 0;
      for (let c of pcmChunks) { merged.set(c, off); off += c.length; }
      pcm = merged;

      processPendingFramesLive();
      iLow = 0;
      const framesSoFar = Math.max(1, Math.floor((pcm.length - fftSize) / hop) + 1);
      iHigh = Math.max(1000, framesSoFar);
      updateCanvasScroll();
    };

    const silentGain = audioCtx.createGain();
    silentGain.gain.value = 0.0;
    mediaSource.connect(workletNode);
    workletNode.connect(silentGain);
    silentGain.connect(audioCtx.destination);

  } catch (err) {
    console.error("Mic error:", err);
    status.textContent = "Microphone access denied.";
    stopRecording();
  }
}

function stopRecording() {
  recording = false;
  status.textContent = "Recording stopped.";
  info.textContent = "";

  if (processor) {
    processor.disconnect();
    processor.onaudioprocess = null;
    processor = null;
  }
  if (mediaSource) {
    mediaSource.disconnect();
    mediaSource = null;
  }
  if (mediaStream) {
    mediaStream.getTracks().forEach(t => t.stop());
    mediaStream = null;
  }

  if (pcm && Array.isArray(pcm)) {
    let length = pcm.reduce((sum, arr) => sum + arr.length, 0);
    let merged = new Float32Array(length);
    let offset = 0;
    for (let chunk of pcm) {
      merged.set(chunk, offset);
      offset += chunk.length;
    }
    pcm = merged;
  }
  iLow = null;
  pcmChunks = null;

    let t = pcm.length / sampleRate;
    hopSizeEl.value = t<0.5?128:(t<5?512:1024);
  restartRender(true);
    
}

recordBtn.addEventListener("click", async () => {
  if (!recording) {
    recording = true;
    await startRecording();
  } else {
    stopRecording();
  }
});

let audioCtx = null;
function ensureAudioCtx(){
  if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  sampleRate = audioCtx.sampleRate || sampleRate;
}

let startTime=0; 
let audioProcessed=0; 

fileEl.addEventListener("change", async e=>{
    const f=e.target.files[0]; if(!f)return;
    const buf=await f.arrayBuffer();
    ensureAudioCtx();
    fHigh = sampleRate/2;
    fWidth = fHigh;
    let ab;
    try {
      ab = await audioCtx.decodeAudioData(buf.slice(0));
      pcm = new Float32Array(ab.getChannelData(0));
      sampleRate = ab.sampleRate || 48000;

      status.textContent=`Loaded ${f.name}, ${pcm.length} samples @ ${sampleRate} Hz`;
      status.style.display = "block";
      restartRender(true);
      
    let t = pcm.length / sampleRate;
    hopSizeEl.value = t<0.5?128:(t<5?512:1024);
      iLow = 0;
      iHigh = framesTotal;

    } catch (err){
      alert("Error decoding video. Please try a different video.");
    }
});
preset.addEventListener("change", async (e) => {
  const val = e.target.value;

  if (val === "silence") {
    initEmptyPCM();
    return;
  }

  const presetMap = {
    dog: "presets/dog.wav",
    flute: "presets/flute.wav",
    trumpet: "presets/trumpet.wav",
    bomb: "presets/bomb.wav",
    male: "presets/male.wav",
    female: "presets/female.wav",
    birdChirp: "presets/birdChirp.mp3",
    lionRoar: "presets/lionRoar.wav",
    seaLion: "presets/seaLion.mp3",
    violin: "presets/violin.mp3",
    timpani: "presets/timpani.wav",
    piano: "presets/piano.ogg",
    cymbal: "presets/cymbal.wav",
    computerBeeps: "presets/computerBeeps.mp3",
    scream: "presets/scream.mp3",
    engine: "presets/engine.mp3",
    fullSpectra: "presets/fullSpectra.wav",
    bass808: "presets/808bass.wav",
    cave14: "presets/cave14.oga",
    sine: "presets/sine.wav",
    triangle: "presets/triangle.mp3",
    square: "presets/square.mp3",
    saw: "presets/saw.mp3"
  };

  const url = presetMap[val];
  if (!url) {
    console.warn("No URL defined for preset:", val);
    return;
  }

  try {
    status.textContent = `Loading preset "${val}"…`;
    ensureAudioCtx(); 

    const resp = await fetch(url);
    if (!resp.ok) throw new Error(`Failed to fetch ${url}: ${resp.status}`);

    const ab = await resp.arrayBuffer();

    const decoded = await audioCtx.decodeAudioData(ab.slice(0));

    pcm = new Float32Array(decoded.getChannelData(0));
    sampleRate = decoded.sampleRate || sampleRate;

    status.textContent = `Loaded preset "${val}", ${pcm.length} samples @ ${sampleRate} Hz`;
    let t = pcm.length / sampleRate;
    hopSizeEl.value = t<0.5?128:(t<5?512:1024);
    restartRender(true);
    iLow = 0;
    iHigh = framesTotal;

  } catch (err) {
    console.error("Preset load error:", err);
    status.textContent = "Error loading preset: " + (err.message || err);
  }
});
fftSizeEl.addEventListener("change",restartRender);
hopSizeEl.addEventListener("change",restartRender);

function restartRender(autoPlay){
    if(!pcm) return;
    autoPlayOnFinish = !!playing || !!autoPlay;
    const exponent = Math.max(6, Math.min(14, parseInt(fftSizeEl.value)||10));
    fftSize = 1 << exponent;
    hop = Math.max(1, parseInt(hopSizeEl.value) || Math.floor(fftSize/2));
    win = hann(fftSize);

    framesTotal = Math.max(1, Math.floor((pcm.length - fftSize) / hop) + 1);
    if (iLow == null || iHigh > framesTotal) {
      iLow = 0;
      iHigh = framesTotal;
    }

    const freqBins = Math.floor(fftSize / 2);
    canvas.width = framesTotal;
    canvas.height = freqBins;
    if (trueScaleVal) {
      const maxHeight = 600;
      const containerWidth = canvas.parentElement.clientWidth;
      const scaleX = containerWidth / framesTotal;
      const scaleY = maxHeight / freqBins;
      const scale = Math.min(scaleX, scaleY, 1);

      canvas.style.width = (canvas.width * scale) + "px";
      canvas.style.height = (canvas.height * scale) + "px";
    } else {
      canvas.style.width = "calc(100% - 40px)";
      let h = window.innerHeight - 110;
      canvas.style.height = h+"px";
    }

    overlayCanvas.style.width = canvas.style.width;
    overlayCanvas.style.height = canvas.style.height;
    yAxis.height = 1024;
    yAxis.style.height = canvas.style.height;
    yAxis.width = 40;
    yAxis.style.height = canvas.style.height;

    specWidth = canvas.width;
    specHeight = canvas.height;

    syncOverlaySize();

    const timeline = document.getElementById('timeline');
    timeline.width = window.innerWidth*1.2;
    timeline.style.width = canvas.style.width;
    timeline.height = 40;

    imageBuffer = new ImageData(canvas.width, canvas.height);
    specWidth = canvas.width;
    specHeight = canvas.height;

    specCanvas.width = specWidth;
    specCanvas.height = specHeight;
    specCtx.clearRect(0, 0, specCanvas.width, specCanvas.height);
    specCtx.putImageData(imageBuffer, 0, 0);

    mags = new Float32Array(specWidth * specHeight);
    phases = new Float32Array(specWidth * specHeight);
    for(let i=0;i<specWidth*specHeight;i++){ mags[i]=0; phases[i]=0; }

    const startFrame = Math.max(0, Math.floor(iLow || 0));
    pos = startFrame * hop;
    x = startFrame;
    rendering = true;

    ctx.fillStyle = "black";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    startTime = performance.now();
    audioProcessed = 0;

    if (playing) stopSource(true);
    requestAnimationFrame(drawLoop);

    if (!autoPlay) {
        if (typeof drawTimeline === 'function') drawTimeline();
        else console.warn("drawTimeline() not defined yet — will run once axes.js loads");

        if (typeof drawYAxis === 'function') drawYAxis();
        else console.warn("drawYAxis() not defined yet — will run once axes.js loads");

        if (typeof drawLogScale === 'function') drawLogScale();
    }
}

function magPhaseToRGB(mag, phase){
    const h = (phase / (2*Math.PI) + 1) % 1; 
    const s = 1;
    const v = Math.min(mag/60,1);
    const c = v*s;
    const m = v - c;
    const hp = h*6;
    const x = c*(1-Math.abs(hp%2-1));
    let r=0,g=0,b=0;
    if(hp < 1){ r=c; g=x; b=0; }
    else if(hp < 2){ r=x; g=c; b=0; }
    else if(hp < 3){ r=0; g=c; b=x; }
    else if(hp < 4){ r=0; g=x; b=c; }
    else if(hp < 5){ r=x; g=0; b=c; }
    else { r=c; g=0; b=x; }
    return [Math.floor((r+m)*255), Math.floor((g+m)*255), Math.floor((b+m)*255)];
}

function rgbToMagPhase(r, g, b) {
    let rf=r/255,gf=g/255,bf=b/255;
    const mx=Math.max(rf,gf,bf), mn=Math.min(rf,gf,bf);
    const d=mx-mn;
    let h=0,s=0,v=mx;
    s=mx===0?0:d/mx;
    if(d!==0){
        if(mx===rf) h=((gf-bf)/d)%6;
        else if(mx===gf) h=(bf-rf)/d+2;
        else h=(rf-gf)/d+4;
        h/=6; if(h<0) h+=1;
    }
    const phase=h*2*Math.PI;
    const mag=v*60;
    return [mag, phase];
}

function getLogScaleSlider() { return Math.max(1, parseFloat(logScaleVal) || 1); }

function binToDisplayY(bin, h) {
    if (!h) return 0;
    const s = getLogScaleSlider();
    if (s <= 1.0000001) {
        return Math.round(h - 1 - bin); 
    } else {
        const a = s - 1;
        const denom = Math.log(1 + a * (h - 1));
        if (!isFinite(denom) || denom === 0) return Math.round(h - 1 - bin);
        const t = Math.log(1 + a * bin) / denom; 
        const y = (1 - t) * (h - 1);
        return Math.round(y);
    }
}

function displayYToBin(y, h) {
    if (!h) return 0;
    const s = getLogScaleSlider();
    if (s <= 1.0000001) {
        return Math.max(0, Math.min(h - 1, Math.round(h - 1 - y)));
    } else {
        const a = s - 1;
        const denom = Math.log(1 + a * (h - 1));
        if (!isFinite(denom) || denom === 0) return Math.max(0, Math.min(h - 1, Math.round(h - 1 - y)));
        const t = 1 - (y / (h - 1));
        const raw = (Math.exp(t * denom) - 1) / a;
        const clamped = Math.max(0, Math.min(h - 1, Math.round(raw)));
        return clamped;
    }
}

function drawFrame(w,h) {
    if (pos + fftSize > pcm.length) { rendering = false; status.style.display = "none"; return false; }

    const re = new Float32Array(fftSize);
    const im = new Float32Array(fftSize);
    for (let i = 0; i < fftSize; i++) { re[i] = (pcm[pos + i] || 0) * win[i]; im[i] = 0; }
    fft_inplace(re, im);

    for (let bin = 0; bin < h; bin++) {
        const mag = Math.hypot(re[bin] || 0, im[bin] || 0);
        const phase = Math.atan2(im[bin] || 0, re[bin] || 0);
        const idx = x * h + bin; 
        mags[idx] = mag;
        phases[idx] = phase;
    }

    for (let yy = 0; yy < h; yy++) {
        const mappedBin = displayYToBin(yy, h);
        const idx = x * h + mappedBin;
        const mag = mags[idx] || 0;
        const phase = phases[idx] || 0;
        const [r, g, b] = magPhaseToRGB(mag, phase);
        const pix = (yy * w + x) * 4; 
        imageBuffer.data[pix]     = r;
        imageBuffer.data[pix + 1] = g;
        imageBuffer.data[pix + 2] = b;
        imageBuffer.data[pix + 3] = 255;
    }
    pos += hop; x++;
    audioProcessed += hop;
    if (x >= w) { rendering = false; 
        if (!painting && autoPlayOnFinish) {
            autoPlayOnFinish = false;
            playPCM(true);
        }
        status.style.display = "none";
        return false;
    }
    return true;
}

function drawLoop() {
    if (!rendering) return;

    const framesPerTick = Math.min(200, Math.max(4, Math.floor(specWidth/8)));

    const h = specHeight;
    const w = specWidth;

    for (let f = 0; f < framesPerTick; f++) {
        if (!drawFrame(w,h)) break;
    }

    specCtx.putImageData(imageBuffer, 0, 0);
    renderView();
    drawCursor();
    const elapsedMS = performance.now() - startTime;
    const elapsedSec = elapsedMS / 1000;
    const speed = audioProcessed / Math.max(1e-6, elapsedSec); 
    const audioSec = pcm.length / sampleRate; 
    const processedSec = audioProcessed / sampleRate;
    status.textContent = `Progress: ${(100*pos/pcm.length).toFixed(1)}% | ` 
        + `Elapsed: ${elapsedSec.toFixed(2)}s | `
        + `Audio processed: ${processedSec.toFixed(2)}/${audioSec.toFixed(2)}s | `
        + `Speed: ${(speed/sampleRate).toFixed(2)}x realtime`;
    if (rendering) {
      status.style.display = "block";
      requestAnimationFrame(drawLoop);
    }
}

function drawCursor(){
    const x = (currentCursorX-iLow) * canvas.width / (iHigh-iLow)
    overlayCtx.clearRect(0,0, canvas.width, canvas.height);
    overlayCtx.strokeStyle = "#0f0";
    overlayCtx.lineWidth = iWidth/500;
    overlayCtx.beginPath();
    overlayCtx.moveTo(x + 0.5, 0);
    overlayCtx.lineTo(x + 0.5, specHeight);
    overlayCtx.stroke();
}

function updateCanvasScroll() {
    if (!imageBuffer || !specCanvas) return;

    const viewWidth = Math.max(1, Math.floor(iHigh - iLow));
    const fStart = Math.max(0, Math.floor(specHeight * (1 - fHigh / (sampleRate/2))));
    const fEnd = Math.min(specHeight, Math.floor(specHeight * (1 - fLow / (sampleRate/2))));
    const viewHeight = Math.max(1, fEnd - fStart);

    canvas.width = viewWidth;
    canvas.height = viewHeight;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(
        specCanvas,
        Math.max(0, Math.floor(iLow)), fStart, 
        viewWidth, viewHeight,                 
        0, 0,                                  
        canvas.width, canvas.height            
    );

    overlayCanvas.width = canvas.width;
    overlayCanvas.height = canvas.height;
    overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

    drawCursor();
}

function renderView() {
    if (!specCanvas || !imageBuffer) return;

    const viewWidth = Math.max(1, Math.floor(iHigh - iLow));
    const fStart = Math.max(0, Math.floor(specHeight * (1 - fHigh / (sampleRate/2))));
    const fEnd = Math.min(specHeight, Math.floor(specHeight * (1 - fLow / (sampleRate/2))));
    const viewHeight = Math.max(1, fEnd - fStart);

    canvas.width = viewWidth;
    canvas.height = viewHeight;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(
        specCanvas,
        Math.max(0, Math.floor(iLow)), fStart, 
        viewWidth, viewHeight,                 
        0, 0,                                  
        canvas.width, canvas.height            
    );

    overlayCanvas.width = canvas.width;
    overlayCanvas.height = canvas.height;
    overlayCanvas.style.width = canvas.style.width;
    overlayCanvas.style.height = canvas.style.height;
}

let painting=false;
let paintedPixels=null;

function getCanvasCoords(e,touch){
    const rect=canvas.getBoundingClientRect();
    const scaleX=canvas.width/rect.width;
    const scaleY=canvas.height/rect.height;
    let x; let y;
    if (touch && e.touches.length === 0) {
        x = _cx; y = _cy;
    } else {
        x = touch ? e.touches[0].clientX : e.clientX;
        y = touch ? e.touches[0].clientY : e.clientY;
        _cx = x; _cy = y;
    }
    return {cx:(x-rect.left)*scaleX, cy:(y-rect.top)*scaleY, scaleX, scaleY};
}

</script>
<script src="drawTools.js"></script>
<script>

function hzToNoteName(frequency) {
  if (frequency <= 0) return "0";
  const A4 = 440;
  const A4_MIDI = 69;
  const midi = Math.round(12 * Math.log2(frequency / A4) + A4_MIDI);
  const noteNames = ["C", "C#", "D", "D#", "E", "F", 
                     "F#", "G", "G#", "A", "A#", "B"];
  const note = noteNames[(midi+1200) % 12];
  const octave = Math.floor(midi / 12) - 1;
  const ret = `${note}${octave}`;
  return ret;
}
let sineOsc = null;
let sineGain = null;
function getSineFreq(cy) {
    const h = specHeight;
    const s = parseFloat(logScaleVal); 
    let bin;
    if (s <= 1.0000001) {
        bin = h - 1 - cy;
    } else {
        const a = s - 1;
        const denom = Math.log(1 + a * (h - 1));
        const t = 1 - cy / (h - 1);
        bin = (Math.exp(t * denom) - 1) / a;
    }
    bin = Math.max(0, Math.min(h - 1, bin));
    return bin * sampleRate / fftSize;
}
function setSineFreq(cy) {
    sineOsc.frequency.setTargetAtTime(getSineFreq(cy), audioCtx.currentTime, 0.01);
}
function visibleToSpecY(visY) {
    const fStart = Math.max(0, Math.floor(specHeight * (1 - fHigh / (sampleRate/2))));
    const fullY = Math.round(visY + fStart);
    return Math.max(0, Math.min(specHeight - 1, fullY));
}
let snapshotMags = null;
let snapshotPhases = null;

function canvasMouseDown(e,touch) {
    if (!mags || !phases) return;

    painting = true;

    snapshotMags = new Float32Array(mags);
    snapshotPhases = new Float32Array(phases);

    visited = new Uint8Array(mags.length);
    stopSource();
    paintedPixels = new Set();
    const {cx,cy,scaleX,scaleY} = getCanvasCoords(e,touch);
    startX = cx; startY = cy;
    overlayCtx.clearRect(0,0,overlayCanvas.width, overlayCanvas.height);
    const realY = visibleToSpecY(cy);
    if (!(currentTool === "rectangle" || currentTool === "line")) {
        paint(cx + iLow, realY, scaleX, scaleY, startX, startY);
    }
    ensureAudioCtx();
    mouseDown = true;
    currentFrame = Math.floor(cx);
    playFrame(currentFrame);

    if (!sineOsc) {
        sineOsc = audioCtx.createOscillator();
        sineOsc.type = "sine";
        sineGain = audioCtx.createGain();
        sineGain.gain.value = 0.2;
        sineOsc.connect(sineGain).connect(audioCtx.destination);
        setSineFreq(realY); 
        sineOsc.start();
    }
}
canvas.addEventListener("mousedown", e=>{
    canvasMouseDown(e,false);
});
canvas.addEventListener("touchstart", e=>{
    canvasMouseDown(e,true);
});

function canvasMouseMove(e,touch) {
    const {cx,cy,scaleX,scaleY} = getCanvasCoords(e,touch);
    if (!recording) {
    const hz = getSineFreq(visibleToSpecY(cy)).toFixed(0);
    const secs = Math.floor(cx/(sampleRate/hopSizeEl.value)*10000)/10000;
    const i = Math.floor(cx*specHeight+hz/(sampleRate/fftSize));
    let normalizedMag = Math.min(1, mags[i] / 256);
    let db = (20 * Math.log10(normalizedMag + 1e-12)).toFixed(1);
    info.innerHTML=`Pitch: ${hz}hz (${hzToNoteName(hz)}) <br>Time: ${secs}<br>Loudness: ${db}db`
    }
    if (!painting && currentTool === "brush" || currentTool === "eraser" || currentTool === "blur" || currentTool === "amplifier") {
        previewShape(cx, cy);
    }
    if(!painting && currentTool != "image") return;

    if (currentTool === "rectangle" || currentTool === "line" || currentTool === "image") {
        previewShape(cx, cy);
    } else {
        overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
        const realY = visibleToSpecY(cy);
        paint(cx + iLow, realY, scaleX, scaleY, startX, startY);
    }

    currentFrame = Math.floor(cx);
    if (mouseDown) {
        playFrame(currentFrame);
        if (sineOsc) setSineFreq( visibleToSpecY(cy) ); 
    }

    currentCursorX = currentFrame;
    drawCursor();
}
canvas.addEventListener("mousemove", e=>{
    canvasMouseMove(e,false);
});
canvas.addEventListener("touchmove", e=>{
    canvasMouseMove(e,true);
});

</script>
<script src="undoredo.js"></script>
<script>
function canvasMouseUp(e,touch) {
  if (!mags || !phases || !painting) return;
    visited = null;
    painting = false;
    paintedPixels = null;
    mouseDown = false;
    stopSource();
    if (sineOsc) {
        sineOsc.stop();
        sineOsc.disconnect();
        sineOsc = null;
        sineGain = null;
    }
    const { cx, cy } = getCanvasCoords(e,touch);
    if (currentTool === "rectangle" || currentTool === "line") {
        commitShape(cx, cy); 
        overlayCtx.clearRect(0,0,overlayCanvas.width,overlayCanvas.height);
    }

    startX=startY=null;

    if (snapshotMags && snapshotPhases && mags && phases) {
    const epsMag = 1e-6;         
    const epsPhase = 1e-3;       

    const changedIdxs = [];
    const prevMags = [];
    const prevPhases = [];

    const h = specHeight;
    const total = mags.length; 

    for (let idx = 0; idx < total; idx++) {
      const oldM = snapshotMags[idx] || 0;
      const newM = mags[idx] || 0;
      if (Math.abs(oldM - newM) > epsMag) {
        changedIdxs.push(idx);
        prevMags.push(oldM);
        prevPhases.push(snapshotPhases[idx] || 0);
        continue;
      }

      const oldP = snapshotPhases[idx] || 0;
      const newP = phases[idx] || 0;
      if (Math.abs(angleDiff(oldP, newP)) > epsPhase) {
        changedIdxs.push(idx);
        prevMags.push(oldM);
        prevPhases.push(oldP);
      }
    }

    if (changedIdxs.length > 0) {

      let minCol = Infinity, maxCol = -Infinity;
      for (let k = 0; k < changedIdxs.length; k++) {
        const col = Math.floor(changedIdxs[k] / h);
        if (col < minCol) minCol = col;
        if (col > maxCol) maxCol = col;
      }
        if (!isFinite(minCol)) { minCol = 0; maxCol = 0; }

        const indicesArr = new Uint32Array(changedIdxs);
        const prevMagsArr = new Float32Array(prevMags);
        const prevPhasesArr = new Float32Array(prevPhases);

        pushHistory({
            type: 'paint',
            indices: indicesArr,
            prevMags: prevMagsArr,
            prevPhases: prevPhasesArr,
            minCol: Math.max(0, minCol),
            maxCol: Math.min(specWidth - 1, maxCol)
        });
    }

    snapshotMags = null;
    snapshotPhases = null;

    const lastEntry = historyStack.length ? historyStack[historyStack.length - 1] : null;
    if (lastEntry) {
      recomputePCMForCols(lastEntry.minCol, lastEntry.maxCol);
    }
  }

    startTime = performance.now();
    audioProcessed = 0;
    playPCM();
    document.getElementById("playPause").innerHTML=pauseHtml;
}

document.addEventListener("mouseup", e => {
    canvasMouseUp(e,false);
});
document.addEventListener("touchend", e => {
    canvasMouseUp(e,true);
});

let sourceNode = null;
let playing = false;
let mouseDown = false;
let currentFrame = 0; 
let pausedAtSample = null; 
let sourceStartTime = 0; 
let wasPlayingDuringDrag = false;

initEmptyPCM();

function updateCursorLoop() {
    if (playing && !painting && pcm && sourceNode) {
        const elapsed = audioCtx.currentTime - sourceStartTime; 
        let samplePos = elapsed * sampleRate;

        if (sourceNode.loop) {
            samplePos = samplePos % pcm.length; 
        }

        const frame = Math.floor(samplePos / hop);
        currentCursorX = Math.min(frame, specWidth - 1);

        specCtx.putImageData(imageBuffer, 0, 0);
        renderView();
        drawCursor();
    }
    requestAnimationFrame(updateCursorLoop);
}
updateCursorLoop();

function stopSource(preservePaused=false){
    if(sourceNode){
        try { sourceNode.stop(); } catch(e) {  }
        try { sourceNode.disconnect(); } catch(e) {  }
        sourceNode = null;
    }

    if (!preservePaused) pausedAtSample = null;
    playing = false;
}

async function playPCM(loop = true, startFrame = null) {
    if (!pcm) return;
    ensureAudioCtx();

    if (audioCtx.state === 'suspended') {
      try { await audioCtx.resume(); } catch (e) { console.warn("audioCtx.resume() failed:", e); }
    }

    stopSource(true);

    let startSample = 0;
    if (startFrame !== null && !isNaN(startFrame)) {
        startSample = Math.max(0, Math.min(pcm.length - 1, startFrame * hop));
    } else if (pausedAtSample !== null) {
        startSample = Math.max(0, Math.min(pcm.length - 1, pausedAtSample));
    } else {
        startSample = 0;
    }

    sourceNode = audioCtx.createBufferSource();
    const buffer = audioCtx.createBuffer(1, pcm.length, sampleRate);
    buffer.copyToChannel(pcm, 0);
    sourceNode.buffer = buffer;
    sourceNode.loop = !!loop;
    sourceNode.connect(audioCtx.destination);

    const offsetSec = startSample / sampleRate;

    sourceStartTime = audioCtx.currentTime - offsetSec;
    try {
        sourceNode.start(0, offsetSec);
    } catch (e) {

        const remaining = pcm.length - startSample;
        const shortBuf = audioCtx.createBuffer(1, Math.max(1, remaining), sampleRate);
        shortBuf.copyToChannel(pcm.subarray(startSample, startSample + remaining), 0);
        try { sourceNode.stop(); } catch(_) {}
        try { sourceNode.disconnect(); } catch(_) {}
        sourceNode = audioCtx.createBufferSource();
        sourceNode.buffer = shortBuf;
        sourceNode.loop = !!loop;
        sourceNode.connect(audioCtx.destination);
        sourceStartTime = audioCtx.currentTime;
        sourceNode.start();
    }

    playing = true;
    pausedAtSample = null;
}

async function playFrame(frameX) {
    currentCursorX = frameX;
    if (!pcm) return;
    ensureAudioCtx();

    if (audioCtx.state === 'suspended') {
      try { await audioCtx.resume(); } catch (e) { console.warn("audioCtx.resume() failed:", e); }
    }

    stopSource(true);
    const start = frameX * hop;
    const end = Math.min(start + fftSize, pcm.length);
    if (end <= start) return;
    const frameLen = end - start;

    const buffer = audioCtx.createBuffer(1, frameLen, sampleRate);
    buffer.copyToChannel(pcm.subarray(start, end), 0);

    sourceNode = audioCtx.createBufferSource();
    sourceNode.buffer = buffer;
    sourceNode.loop = true; 
    sourceNode.connect(audioCtx.destination);
    sourceStartTime = audioCtx.currentTime - (start / sampleRate);
    sourceNode.start();
    playing = true;
    pausedAtSample = null;
}

function renderFullSpectrogramToImage() {
    if (!imageBuffer || !mags || !phases) return;
    const w = specWidth, h = specHeight;
    for(let xx=0; xx<w; xx++){

        for(let yy=0; yy<h; yy++){

            const bin = displayYToBin(yy, h);
            const idx = xx * h + bin;
            const mag = mags[idx] || 0;
            const phase = phases[idx] || 0;
            const [r,g,b] = magPhaseToRGB(mag, phase);
            const pix = (yy * w + xx) * 4;
            imageBuffer.data[pix] = r;
            imageBuffer.data[pix+1] = g;
            imageBuffer.data[pix+2] = b;
            imageBuffer.data[pix+3] = 255;
        }
    }
    specCtx.putImageData(imageBuffer, 0, 0);
    renderView();
}

</script>
<script src="downloads.js"></script>
<script>

function processPendingFramesLive(){

  if (!pcm || !fftSize) return;

  while (pos + fftSize <= pcm.length) {

    if (!drawFrame(specWidth, specHeight)) break;
  }

  if (imageBuffer && specCtx) specCtx.putImageData(imageBuffer, 0, 0);
  renderView();
  drawCursor();
}

function updateBrushPreview() {
  const preview = document.getElementById("strokePreview");
  const pctx = preview.getContext("2d");
  pctx.clearRect(0, 0, preview.width, preview.height);

  const centerX = preview.width / 2;
  const centerY = preview.height / 2;
  const radius = brushSize / 2;
  function th(num) {
    let hex = num.toString(16);
    if (hex.length === 1) {
      hex = '0' + hex;
    }
    return hex;
  }
  function adjustSaturation([r,g,b], factor){
    let avg = Math.max(r,g,b);
    return [r,g,b].map(v => Math.round(avg + (v-avg)*factor));
  }
  let rgb = adjustSaturation(magPhaseToRGB(brushColor/5*brushOpacity, penPhase),phaseOpacity);
  const color = currentTool === "eraser" ? "#000" : "#"+th(rgb[0])+th(rgb[1])+th(rgb[2]);

  if (currentTool === "eraser") {
    pctx.strokeStyle = "#fff";
    pctx.lineWidth = 1;
    pctx.beginPath();
    pctx.arc(centerX, centerY, radius - 1, 0, Math.PI * 2);
    pctx.stroke();
  } else if (currentTool === "blur") {
    let gradient = pctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius*1.5);
    gradient.addColorStop(0, 'white');  // center
    gradient.addColorStop(1, 'black');  // edge
    pctx.fillStyle = gradient;
    pctx.lineWidth = 2;
    pctx.beginPath();
    pctx.arc(centerX, centerY, radius*1.5 - 1, 0, Math.PI * 2);
    pctx.fill();
  } else if (currentTool === "line") {
    pctx.strokeStyle = color;
    pctx.lineWidth = 2;
    pctx.beginPath();
    pctx.moveTo(centerX - 20 , centerY + 20);
    pctx.lineTo(centerX + 20, centerY - 20);
    pctx.stroke();
  } else if (currentTool === "rectangle") {
    pctx.fillStyle = color;
    pctx.beginPath();
    pctx.rect(centerX - 30, centerY - 30, 60, 60);
    pctx.fill();
  } else if (currentTool === "image"){
    console.log(overlayImage);
    if (overlayImage && overlayImage.complete) {
      const maxDim = Math.min(preview.width, preview.height) * 0.8 * (brushSize / 20);
      const aspect = overlayImage.width / overlayImage.height;
      let drawW, drawH;
      if (aspect > 1) {
        drawW = maxDim;
        drawH = maxDim / aspect;
      } else {
        drawH = maxDim;
        drawW = maxDim * aspect;
      }
      const dx = centerX - drawW / 2;
      const dy = centerY - drawH / 2;
      pctx.drawImage(overlayImage, dx, dy, drawW, drawH);
    }
  } else if (currentTool === "amplifier") {
    pctx.font = "12px Arial";
    pctx.fillStyle = brushColor.toString(16).padStart(2,'0')+"0000";
    pctx.fillText((((brushColor / 255) * 128)/64 * brushOpacity).toFixed(1)+"x", centerX-10, centerY+5);
    pctx.strokeStyle = color;
    pctx.lineWidth = 1;
    pctx.beginPath();
    pctx.arc(centerX, centerY, radius - 1, 0, Math.PI * 2);
    pctx.stroke();
  } else {
    pctx.fillStyle = color;
    pctx.beginPath();
    pctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
    pctx.fill();
  }
}
updateBrushPreview();
updateTimelineCursor();

drawTimeline();
drawYAxis();
drawLogScale();
renderFullSpectrogramToImage();
</script>
</body>
</html>