<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>SpectroDraw â€” Interactive Spectrogram Editor</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
  <style>
  :root{
    --bg:#07080b;
    --panel:#0f1720;
    --muted:#9aa4b2;
    --accent1:#4f46e5;
    --accent2:#9333ea;
    --accent3:#ec4899;
    --glass: rgba(255,255,255,0.03);
    --cta-grad: linear-gradient(90deg,var(--accent1),var(--accent2),var(--accent3));
    --hero-image:url('/assets/spectrogram-hero2.jpg'); /* ðŸ‘ˆ replace with your spectrogram image */
  }
  *{box-sizing:border-box}
  html, body {
  height: 100%;
}

/* replace your body background with this */
body{
  margin:0;
  font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;
  /* radial gradient layer + base color */
  background-image:
    radial-gradient(circle at 8% 10%, rgba(79,70,229,0.06) 0%, rgba(79,70,229,0.06) 20%, transparent 60%),
    linear-gradient(#07080b, #07080b); /* fallback solid color */
  background-repeat: no-repeat;
  background-attachment: fixed;   /* anchor to viewport -> no jumping when page is taller */
  background-size: cover;        /* scale to cover viewport */
  color:#eef2ff;
  -webkit-font-smoothing:antialiased;
  -moz-osx-font-smoothing:grayscale;
  line-height:1.45;
}
  a{color:inherit}
  nav{
    display:flex;
    justify-content:space-between;
    align-items:center;
    padding:1rem 2rem;
    position:sticky;
    top:0;
    z-index:40;
    backdrop-filter: blur(8px);
    background: linear-gradient(180deg, rgba(0,0,0,0.35), rgba(0,0,0,0.15));
    border-bottom: 1px solid rgba(255,255,255,0.02);
  }
  .nav-left{display:flex;align-items:center;gap:1rem}
  .brand{font-weight:800;letter-spacing:0.2px}
  .nav-right{display:flex;gap:1rem;align-items:center}
  .nav-right a{font-weight:600;text-decoration:none;color:#dfe7ff;opacity:0.95}
  .nav-right a:hover{color:var(--accent1)}

  /* ===== HERO (new Soundraw-style) ===== */
  .hero {
    position: relative;
    min-height: 66vh;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
    color: #eef2ff;
  }
  .hero::before {
    content: "";
    position: absolute;
    inset: 0;
    background-image: var(--hero-image);
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    filter: contrast(105%) saturate(110%) brightness(0.72);
    transform: scale(1.02);
    z-index: 0;
  }
  .hero::after {
    content: "";
    position: absolute;
    inset: 0;
    background: linear-gradient(180deg, rgba(6,8,12,0.55), rgba(6,8,12,0.65));
    z-index: 1;
    pointer-events: none;
  }
  .hero-inner {
    position: relative;
    z-index: 2;
    width: 100%;
    max-width: 1200px;
    padding: 6% 5%;
    display: flex;
    flex-direction: column;
    gap: 1rem;
    align-items: center;
    text-align: center;
  }
  .hero-pre {
    color: var(--muted);
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 1.2px;
    font-size: .78rem;
    margin-bottom: .35rem;
  }
  .hero-row {
    display: flex;
    align-items: center;
    gap: 1rem;
    width: 100%;
    justify-content: center;
  }
  .hero-svg { flex: 0 0 auto; width: 3.5rem; opacity: .95; }
  @media(min-width:640px){ .hero-svg{ width: 5rem; } }
  @media(min-width:1024px){ .hero-svg{ width: 7rem; } }
  .hero-title-wrap { flex: 1 1 auto; display:flex; align-items:center; justify-content:center; }
  .hero h1 {
    margin: 0;
    font-weight: 800;
    line-height: 1.02;
    background: var(--cta-grad);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    color: transparent;
    font-size: 2rem;
  }
  @media(min-width:640px){ .hero h1{ font-size: 2.8rem; } }
  @media(min-width:1024px){ .hero h1{ font-size: 4rem; } }
  .hero-sub {
    color: #dbe8ff;
    max-width: 920px;
    font-size: 1.05rem;
    margin-top: .6rem;
  }
  .cta-wrap {
    margin-top: 2rem;
    display:flex;
    gap: 1rem;
    align-items:center;
    justify-content:center;
  }
  .btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  font-size: 20px;
  padding: 1.2rem 2.6rem;
  border-radius: 999px;
  font-weight: 800;
  cursor: pointer;
  text-decoration: none;
  border: none;
}

.btn-primary {
  position: relative;
  background: var(--cta-grad);
  color: #fff;
  border-radius: 999px;
  padding: 1.2rem 2.6rem;
  font-weight: 800;
  cursor: pointer;
  text-decoration: none;
  border: none;
  overflow: hidden;
  transition: transform .4s ease, box-shadow .6s ease, background .4s ease;
  box-shadow:
    0 0 50px rgba(79,70,229,0.5),
    0 0 70px rgba(147,51,234,0.45),
    inset 0 0 50px rgba(147,51,234,0.3);
}

.btn-primary::before {
  content: "";
  position: absolute;
  inset: 3px;
  background: rgba(7, 8, 11, 0.8);
  border-radius: inherit;
  z-index: 0;
  backdrop-filter: blur(4px);
  transition: background .5s ease, box-shadow .5s ease;
}

.btn-primary span {
  position: relative;
  z-index: 1;
}

.btn-primary:hover {
  transform: translateY(-2px);
  box-shadow:
    0 0 15px rgba(79,70,229,0.6),
    0 0 25px rgba(147,51,234,0.7),
    inset 0 0 60px rgba(147,51,234,0.8); /* concentrated inner glow */
}

.btn-primary:hover::before {
  background: rgba(7, 8, 11, 0.3); /* more transparent to let the glow fill in */
}

.btn-ghost {
  background: transparent;
  color: #e9f0ff;
  padding: .7rem 1.2rem;
  border-radius: 999px;
}


  /* ===== Rest of your styles remain the same ===== */
  section { padding:3.25rem 1rem; }
  .container { max-width:1200px; margin:0 auto; }
  .customize {
    display:grid;
    grid-template-columns: 1fr;
    gap:1.25rem;
    align-items:center;
  }
  @media(min-width:920px){
    .customize{grid-template-columns: 1fr 1fr; gap:2.25rem;}
  }
  .glow-panel{
    border-radius:14px;
    position:relative;
    overflow:hidden;
    min-height:200px;
    border:1px solid rgba(255,255,255,0.03);
    background: linear-gradient(180deg, rgba(255,255,255,0.015), rgba(255,255,255,0.01));
    box-shadow: 0 14px 30px rgba(3,6,23,0.6);
  }
  .glow-panel:before{
    content:"";
    position:absolute;
    inset:-30%;
    background: conic-gradient(from 120deg, rgba(79,70,229,0.14), rgba(236,72,153,0.06), rgba(147,51,234,0.1));
    filter: blur(60px);
    opacity:0.9;
    pointer-events:none;
    transform: rotate(18deg);
  }
  .glow-media{
    position:relative;
    z-index:2;
    padding:1rem;
  }
  .section-title { color:var(--muted); font-weight:700; letter-spacing:1.2px; text-transform:uppercase; margin-bottom:0.4rem; font-size:0.8rem; }
  .section-head { font-size:1.9rem; font-weight:800; margin:0 0 0.6rem 0; }
  .section-copy{ color:#cbd5e1; max-width:62ch; margin-bottom:0.8rem; }
  .tile-grid{display:grid;grid-template-columns: repeat(1,1fr);gap:1rem;}
  @media(min-width:900px){ .tile-grid{ grid-template-columns: repeat(4,1fr); } }
  .tile{border-radius:12px;overflow:hidden;min-height:160px;background:#07101a;border:1px solid rgba(255,255,255,0.03);position:relative;}
  .tile img{ width:100%; height:100%; object-fit:cover; display:block; opacity:0.95; }
  .carousel{display:flex;gap:1rem;overflow:auto;padding-bottom:0.25rem;}
  .sample{min-width:180px;background:var(--panel);border-radius:10px;padding:0.6rem;border:1px solid rgba(255,255,255,0.03);}
  .mission-card,.coming-card,.social-card{background:linear-gradient(180deg,rgba(255,255,255,0.01),rgba(255,255,255,0.01));border-radius:12px;padding:1rem;border:1px solid rgba(255,255,255,0.03);color:#dbe8ff;}
  footer{padding:2rem 1rem;text-align:center;color:var(--muted);margin-top:2rem;border-top:1px solid rgba(255,255,255,0.02);}
  .center{display:flex;align-items:center;justify-content:center}
  .btn-youtube {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 0.8rem 1.6rem;
  border-radius: 999px;
  font-weight: 800;
  text-decoration: none;
  color: #000;
  background: #fff;
  font-size: 1rem;
  transition: background 0.2s ease, transform 0.1s ease;
}

.btn-youtube:hover {
  background: #f0f0f0;
  transform: translateY(-2px);
}

</style>

</head>
<body>
  <nav>
    <div class="nav-left">
      <div class="brand">SpectroDraw</div>
      <div style="opacity:.6;margin-left:.6rem;color:var(--muted)">Interactive Spectrogram Editor</div>
    </div>
    <div class="nav-right">
      <a href="/app">Launch App</a>
      <a href="/docs">Docs</a>
      <a href="/pricing">Pricing</a>
      <a href="/login">Sign in</a>
    </div>
  </nav>

  <!-- HERO -->
  <header class="hero" role="banner" aria-label="SpectroDraw hero" style="height: 700px;">
    <div class="hero-inner">
      <!-- Top pretext (uppercase) -->
      <div class="hero-pre center">The World's First Spectrogram-Based Audio Editor</div>

      <!-- main row with left SVG, headline in center, right SVG -->
      <div class="hero-row" role="presentation" aria-hidden="true">

        <div class="hero-title-wrap" style="padding:0 0.75rem;">
          <h1>
            <span style="white-space:nowrap;display:block">Create & Shape</span>
            <span style="white-space:nowrap;display:block">Unique Sounds Visually</span>
          </h1>
        </div>
      </div>


      <!-- descriptive subtext -->
      <p class="hero-sub center" style="margin-top:0.9rem;">
        SpectroDrawâ€™s interactive spectrogram lets you paint frequency content directly â€” perfect for sound designers, music makers, and audio tinkerers. Create sound effects, convert to midi, and more.
      </p>

      <!-- CTA -->
      <div class="cta-wrap" role="region" aria-label="primary actions">
        <a href="/app" class="btn btn-primary" title="Try SpectroDraw for free"><span>Try it for free</span></a>
      </div>
    </div>
  </header>

  <!-- CUSTOMIZE SECTION -->
  <section aria-labelledby="customize-heading" style="padding: 100px 30px;">
    <div style="display:flex; flex-direction:column; align-items:center; text-align:center; max-width:900px; margin:0 auto; gap:1.5rem;">
      <!-- Text & Button -->
      <div>
        <div class="section-title">Edit &amp; Personalize</div>
        <h2 id="customize-heading" class="section-head">Fine-tune frequency content visually</h2>
        <p class="section-copy">Use SpectroDrawâ€™s tools (brush, rectangle, line, blur, amplifier, and image overlay) to craft textures and fx quickly.</p>
        <div style="margin-top:1rem;">
          <button class="btn btn-primary" onclick="location.href='/app'"><span>Start Creating</span></button>
        </div>
      </div>

      <!-- Video -->
      <video
        id="dbgVideo"
        playsinline
        muted
        autoplay
        loop
        preload="metadata"
        controlslist="nodownload nofullscreen noremoteplayback"
        style="
          width:100%;
          border-radius:10px;
          box-shadow: 0 0 80px rgb(0, 29, 245),
                      0 0 120px rgba(229, 255, 0, 0.8);
          outline: none; margin-top:30px;
        "
      >
        <source src="/assets/freqedit.mp4" type="video/mp4">
        Your browser doesn't support the video tag.
      </video>
    </div>
  </section>

<!-- ===== GENERATE / GRID SECTION (REPLACEMENT) ===== -->
<section aria-labelledby="generate-heading"></section>
<!-- ===== UPDATED MIDI SECTION (with per-canvas scrub + float16 pcm) ===== -->
<section id="midiSection" aria-labelledby="generate-heading" style="padding:40px 30px;">
  <div class="container" style="max-width:1100px;margin:0 auto;">
    <div style="display:flex;gap:1rem;align-items:center;flex-direction:column">
      <div class="section-title">Spectral Workflows</div>
      <h3 id="generate-heading" class="section-head" style="text-align:center">Create Clean MIDIs with ease</h3>
      <p class="section-copy" style="text-align:center">Generate clean MIDIs from songs easily with automatic note filtering options.</p>
    </div>

    <!-- two canvases side-by-side + arrow img between -->
    <div class="midi-row" style="display:flex;gap:12px;align-items:center;justify-content:space-between;margin-top:20px;flex-wrap:wrap;">
      <!-- LEFT: Original -->
      <div class="midi-panel glow-panel" style="flex:1 1 440px; padding:16px; display:flex;flex-direction:column;align-items:stretch;gap:12px;">
        <div style="display:flex;align-items:center;justify-content:space-between;">
          <div style="font-weight:700">Original</div>
        </div>

        <!-- original canvas -->
        <canvas id="originalCanvas" width="640" height="200"
          style="width:100%;height:200px;border-radius:8px;background:#06070a;border:1px solid rgba(255,255,255,0.02)">
        </canvas>

        <!-- progress scrub for original -->
        <div style="display:flex;align-items:center;gap:8px;">
          <input id="originalScrub" type="range" min="0" max="10" step="0.01" value="0"
            style="flex:1" aria-label="Original scrub"/>
          <div style="width:75px;text-align:right;color:var(--muted)" id="originalTime">0:00</div>
        </div>

        <!-- play + upload buttons side by side -->
        <div style="display:flex;align-items:center;justify-content:center;gap:10px;margin-top:6px;">
          <label for="audioUpload" class="btn btn-primary" style="cursor:pointer;font-size:15px;">
            <span>Upload audio</span>
            <input id="audioUpload" type="file" accept="audio/*" style="display:none" />
          </label>
          <button id="playOriginalBtn" class="btn btn-primary" aria-label="Play Original" style="font-size:15px;"><span>Play original</span></button>
        </div>

        <!-- upload note -->
        <div id="upload-note" style="color:var(--muted);font-size:0.9rem;text-align:center;"></div>
      </div>

      <!-- placeholder arrow image between canvases (you said you'll update later) -->
      <div style="flex:0 0 auto;display:flex;align-items:center;justify-content:center;">
        <img id="arrowImg" src="/assets/arrow-white.svg" alt="arrow" style="width:56px;height:56px;object-fit:contain;"/>
      </div>

      <!-- RIGHT: MIDI -->
      <div class="midi-panel glow-panel" style="flex:1 1 440px; padding:16px; display:flex;flex-direction:column;align-items:stretch;gap:12px;">
        <div style="display:flex;align-items:center;justify-content:space-between;">
          <div style="font-weight:700">MIDI</div>
        </div>

        <!-- midi canvas -->
        <canvas id="midiCanvas" width="640" height="200" style="width:100%;height:200px;border-radius:8px;background:#06070a;border:1px solid rgba(255,255,255,0.02)"></canvas>

        <!-- progress scrub for midi -->
        <div style="display:flex;align-items:center;gap:8px;">
          <input id="midiScrub" type="range" min="0" max="10" step="0.01" value="0" style="flex:1" aria-label="MIDI scrub"/>
          <div style="width:75px;text-align:right;color:var(--muted)" id="midiTime">0:00</div>
        </div>

        <!-- play/pause for midi -->
        <div style="display:flex;align-items:center;gap:10px;justify-content:center;margin-top:6px;">
          <!-- This button now plays the notes returned from getNotes() using a piano synth -->
          <button id="midiPlayPause" class="btn btn-primary" aria-label="Play/Pause MIDI" style="font-size:15px;"><span>Play MIDI</span></button>

          <div id="midi-time" style="color:var(--muted);font-size:0.95rem">0:00 / 0:10</div>
        </div>
      </div>
    </div>

    <!-- try it yourself CTA (placed below the two canvases) -->
    <div style="margin:68px 0 80px 0;display:flex;gap:1rem;align-items:center;justify-content:center;">
      <a class="btn btn-primary" href="/app"><span>Try Yourself</span></a>
    </div>
  </div>

  <!-- hidden audio elements used for playback / duration control -->
  <audio id="originalAudio" preload="metadata" src="assets/default.mp3"></audio>
  <audio id="midiAudio" preload="metadata" src="assets/default.mp3"></audio>
</section>
<script src="app/fft.js"></script>
<!-- <script type="module" src="public/bundle.js"></script> -->
 <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>

<!-- then load your midi.js (non-module is fine) -->
<script src="app/midi.js"></script>
<script>
  let pcm = null, x=0,pos=0,hop=2048,fftSize=8192,framesTotal=0,sampleRate=48000,noiseFloor=-20,a4p=440,npo=12;useVolumeControllers=false;
  let dCutoff=0.125;specWidth=468;specHeight=8192;imageBuffer=null;midiSnapshot=null;midiAlignTime=true;mSubBeat=4;midiBpm=124;
  const ctx = originalCanvas.getContext("2d");
(function(){
  const MAX_SECONDS = 10.0;
  let effectiveDuration = MAX_SECONDS; // <-- use this for all UI/playhead mapping (min(MAX_SECONDS, actual audio length))

  const originalAudio = document.getElementById('originalAudio');
  const midiAudio = document.getElementById('midiAudio');
  const uploadInput = document.getElementById('audioUpload');
  const midiFileName = document.getElementById('midi-file-name');
  const notesPlayPauseBtn = document.getElementById('midiPlayPause'); // renamed for clarity in code
  const playOriginalBtn = document.getElementById('playOriginalBtn'); // new button
  const midiTime = document.getElementById('midi-time');
  const originalScrub = document.getElementById('originalScrub');
  const midiScrub = document.getElementById('midiScrub');
  const originalTime = document.getElementById('originalTime');
  const midiTimeDisplay = document.getElementById('midiTime');
  const uploadNote = document.getElementById('upload-note');
  const originalCanvas = document.getElementById('originalCanvas');
  const midiCanvas = document.getElementById('midiCanvas');
  const arrowImg = document.getElementById('arrowImg');

  // set up resize so both canvases share the same pixel width (keeps them visually identical)
  function resizeCanvases(){
    const row = document.querySelector('.midi-row');
    if(!row) return;
    const style = getComputedStyle(row);
    const gap = parseInt(style.gap || 12,10) || 12;
    const arrowW = arrowImg ? (arrowImg.clientWidth || 56) : 56;
    const totalW = row.clientWidth;
    const availableForPanels = Math.max(0, totalW - arrowW - gap*2);
    const panelW = Math.floor(availableForPanels / 2);

    [originalCanvas, midiCanvas].forEach(c => {
      c.style.width = '100%';
      const pixelW = Math.max(32, panelW - 32);
      c.width = pixelW;
    });
  }
  window.addEventListener('resize', resizeCanvases);
  setTimeout(resizeCanvases, 50);

  // update effectiveDuration from pcm or audio metadata
  function updateEffectiveDuration(){
    if(pcm && pcm.length && sampleRate){
      effectiveDuration = Math.min(MAX_SECONDS, pcm.length / sampleRate);
    } else if (originalAudio && isFinite(originalAudio.duration) && originalAudio.duration > 0){
      effectiveDuration = Math.min(MAX_SECONDS, originalAudio.duration);
    } else if (midiAudio && isFinite(midiAudio.duration) && midiAudio.duration > 0){
      effectiveDuration = Math.min(MAX_SECONDS, midiAudio.duration);
    } else {
      effectiveDuration = MAX_SECONDS;
    }
    // update scrub ranges and displays to reflect new duration
    originalScrub.max = effectiveDuration;
    midiScrub.max = effectiveDuration;
  }

  // enforce max during playback: now uses effectiveDuration (so short files end naturally)
  function enforceMaxDuringPlayback(audio){
    function timeUpdateHandler(){
      if(audio.currentTime >= effectiveDuration){
        audio.pause();
        audio.currentTime = effectiveDuration;
      }
    }
    audio.addEventListener('timeupdate', timeUpdateHandler);
  }
  enforceMaxDuringPlayback(originalAudio);
  enforceMaxDuringPlayback(midiAudio);

  // ---------- NOTE PLAYBACK (WebAudio piano-like synth) ----------
  let audioCtx = null;
  let scheduledNodes = []; // holds {oscNodes:[], gainNode, stopAt}
  let notesPlaying = false;
  let notesStartTime = 0; // audioCtx.currentTime when notes started
  let notesStartOffset = 0; // scrub offset in seconds when started
  let notesProgressInterval = null;

  function midiToFreq(m){
    return 440 * Math.pow(2, (m - 57) / 12);
  }

  function stopScheduledNotes(){
    if(!audioCtx) return;
    for(const s of scheduledNodes){
      try {
        if(s.gain) {
          s.gain.gain.cancelScheduledValues(audioCtx.currentTime);
          s.gain.gain.setValueAtTime(0, audioCtx.currentTime);
        }
        for(const o of s.oscNodes || []) {
          try { o.stop(); } catch(e) {}
          try { o.disconnect(); } catch(e) {}
        }
        if(s.gain && s.gain.disconnect) s.gain.disconnect();
      } catch(e){}
    }
    scheduledNodes.length = 0;
  }

  function updateNotesButtonText(){
    const span = notesPlayPauseBtn.querySelector('span');
    span.textContent = notesPlaying ? 'Pause MIDI' : 'Play MIDI';
  }
  function updateOriginalButtonText(){
    const span = playOriginalBtn.querySelector('span');
    span.textContent = originalAudio && !originalAudio.paused ? 'Pause original' : 'Play original';
  }

  // update midi-time / midi-scrub either from midiAudio or from notes playback
  function updateTimeDisplays(){
    // ensure effectiveDuration is current
    updateEffectiveDuration();

    // original time (left)
    originalTime.textContent = formatTime(Math.min(originalAudio.currentTime || 0, effectiveDuration), effectiveDuration);
    if(!originalScrubSeeking){
      originalScrub.value = Math.min(originalAudio.currentTime || 0, effectiveDuration);
    }
    drawOriginalPlayhead(originalAudio.currentTime || 0);
    originalScrub.max = effectiveDuration;
    midiScrub.max = effectiveDuration;

    if(notesPlaying && audioCtx) {
      const elapsed = Math.min(effectiveDuration, notesStartOffset + (audioCtx.currentTime - notesStartTime));
      midiTimeDisplay.textContent = formatTime(elapsed, effectiveDuration);
      midiTime.textContent = `${formatTime(elapsed, effectiveDuration)} / ${formatTime(effectiveDuration, effectiveDuration)}`;
      midiScrub.value = elapsed;      
      drawMidiPlayhead(elapsed);
      // if we've reached effectiveDuration, stop
      if(elapsed >= effectiveDuration) {
        stopNotesPlayback();
      }
    } else {
      // fallback to midiAudio element time for display (kept for compatibility)
      const t = Math.min(midiAudio.currentTime || 0, effectiveDuration);
      midiTimeDisplay.textContent = formatTime(t, effectiveDuration);
      midiTime.textContent = `${formatTime(t, effectiveDuration)} / ${formatTime(effectiveDuration, effectiveDuration)}`;
      midiScrub.value = t;
      drawMidiPlayhead(t);
    }
  }

  // Start notes playback from current midiScrub value
  async function startNotesPlayback(){
    try { if(typeof removeHarmonics === 'function') removeHarmonics(); } catch(e){}

    // handle getNotes possibly returning a Promise
    let notes = null;
    try {
      if (typeof getNotes === 'function') {
        const maybe = getNotes();
        if (maybe && typeof maybe.then === 'function') {
          // it's a Promise â€” await it
          notes = await maybe;
        } else {
          // synchronous array/return
          notes = maybe;
        }
      } else {
        notes = null;
      }
    } catch (err) {
      console.warn('Error loading notes:', err);
      notes = null;
    }

    if(!notes || !Array.isArray(notes) || notes.length === 0){
      uploadNote.textContent = 'No MIDI notes available to play.';
      setTimeout(()=> uploadNote.textContent = '', 2400);
      return;
    }

    if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    // ensure resume on user gesture (this handler is triggered by a user click)
    if(audioCtx.state === 'suspended') {
      try { await audioCtx.resume(); } catch(e) { console.warn('audioCtx.resume() failed:', e); }
    }

    // stop any previous scheduled notes
    stopScheduledNotes();

    notesPlaying = true;
    // start from scrub position but clamp to effectiveDuration
    notesStartOffset = Math.min(parseFloat(midiScrub.value || 0), effectiveDuration);
    notesStartTime = audioCtx.currentTime;

    // ADSR values
    const attack = 0.006;
    const decay = 0.18;
    const sustainLevel = 0.24;
    const release = 0.28;
    const minFloor = 0.0001; // small floor for exponential ramps

    for(const note of notes){
      const start = (typeof note.startTime === 'number') ? note.startTime : 0;
      const dur = (typeof note.lengthSeconds === 'number') ? note.lengthSeconds : 0.5;
      const noteEnd = start + dur;
      if(noteEnd <= notesStartOffset) continue; // note finished before our offset

      const relativeStart = Math.max(0, start - notesStartOffset);
      const when = audioCtx.currentTime + relativeStart;
      const freq = midiToFreq(Math.round(note.midiFloat || 60));

      const vel = note.velocity;
      const velNorm = Math.max(0.01, Math.min(1, vel / 127));
      const peakGain = velNorm;

      const gainNode = audioCtx.createGain();
      gainNode.gain.setValueAtTime(minFloor, audioCtx.currentTime);
      gainNode.connect(audioCtx.destination);

      const osc = audioCtx.createOscillator();
      osc.type = 'sine';              // simple sine oscillator per request
      osc.frequency.setValueAtTime(freq, audioCtx.currentTime);

      osc.connect(gainNode);

      const noteOn = when;
      const noteOff = when + Math.max(0.01, dur);

      const startTime = Math.max(audioCtx.currentTime, noteOn - 0.005);
      try { osc.start(startTime); } catch(e){}

      gainNode.gain.setValueAtTime(minFloor, startTime);
      gainNode.gain.exponentialRampToValueAtTime(Math.max(minFloor, peakGain), noteOn + attack);
      gainNode.gain.exponentialRampToValueAtTime(Math.max(minFloor, peakGain * sustainLevel), noteOn + attack + decay);
      gainNode.gain.setValueAtTime(gainNode.gain.value, Math.max(audioCtx.currentTime, noteOff - release));
      gainNode.gain.exponentialRampToValueAtTime(minFloor, noteOff + 0.05);

      try { osc.stop(noteOff + 0.1); } catch(e){}

      scheduledNodes.push({ oscNodes: [osc], gain: gainNode, stopAt: noteOff + 0.1 });
    }

    // UI update loop for notes
    notesProgressInterval = setInterval(updateTimeDisplays, 120);
    updateNotesButtonText();
  }


  function stopNotesPlayback(){
    if(audioCtx && notesPlaying){
      const elapsed = Math.min(effectiveDuration, notesStartOffset + (audioCtx.currentTime - notesStartTime));
      midiScrub.value = elapsed;
    }
    notesPlaying = false;
    stopScheduledNotes();
    if(notesProgressInterval){ clearInterval(notesProgressInterval); notesProgressInterval = null; }
    updateNotesButtonText();
    updateTimeDisplays();
  }

  // notes Play/Pause button handler
  notesPlayPauseBtn.addEventListener('click', async ()=>{
    if(!notesPlaying){
      await startNotesPlayback();
    } else {
      stopNotesPlayback();
    }
  });

  // ---------- ORIGINAL PLAYBACK (reuses originalAudio element) ----------
  playOriginalBtn.addEventListener('click', ()=>{
    // toggle originalAudio play/pause
    if(originalAudio.paused){
      if(originalAudio.currentTime >= effectiveDuration) originalAudio.currentTime = 0;
      originalAudio.play();
    } else {
      originalAudio.pause();
    }
    updateOriginalButtonText();
  });

  // Update original button text when originalAudio plays/pauses/ends
  originalAudio.addEventListener('play', updateOriginalButtonText);
  originalAudio.addEventListener('pause', updateOriginalButtonText);
  originalAudio.addEventListener('ended', updateOriginalButtonText);

  // format time helper (now takes a max param)
  function formatTime(s, max = MAX_SECONDS){
    s = Math.max(0, Math.min(s, max));
    const m = Math.floor(s / 60);
    const sec = Math.floor(s % 60).toString().padStart(2,'0');
    return `${m}:${sec}`;
  }

  // Keep existing midiAudio controls functioning (left as a fallback)
  function updateMidiAudioButton(){
    // not used directly, left for compatibility if you later decide midiAudio is used
  }

  // Update displays every time either audio element updates
  originalAudio.addEventListener('timeupdate', updateTimeDisplays);
  midiAudio.addEventListener('timeupdate', updateTimeDisplays);

  // scrub interactions
  let originalScrubSeeking = false;
  let midiScrubSeeking = false;

  originalScrub.addEventListener('input', ()=> {
    originalScrubSeeking = true;
    const t = parseFloat(originalScrub.value);
    originalTime.textContent = formatTime(t, effectiveDuration);
  });
  originalScrub.addEventListener('change', ()=>{ 
    originalScrubSeeking = false;
    originalAudio.currentTime = Math.min(parseFloat(originalScrub.value), effectiveDuration);
  });

  midiScrub.addEventListener('input', ()=> {
    midiScrubSeeking = true;
    const t = parseFloat(midiScrub.value);
    midiTimeDisplay.textContent = formatTime(t, effectiveDuration);
  });
  midiScrub.addEventListener('change', ()=> {
    midiScrubSeeking = false;
    if(notesPlaying){
      stopNotesPlayback();
    }
    midiAudio.currentTime = Math.min(parseFloat(midiScrub.value), effectiveDuration);
  });

  // When metadata loads, ensure the UI reflects effectiveDuration
  function onMetadataLoadedFor(audioElement){
    updateEffectiveDuration();
    updateTimeDisplays();
  }
  function displayYToBin(y, h) {
    if (!h) return 0;
    const s = 2.0;
    if (s <= 1.0000001) {
        return Math.max(0, Math.min(h - 1, Math.round(h - 1 - y)));
    } else {
        const a = s - 1;
        const denom = Math.log(1 + a * (h - 1));
        if (!isFinite(denom) || denom === 0) return Math.max(0, Math.min(h - 1, Math.round(h - 1 - y)));
        const t = 1 - (y / (h - 1));
        const raw = (Math.exp(t * denom) - 1) / a;
        const clamped = Math.max(0, Math.min(h - 1, Math.round(raw)));
        return clamped;
    }
  }
  function magPhaseToRGB(mag, phase){
    const h = (phase / (2*Math.PI) + 1) % 1; 
    const s = 1;
    const v = Math.min(mag/60,1);
    const c = v*s;
    const m = v - c;
    const hp = h*6;
    const x = c*(1-Math.abs(hp%2-1));
    let r=0,g=0,b=0;
    if(hp < 1){ r=c; g=x; b=0; }
    else if(hp < 2){ r=x; g=c; b=0; }
    else if(hp < 3){ r=0; g=c; b=x; }
    else if(hp < 4){ r=0; g=x; b=c; }
    else if(hp < 5){ r=x; g=0; b=c; }
    else { r=c; g=0; b=x; }
    return [Math.floor((r+m)*255), Math.floor((g+m)*255), Math.floor((b+m)*255)];
  }
  originalAudio.addEventListener('loadedmetadata', ()=>onMetadataLoadedFor(originalAudio));
  midiAudio.addEventListener('loadedmetadata', ()=>onMetadataLoadedFor(midiAudio));
  function drawOriginalPlayhead(timeSec){
    if(!imageBuffer || !ctx) return;
    const t = Math.max(0, Math.min(timeSec || 0, effectiveDuration));
    // width is in spectrogram pixels (restartRender sets originalCanvas.width = framesTotal)
    const w = originalCanvas.width || 1;
    const x = Math.round((t / Math.max(1e-8, effectiveDuration)) * (w - 1));

    // redraw the spectrogram base then overlay playhead
    ctx.putImageData(imageBuffer, 0, 0);

    // thin bright line + faint glow
    ctx.save();
    ctx.globalAlpha = 1.0;
    ctx.fillStyle = 'rgba(255,255,255,0.12)';
    ctx.fillRect(x, 0, 2, originalCanvas.height);
    ctx.globalAlpha = 0.25;
    ctx.fillRect(Math.max(0, x-4), 0, 9, originalCanvas.height);
    ctx.restore();
  }
  function drawMidiPlayhead(timeSec){
    if(!midiCanvas) return;
    const mctx = midiCanvas.getContext('2d');
    const t = Math.max(0, Math.min(timeSec || 0, effectiveDuration));
    const w = midiCanvas.width || 1;
    const x = Math.round((t / Math.max(1e-8, effectiveDuration)) * (w - 1));

    // restore notes layer snapshot if available (prevents ghosting)
    if(midiSnapshot && midiSnapshot.width === midiCanvas.width && midiSnapshot.height === midiCanvas.height){
      mctx.putImageData(midiSnapshot, 0, 0);
    }

    // draw thin bright line + faint glow similar to original playhead
    mctx.save();
    mctx.globalAlpha = 1.0;
    mctx.fillStyle = 'rgba(255,255,255,0.12)';
    mctx.fillRect(x, 0, 2, midiCanvas.height);
    mctx.globalAlpha = 0.22;
    mctx.fillRect(Math.max(0, x - 4), 0, 9, midiCanvas.height);
    mctx.restore();
  }
   async function restartRender(){
    if(!pcm) return;
    win = hann(fftSize);

    framesTotal = Math.max(1, Math.floor((pcm.length - fftSize) / hop) + 1);
    const freqBins = Math.floor(fftSize / 2);
    originalCanvas.width = framesTotal;
    originalCanvas.height = freqBins;

    specWidth = originalCanvas.width;
    specHeight = originalCanvas.height;

    imageBuffer = new ImageData(originalCanvas.width, originalCanvas.height);
    specWidth = originalCanvas.width;
    specHeight = originalCanvas.height;

    mags = new Float32Array(specWidth * specHeight);
    phases = new Float32Array(specWidth * specHeight);
    for(let i=0;i<specWidth*specHeight;i++){ mags[i]=0; phases[i]=0; }

    pos = 0; x = 0;

    ctx.fillStyle = "black";
    ctx.fillRect(0,0,originalCanvas.width,originalCanvas.height);

    const h = specHeight;
    const w = specWidth;

    for (let f = 0; f < specWidth; f++) {
        const re = new Float32Array(fftSize);
        const im = new Float32Array(fftSize);
        for (let i = 0; i < fftSize; i++) { re[i] = (pcm[pos + i] || 0) * win[i]; im[i] = 0; }
        fft_inplace(re, im);

        for (let bin = 0; bin < h; bin++) {
            const mag = Math.hypot(re[bin] || 0, im[bin] || 0);
            const phase = Math.atan2(im[bin] || 0, re[bin] || 0);
            const idx = x * h + bin; 
            mags[idx] = mag;
            phases[idx] = phase;
        }

        for (let yy = 0; yy < h; yy+=4) {
            const mappedBin = displayYToBin(yy, h);
            const idx = x * h + mappedBin;
            const mag = mags[idx] || 0;
            const phase = phases[idx] || 0;
            const [r, g, b] = magPhaseToRGB(mag, phase);
            for (let i = 0; i < 4; i++) {       
              const pix = ((yy+i) * w + x) * 4; 
              imageBuffer.data[pix]     = r;
              imageBuffer.data[pix + 1] = g;
              imageBuffer.data[pix + 2] = b;
              imageBuffer.data[pix + 3] = 255;
            }
        }
        pos += hop; x++;
    }
    
    ctx.clearRect(0, 0, originalCanvas.width, originalCanvas.height);
    ctx.putImageData(imageBuffer, 0, 0);
    drawOriginalPlayhead(0);

    // --- FIX: handle possible Promise from getNotes() ---
    let notes = [];
    try {
      if (typeof getNotes === 'function') {
        const maybe = getNotes();
        // if getNotes() returned a Promise, await it
        if (maybe && typeof maybe.then === 'function') {
          try {
            notes = await maybe;
            if (!Array.isArray(notes)) notes = [];
          } catch (e) {
            console.warn('await getNotes() failed, falling back to empty notes:', e);
            notes = [];
          }
        } else {
          // synchronous result
          notes = maybe || [];
        }
      } else {
        notes = [];
      }
    } catch (err) {
      console.warn('Error obtaining notes, using empty array:', err);
      notes = [];
    }

    // ---------------------- draw notes to midiCanvas ----------------------
    midiCanvas.width = originalCanvas.width;
    const mctx = midiCanvas.getContext('2d');

    mctx.clearRect(0, 0, midiCanvas.width, midiCanvas.height);
    mctx.fillStyle = '#06070a';
    mctx.fillRect(0, 0, midiCanvas.width, midiCanvas.height);

    if (!notes || notes.length === 0) return;

    let minMidi = 0, maxMidi = 127;
    
    const pitchRange = maxMidi - minMidi;

    // use effectiveDuration here (instead of fixed 10s)
    const totalSeconds = effectiveDuration;
    const canvasW = midiCanvas.width;
    const canvasH = midiCanvas.height;

    const noteMinHeight = 6;
    const bandHeight = Math.max(noteMinHeight, Math.round(canvasH / Math.min(48, pitchRange + 1) * 0.9));
    // console.log(notes);
    for (const note of notes) {
      const x = Math.round((note.startTime / Math.max(1e-8,totalSeconds)) * canvasW);
      const w = Math.max(1, Math.round((note.lengthSeconds / Math.max(1e-8,totalSeconds)) * canvasW));

      const pitchNorm = (note.midiFloat - minMidi) / (pitchRange || 1);
      const yCenter = Math.round((1 - pitchNorm) * (canvasH - 1));
      const h = bandHeight;
      const y = Math.max(0, Math.min(canvasH - h, yCenter - Math.round(h / 2)));

      const vel = note.velocity;
      const alpha = Math.max(0.08, Math.min(1, vel / 127));

      mctx.fillStyle = `rgba(120,255,200,${alpha})`;
      mctx.fillRect(x, y, w, h);

      mctx.strokeStyle = `rgba(20,40,60,${0.5 * alpha})`;
      mctx.lineWidth = 1;
      mctx.strokeRect(x + 0.5, y + 0.5, Math.max(1, w - 1), Math.max(1, h - 1));
    }
    try {
      // capture the rendered notes layer so we can restore it before drawing the playhead later
      midiSnapshot = mctx.getImageData(0, 0, midiCanvas.width, midiCanvas.height);
    } catch (e) {
      midiSnapshot = null;
    }

    // draw initial midi playhead at 0
    drawMidiPlayhead(0);
  }
  // Upload handling:
  uploadInput.addEventListener('change', async (e)=>{
    const file = e.target.files && e.target.files[0];
    if(!file) return;

    const url = URL.createObjectURL(file);
    originalAudio.src = url;
    midiAudio.src = url;

    try{
      const ab = await file.arrayBuffer();
      const AC = window.OfflineAudioContext || window.AudioContext || window.webkitOfflineAudioContext || window.webkitAudioContext;
      const audioCtxLocal = new (window.AudioContext || window.webkitAudioContext)();
      const audioBuffer = await audioCtxLocal.decodeAudioData(ab.slice(0));
      sampleRate = audioBuffer.sampleRate || 44100;
      const ch0 = audioBuffer.numberOfChannels > 0 ? audioBuffer.getChannelData(0) : new Float32Array();

      const maxLen = Math.min(ch0.length, Math.floor(sampleRate * MAX_SECONDS));
      const floatSlice = ch0.subarray(0, maxLen);

      pcm = new Float32Array(maxLen);
      pcm.set(floatSlice);

      // update effectiveDuration based on pcm length
      updateEffectiveDuration();

      originalAudio.load();
      midiAudio.load();

      originalAudio.currentTime = 0;
      midiAudio.currentTime = 0;
      midiAudio.pause();
      updateTimeDisplays();
      resizeCanvases();
      restartRender();

    }catch(err){
      console.error('Failed to decode audio file', err);
      uploadNote.textContent = 'Failed to decode audio â€” check file format.';
    }
  });

  // Safety seek clamp
  function clampSeek(audio){
    if(audio.currentTime > effectiveDuration) audio.currentTime = effectiveDuration;
    if(audio.currentTime < 0) audio.currentTime = 0;
  }
  originalAudio.addEventListener('seeked', ()=>clampSeek(originalAudio));
  midiAudio.addEventListener('seeked', ()=>clampSeek(midiAudio));

  // initial UI
  updateTimeDisplays();
  updateNotesButtonText();
  updateOriginalButtonText();
  // initial resize
  async function loadDefaultAsset() {
    try {
      const resp = await fetch('assets/default.mp3');
      if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
      const ab = await resp.arrayBuffer();
      const audioCtxLocal = new (window.AudioContext || window.webkitAudioContext)();
      const audioBuffer = await audioCtxLocal.decodeAudioData(ab.slice(0));
      sampleRate = audioBuffer.sampleRate || 44100;
      const ch0 = audioBuffer.numberOfChannels > 0 ? audioBuffer.getChannelData(0) : new Float32Array();
      const maxLen = Math.min(ch0.length, Math.floor(sampleRate * MAX_SECONDS));
      pcm = new Float32Array(maxLen);
      pcm.set(ch0.subarray(0, maxLen));

      // set effectiveDuration from pcm
      updateEffectiveDuration();

      // make the <audio> elements use the same URL so UI playback still works
      originalAudio.src = 'assets/default.mp3';
      midiAudio.src = 'assets/default.mp3';
      originalAudio.load();
      midiAudio.load();

      // make sure UI and canvases reflect the loaded audio
      resizeCanvases();
      restartRender();
      updateTimeDisplays();
    } catch (err) {
      console.error('Failed to load default asset', err);
      uploadNote.textContent = 'Failed to load default audio. Check assets/default.mp3.';
    }
  }

  // call it once at end of setup
  loadDefaultAsset();

  setTimeout(resizeCanvases, 80);
  setTimeout(restartRender, 80);
})();
</script>



<link rel="stylesheet" type="text/css" href="homepageTimelineStyle.css">
<script src="homepageTimeline.js"></script>

  <!-- MADE FOR / LICENSE NOTE -->
  <section>
    <div class="container" style="display:flex;flex-direction:column;align-items:center;gap:1rem">
      <div class="section-title">Trusted By Creators</div>
      <h3 class="section-head" style="text-align:center">Designed for sound designers & music creators</h3>
      <p class="section-copy" style="text-align:center;max-width:68ch">SpectroDraw is built to accelerate creative workflows, from rapid fx prototyping to sheet music creation. Export clean MIDI, download stems, or bring your spectral edits into a DAW via the upcoming VST.</p>
      <div style="margin-top:.9rem">
        <a class="btn btn-primary" href="/app"><span>Launch App</span></a>
      </div>
    </div>
  </section>

  <!-- OUR MISSION (kept from your earlier content) -->
  <section>
    <div class="container" style="max-width:900px;margin:0 auto">
      <div class="mission-card">
        <h3 style="margin-top:0">Our Mission</h3>
        <p style="margin:.5rem 0 0">Our mission is to make sound design as natural and creative as drawing on a canvas â€” turning audio editing into an intuitive, visual experience accessible to everyone.</p>
        <ul style="margin-top:.6rem">
          <li><strong>World's first spectrogram-based editor:</strong> using an editable spectrogram instead of a waveform as the editing surface.</li>
          <li><strong>Faster sound design:</strong> paint and sculpt frequency content directly.</li>
          <li><strong>Educational tool:</strong> clearly visualizes frequency, harmonics, and time-frequency concepts.</li>
          <li><strong>Accurate audio â†’ MIDI:</strong> convert songs to MIDI with enhanced note filtering that removes extraneous pitch and timing noise.</li>
        </ul>
      </div>
    </div>
  </section>

  <!-- COMING SOON -->
  <section>
    <div class="container" style="display:grid;grid-template-columns:1fr 1fr;gap:1rem">
      <div class="coming-card">
        <h4 style="margin:0">ðŸ”Œ VST plugin</h4>
        <p style="margin:.5rem 0 0">Our goal is to turn SpectroDraw into a VST plugin for DAWs like FL Studio and Logic Pro so you can create and modify sounds directly in your session.</p>
      </div>
      <div class="coming-card">
        <h4 style="margin:0">ðŸ“± iOS App</h4>
        <p style="margin:.5rem 0 0">SpectroDraw will be available on the iOS App Store â€” interactive spectrogram editing on iPhone and iPad.</p>
      </div>
    </div>
  </section>

  <!-- SOCIAL / FOOTER -->
  <section>
  <div style="display:flex;flex-direction:column;align-items:center;gap:0.75rem;text-align:center">
    <h1>My YouTube Channel</h1>
    <!-- Profile image circle -->
    <img src="/assets/randommangos.jpg" alt="RandomMangos" 
        style="width:140px;height:140px;border-radius:999px;object-fit:cover;">

    <!-- Name and subscriber count stacked -->
    <div style="display:flex;flex-direction:column;gap:0.15rem">
      <div style="font-weight:800;font-size:3rem">RandomMangos</div>
      <div style="color:var(--muted);font-size:1.5rem;">66,000 subscribers</div>
    </div>

    <!-- Paragraph -->
    <p style="margin:0;color:#dbe8ff;max-width:680px;">
      I have been making beats, remixes, EDM, and phonk since 2020. One thing I've always wanted is a tool that makes audio editing less complicated and more intuitive.
      As a creator, I know how overwhelming traditional DAWs and audio editors can be, especially when you just want to experiment, remix, or shape sounds quickly.
      That's why I made SpectroDraw, which can let you interact with audio visually and creatively, making the process of editing, remixing, and designing music much more accessible and fun for everyone.
    </p>

    <!-- Buttons (centered) -->
    <div style="display:flex;gap:1.7rem;justify-content:center;margin-top:20px;">
      <a class="btn btn-youtube" href="https://www.youtube.com/channel/UCGmPeEqdsLBMsfUK3DZOw2A" target="_blank" rel="noopener noreferrer">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="red" style="margin-right:8px;">
          <path d="M23.498 6.186c-.275-1.033-1.08-1.847-2.113-2.124C19.6 3.5 12 3.5 12 3.5s-7.6 0-9.386.562c-1.033.277-1.838 1.091-2.113 2.124C0 7.972 0 12 0 12s0 4.028.501 5.814c.275 1.033 1.08 1.847 2.113 2.124C4.4 20.5 12 20.5 12 20.5s7.6 0 9.386-.562c1.033-.277 1.838-1.091 2.113-2.124C24 16.028 24 12 24 12s0-4.028-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"/>
        </svg>
        YouTube
      </a>
      <a class="btn btn-primary" href="/app"><span>Launch App</span></a>
    </div>
  </div>
</section>


  <footer>
    Â© <span id="year"></span> SpectroDraw Â· Built for creative sound design
  </footer>

  <script>
    document.getElementById('year').textContent = new Date().getFullYear();
    // Lightweight accessibility helpers for keyboard activation on .sample elements (no external JS).
    document.querySelectorAll('.sample').forEach(el=>{
      el.tabIndex = 0;
      el.addEventListener('keydown', (e)=>{
        if(e.key === 'Enter' || e.key === ' ') { el.querySelector('img')?.click(); }
      });
    });
  </script>
</body>
</html>
